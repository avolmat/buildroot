From 5c622ac6f99e98474a9f264c31717be183c06737 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Fri, 3 Feb 2023 21:18:06 +0100
Subject: [PATCH 01/16] gpu: drm: sti: add hdmi tx6g0c28 phy for STi platform

Addition of the HDMI TX PHY driver for use in the STiH418
SoC platform and more especially the 4KOpen (B2264) board.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/Makefile               |   1 +
 drivers/gpu/drm/sti/sti_hdmi.c             |   4 +
 drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.c | 423 +++++++++++++++++++++
 drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.h |  14 +
 4 files changed, 442 insertions(+)
 create mode 100644 drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.c
 create mode 100644 drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.h

diff --git a/drivers/gpu/drm/sti/Makefile b/drivers/gpu/drm/sti/Makefile
index f203ac5514ae..bf52edb7dba5 100644
--- a/drivers/gpu/drm/sti/Makefile
+++ b/drivers/gpu/drm/sti/Makefile
@@ -11,6 +11,7 @@ sti-drm-y := \
 	sti_plane.o \
 	sti_hdmi.o \
 	sti_hdmi_tx3g4c28phy.o \
+	sti_hdmi_tx6g0c28phy.o \
 	sti_dvo.o \
 	sti_awg_utils.o \
 	sti_vtg.o \
diff --git a/drivers/gpu/drm/sti/sti_hdmi.c b/drivers/gpu/drm/sti/sti_hdmi.c
index 8539fe1fedc4..7ffdc5ef819d 100644
--- a/drivers/gpu/drm/sti/sti_hdmi.c
+++ b/drivers/gpu/drm/sti/sti_hdmi.c
@@ -27,6 +27,7 @@
 
 #include "sti_hdmi.h"
 #include "sti_hdmi_tx3g4c28phy.h"
+#include "sti_hdmi_tx6g0c28phy.h"
 #include "sti_vtg.h"
 
 #define HDMI_CFG                        0x0000
@@ -1362,6 +1363,9 @@ static const struct of_device_id hdmi_of_match[] = {
 	{
 		.compatible = "st,stih407-hdmi",
 		.data = &tx3g4c28phy_ops,
+	}, {
+		.compatible = "st,stih418-hdmi",
+		.data = &tx6g0c28phy_ops,
 	}, {
 		/* end node */
 	}
diff --git a/drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.c b/drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.c
new file mode 100644
index 000000000000..560a4e60bf79
--- /dev/null
+++ b/drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.c
@@ -0,0 +1,423 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) Alain Volmat - 2023
+ * Author: Alain Volmat <avolmat@me.com>
+ *
+ * This driver is highly inspired from sti_hdmi_tx3g4c28phy.c
+ * with IP behavior understood by looking the display package
+ * from 4kopen.com
+ * https://bitbucket.org/4kopen/display/src/master/display/ip/hdmi/stmhdmitx6g0_c28_phy.cpp
+ */
+
+#include <drm/drm_print.h>
+#include <linux/delay.h>
+#include <linux/reset.h>
+
+#include "sti_hdmi_tx6g0c28phy.h"
+
+#define HDMI_SRZ_CFG		0x504
+#define HDMI_SRZ_PWR_CFG	0x508
+#define HDMI_SRZ_PLL_CFG	0x510
+#define HDMI_SRZ_STR_1		0x518
+#define HDMI_SRZ_STR_2		0x51C
+#define HDMI_SRZ_CALCODE_EXT	0x530
+#define HDMI_SRZ_TX_RSVR_BITS	0x560
+
+/* ******************************* */
+/* register : HDMI_SRZ_CFG         */
+/* ******************************* */
+#define HDMI_SRZ_CFG_EN				BIT(0)
+#define HDMI_SRZ_CFG_EN_PE_C0_MASK		GENMASK(6, 4)
+#define HDMI_SRZ_CFG_EN_PE_C1_MASK		GENMASK(10, 8)
+#define HDMI_SRZ_CFG_EN_PE_C2_MASK		GENMASK(14, 12)
+
+#define HDMI_SRZ_CFG_EXTERNAL_DATA		BIT(16)
+#define HDMI_SRZ_CFG_RBIAS_EXT			BIT(17)
+#define HDMI_SRZ_CFG_EN_SINK_TERM_DETECTION	BIT(18)
+#define HDMI_SRZ_CFG_ISNKCTRL_MASK		GENMASK(21, 20)
+
+#define HDMI_SRZ_CFG_EN_SRC_TERMINATION_SHIFT    (24)
+#define HDMI_SRZ_CFG_EN_SRC_TERMINATION_VAL_BLW_165MHZ             (0x0)
+#define HDMI_SRZ_CFG_EN_SRC_TERMINATION_VAL_BWN_165MHZ_340MHZ      (0x2)
+#define HDMI_SRZ_CFG_EN_SRC_TERMINATION_VAL_ABV_340MHZ             (0x3)
+
+#define HDMI_SRZ_CFG_CKCH_LOWSW_EN_SHIFT          (29)
+#define HDMI_SRZ_CFG_CKCH_LOWSW_EN_VAL_500MV      (0x0) /* for below or equal 3.4 Gbps */
+#define HDMI_SRZ_CFG_CKCH_LOWSW_EN_VAL_300MV      (0x1) /* for above 3.4 Gbps */
+
+#define HDMI_SRZ_CFG_CKBY10_OR_40_SHIFT             (30)
+#define HDMI_SRZ_CFG_CKBY10_OR_40_VAL_DIV_BY_10     (0x0) /* for below or equal 3.4 Gbps */
+#define HDMI_SRZ_CFG_CKBY10_OR_40_VAL_DIV_BY_40     (0x1) /* for above 3.4 Gbps */
+
+#define HDMI_SRZ_CFG_DATA20BIT10BIT_SHIFT           (31)
+#define HDMI_SRZ_CFG_DATA20BIT10BIT_VAL_10_BPC      (0x0)
+#define HDMI_SRZ_CFG_DATA20BIT10BIT_VAL_20_BPC      (0x1)
+
+/* ******************************* */
+/* register : HDMI_SRZ_PWR_CFG     */
+/* ******************************* */
+
+#define HDMI_SRZ_PWR_CFG_EXT_DATACK_EN	BIT(5)
+#define HDMI_SRZ_PWR_CFG_EXT_DATACK		BIT(6)
+#define HDMI_SRZ_PWR_CFG_PEBYPASS_ENABLE_N	BIT(19)
+
+/* ******************************* */
+/* register : HDMI_SRZ_PLL_CFG     */
+/* ******************************* */
+
+#define HDMI_PLL_CFG_EN		BIT(0)
+#define HDMI_PLL_CFG_NDIV_SHIFT (8)
+#define HDMI_PLL_CFG_IDF_SHIFT  (16)
+#define HDMI_PLL_CFG_ODF_SHIFT  (24)
+
+#define ODF_DIV_1          (0)
+#define ODF_DIV_2          (1)
+#define ODF_DIV_4          (2)
+#define ODF_DIV_8          (3)
+#define ODF_DIV_16         (4)
+
+#define STM_HDMI_NDIV_10   (10)
+#define STM_HDMI_NDIV_15   (15)
+#define STM_HDMI_NDIV_20   (20)
+#define STM_HDMI_NDIV_25   (25)
+#define STM_HDMI_NDIV_30   (30)
+#define STM_HDMI_NDIV_40   (40)
+#define STM_HDMI_NDIV_50   (50)
+
+#define STM_HDMI_MULT_5     (500)
+#define STM_HDMI_MULT_6_25  (625)
+#define STM_HDMI_MULT_7_5   (750)
+#define STM_HDMI_MULT_10    (1000)
+#define STM_HDMI_MULT_12_5  (1250)
+#define STM_HDMI_MULT_15    (1500)
+#define STM_HDMI_MULT_20    (2000)
+#define STM_HDMI_MULT_25    (2500)
+#define STM_HDMI_MULT_30    (3000)
+#define STM_HDMI_MULT_40    (4000)
+#define STM_HDMI_MULT_50    (5000)
+#define STM_HDMI_MULT_60    (6000)
+#define STM_HDMI_MULT_80    (8000)
+
+/* ******************************* */
+/* register : HDMI_SRZ_STR_1       */
+/* ******************************* */
+
+#define HDMI_SRZ_STR1_MSK_PEXC0   GENMASK(11, 0)
+#define HDMI_SRZ_STR1_MSK_PEXC1   GENMASK(27, 16)
+
+
+/* ******************************* */
+/* register : HDMI_SRZ_STR_2       */
+/* ******************************* */
+
+#define HDMI_SRZ_STR2_PEXC2       (0)
+#define HDMI_SRZ_STR2_MSK_PEXC2   (0xFFF<<HDMI_SRZ_STR2_PEXC2)
+
+/* ******************************* */
+/* register : HDMI_SRZ_CALCODE_EXT */
+/* ******************************* */
+
+#define HDMI_SRZ_CALCODE_EXT_MASK        GENMASK(27, 0)
+
+/* ******************************** */
+/* register : HDMI_SRZ_TX_RSVR_BITS */
+/* ******************************** */
+
+#define HDMI_SRZ_TX_RSVR_BITS_BELOW_340MHZ       (0)
+#define HDMI_SRZ_TX_RSVR_BITS_ABOVE_340MHZ       (0x0800000)
+
+/* *********************************** */
+/* Configuration                       */
+/* *********************************** */
+
+/* Config 0 => HDMI_SRZ_CFG */
+#define HDMI_SRZ_CONFIG_0_MASK  (HDMI_SRZ_CFG_EN_PE_C0_MASK | \
+				 HDMI_SRZ_CFG_EN_PE_C1_MASK | \
+				 HDMI_SRZ_CFG_EN_PE_C2_MASK | \
+				 HDMI_SRZ_CFG_ISNKCTRL_MASK)
+/* Config 1 => HDMI_SRZ_STR_1 */
+#define HDMI_SRZ_CONFIG_1_MASK  (HDMI_SRZ_STR1_MSK_PEXC0 | HDMI_SRZ_STR1_MSK_PEXC1)
+
+/* Config 2 => HDMI_SRZ_STR_2 */
+#define HDMI_SRZ_CONFIG_2_MASK  (HDMI_SRZ_STR2_MSK_PEXC2)
+
+/* Config 3 => HDMI_SRZ_CALCODE_EXT */
+#define HDMI_SRZ_CONFIG_3_MASK  (HDMI_SRZ_CALCODE_EXT_MASK)
+
+#define STM_HDMI_THOLD_CLK_600MHZ  (600000000)
+#define STM_HDMI_THOLD_CLK_340MHZ  (340000000)
+#define STM_HDMI_THOLD_CLK_165MHZ  (165000000)
+
+#define HDMI_TIMEOUT_PLL_LOCK  50  /*milliseconds */
+
+struct plldividers_s {
+	u32 min;
+	u32 max;
+	u32 idf;
+	u32 odf;
+};
+
+/*
+ * Functional specification recommended values
+ */
+static struct plldividers_s plldividers[] = {
+	{0, 37500000, 1, ODF_DIV_16 },
+	{37500000, 75000000, 2, ODF_DIV_8 },
+	{75000000, 150000000, 4, ODF_DIV_4 },
+	{150000000, 300000000, 8, ODF_DIV_2 },
+	{300000000, 600000000, 16, ODF_DIV_1 }
+};
+
+
+
+static struct hdmi_phy_config hdmiphy_config[] = {
+	{0, 145000000, {0x0, 0x0, 0x0, 0x0} },
+	{145000000, 165000000, {0x1110, 0x0, 0x0, 0x0} },
+	{165000000, 340000000, {0x1110, 0x30003, 0x3, 0x0} },
+	{340000000, 600000000, {0x200000, 0x0, 0x0, 0x0} },
+};
+
+#if 0
+static struct specificplldividers_s {
+	u32 px_pllin_clk;
+	u32 req_mult;
+	u32 idf;
+	u32 ndiv;
+	u32 odf;
+} specificplldividers[] = {
+	{13500000,	STM_HDMI_MULT_20,	1,	40,	ODF_DIV_16},
+	{13500000,	STM_HDMI_MULT_25,	1,	50,	ODF_DIV_16},
+	{13500000,	STM_HDMI_MULT_30,	1,	30,	ODF_DIV_8},
+	{13500000,	STM_HDMI_MULT_40,	1,	40,	ODF_DIV_8},
+	{13500000,	STM_HDMI_MULT_50,	1,	50,	ODF_DIV_8},
+	{13500000,	STM_HDMI_MULT_60,	1,	30,	ODF_DIV_4},
+	{13500000,	STM_HDMI_MULT_80,	1,	40,	ODF_DIV_4},
+	{16875000,	STM_HDMI_MULT_20,	1,	40,	ODF_DIV_16},
+	{16875000,	STM_HDMI_MULT_40,	1,	40,	ODF_DIV_8},
+	{20250000,	STM_HDMI_MULT_20,	1,	20,	ODF_DIV_8},
+	{20250000,	STM_HDMI_MULT_40,	1,	20,	ODF_DIV_4},
+	{21760000,	STM_HDMI_MULT_20,	1,	20,	ODF_DIV_8},
+	{25200000,	STM_HDMI_MULT_15,	1,	15,	ODF_DIV_8},
+	{25200000,	STM_HDMI_MULT_20,	1,	20,	ODF_DIV_8},
+	{27000000,	STM_HDMI_MULT_15,	1,	15,	ODF_DIV_8},
+	{27000000,	STM_HDMI_MULT_20,	1,	20,	ODF_DIV_8},
+	{27000000,	STM_HDMI_MULT_25,	1,	25,	ODF_DIV_8},
+	{27000000,	STM_HDMI_MULT_30,	1,	15,	ODF_DIV_4},
+	{27000000,	STM_HDMI_MULT_50,	1,	25,	ODF_DIV_4},
+	{27000000,	STM_HDMI_MULT_60,	1,	15,	ODF_DIV_2},
+	{27000000,	STM_HDMI_MULT_80,	1,	20,	ODF_DIV_2},
+	{33750000,	STM_HDMI_MULT_20,	1,	20,	ODF_DIV_8},
+	{40500000,	STM_HDMI_MULT_20,	1,	10,	ODF_DIV_4},
+	{40500000,	STM_HDMI_MULT_40,	1,	10,	ODF_DIV_2},
+	{54000000,	STM_HDMI_MULT_15,	2,	15,	ODF_DIV_4},
+	{54000000,	STM_HDMI_MULT_30,	2,	15,	ODF_DIV_2},
+	{59400000,	STM_HDMI_MULT_15,	2,	15,	ODF_DIV_4},
+	{72000000,	STM_HDMI_MULT_12_5,	4,	25,	ODF_DIV_4},
+	{72000000,	STM_HDMI_MULT_15,	4,	30,	ODF_DIV_4},
+	{74250000,	STM_HDMI_MULT_12_5,	4,	25,	ODF_DIV_4},
+	{74250000,	STM_HDMI_MULT_15,	4,	30,	ODF_DIV_4},
+	{74250000,	STM_HDMI_MULT_20,	4,	40,	ODF_DIV_4},
+	{81000000,	STM_HDMI_MULT_20,	2,	10,	ODF_DIV_2},
+	{108000000,	STM_HDMI_MULT_15,	4,	15,	ODF_DIV_2},
+	{118800000,	STM_HDMI_MULT_15,	4,	15,	ODF_DIV_2},
+	{148500000,	STM_HDMI_MULT_12_5,	8,	25,	ODF_DIV_2},
+	{148500000,	STM_HDMI_MULT_15,	8,	30,	ODF_DIV_2},
+	{148500000,	STM_HDMI_MULT_20,	8,	40,	ODF_DIV_2},
+	{148500000,	STM_HDMI_MULT_25,	8,	25,	ODF_DIV_1},
+	{148500000,	STM_HDMI_MULT_30,	8,	30,	ODF_DIV_1},
+	{148500000,	STM_HDMI_MULT_40,	8,	40,	ODF_DIV_1},
+	{150000000,	STM_HDMI_MULT_50,	4,	20,	ODF_DIV_1},
+	{297000000,	STM_HDMI_MULT_12_5,	16,	25,	ODF_DIV_1},
+	{297000000,	STM_HDMI_MULT_15,	16,	30,	ODF_DIV_1},
+	{297000000,	STM_HDMI_MULT_20,	16,	40,	ODF_DIV_1},
+	{300000000,	STM_HDMI_MULT_20,	16,	40,	ODF_DIV_1},
+	{594000000,	STM_HDMI_MULT_5,	16,	20,	ODF_DIV_2},
+	{594000000,	STM_HDMI_MULT_6_25,	16,	25,	ODF_DIV_2},
+	{594000000,	STM_HDMI_MULT_7_5,	16,	30,	ODF_DIV_2}
+};
+#endif
+
+
+/**
+ * sti_hdmi_tx6g0c28phy_start - Start hdmi phy macro cell tx6g0c28
+ *
+ * @hdmi: pointer on the hdmi internal structure
+ *
+ * Return false if an error occur
+ */
+static bool sti_hdmi_tx6g0c28phy_start(struct sti_hdmi *hdmi)
+{
+	u32 ckpxpll = hdmi->mode.clock * 1000;
+	u32 cfg, val, tmdsck, idf, odf, pllctrl = 0;
+	bool foundplldivides = false;
+	u32 tx_rsvr_bits = HDMI_SRZ_TX_RSVR_BITS_BELOW_340MHZ;
+	int i;
+
+	DRM_DEBUG_DRIVER("ckpxpll = %dHz\n", ckpxpll);
+
+	/*
+	 * FIXME - in case of output format is STM_VIDEO_OUT_420
+	 * ckpxpll is divided by 2 - don't know how to put this
+	 * here yet
+	 * req_mult_by_100 = STM_HDMI_MULT_10; aka 1000
+	 */
+	for (i = 0; i < ARRAY_SIZE(plldividers); i++) {
+		if (ckpxpll >= plldividers[i].min &&
+		    ckpxpll < plldividers[i].max) {
+			idf = plldividers[i].idf;
+			odf = plldividers[i].odf;
+			foundplldivides = true;
+			break;
+		}
+	}
+
+	if (!foundplldivides) {
+		DRM_ERROR("input TMDS clock speed (%d) not supported\n",
+			  ckpxpll);
+		goto err;
+	}
+
+	/* Assuming no pixel repetition and 24bits color */
+	tmdsck = ckpxpll;
+	pllctrl |= 20 << HDMI_PLL_CFG_NDIV_SHIFT;
+
+	if (tmdsck > 600000000) {
+		DRM_ERROR("output TMDS clock (%d) out of range\n", tmdsck);
+		goto err;
+	}
+
+#if 0
+	for (i = 0; i < ARRAY_SIZE(specificplldividers); i++) {
+		if (ckpxpll >= specificplldividers[i].px_pllin_clk &&
+		    req_mult_by_100 == specificplldividers[i].req_mult) {
+			printk(KERN_ERR "%s - Line %d - got specificplldividers\n",
+			       __func__, __LINE__);
+			pllctrl = specificplldividers[i].ndiv << PLL_CFG_NDIV_SHIFT;
+			idf = specificplldividers[i].idf;
+			odf = specificplldividers[i].odf;
+			break;
+		}
+		if (ckpxpll < specificplldividers[i].px_pllin_clk)
+			break;
+	}
+#endif
+
+	pllctrl |= idf << HDMI_PLL_CFG_IDF_SHIFT;
+	pllctrl |= odf << HDMI_PLL_CFG_ODF_SHIFT;
+
+	cfg = (HDMI_SRZ_CFG_EN |
+	       HDMI_SRZ_CFG_EXTERNAL_DATA |
+	       HDMI_SRZ_CFG_RBIAS_EXT |
+	       HDMI_SRZ_CFG_EN_SINK_TERM_DETECTION |
+	       (HDMI_SRZ_CFG_DATA20BIT10BIT_VAL_10_BPC << HDMI_SRZ_CFG_DATA20BIT10BIT_SHIFT));
+
+	if (tmdsck > 340000000) {
+		cfg |= (HDMI_SRZ_CFG_EN_SRC_TERMINATION_VAL_ABV_340MHZ << HDMI_SRZ_CFG_EN_SRC_TERMINATION_SHIFT) |
+		       (HDMI_SRZ_CFG_CKCH_LOWSW_EN_VAL_300MV << HDMI_SRZ_CFG_CKCH_LOWSW_EN_SHIFT) |
+		       (HDMI_SRZ_CFG_CKBY10_OR_40_VAL_DIV_BY_40 << HDMI_SRZ_CFG_CKBY10_OR_40_SHIFT);
+		tx_rsvr_bits = HDMI_SRZ_TX_RSVR_BITS_ABOVE_340MHZ;
+	} else if (tmdsck > 165000000) {
+		cfg |= (HDMI_SRZ_CFG_EN_SRC_TERMINATION_VAL_BWN_165MHZ_340MHZ << HDMI_SRZ_CFG_EN_SRC_TERMINATION_SHIFT) |
+		       (HDMI_SRZ_CFG_CKCH_LOWSW_EN_VAL_500MV << HDMI_SRZ_CFG_CKCH_LOWSW_EN_SHIFT) |
+		       (HDMI_SRZ_CFG_CKBY10_OR_40_VAL_DIV_BY_10 << HDMI_SRZ_CFG_CKBY10_OR_40_SHIFT);
+	} else {
+		cfg |= (HDMI_SRZ_CFG_EN_SRC_TERMINATION_VAL_BLW_165MHZ << HDMI_SRZ_CFG_EN_SRC_TERMINATION_SHIFT) |
+		       (HDMI_SRZ_CFG_CKCH_LOWSW_EN_VAL_500MV << HDMI_SRZ_CFG_CKCH_LOWSW_EN_SHIFT) |
+		       (HDMI_SRZ_CFG_CKBY10_OR_40_VAL_DIV_BY_10 << HDMI_SRZ_CFG_CKBY10_OR_40_SHIFT);
+	}
+
+	/*
+	 * To configure the source termination and pre-emphasis appropriately
+	 * for different high speed TMDS clock frequencies a phy configuration
+	 * table must be provided, tailored to the SoC and board combination.
+	 */
+	for (i = 0; i < ARRAY_SIZE(hdmiphy_config); i++) {
+		if (hdmiphy_config[i].min_tmds_freq <= tmdsck &&
+		    hdmiphy_config[i].max_tmds_freq >= tmdsck) {
+			cfg |= (hdmiphy_config[i].config[0] & HDMI_SRZ_CONFIG_0_MASK);
+			hdmi_write(hdmi, cfg, HDMI_SRZ_CFG);
+			hdmi_write(hdmi, 0, HDMI_SRZ_PWR_CFG);
+
+			val = hdmiphy_config[i].config[1] & HDMI_SRZ_CONFIG_1_MASK;
+			hdmi_write(hdmi, val, HDMI_SRZ_STR_1);
+
+			val = hdmiphy_config[i].config[2] & HDMI_SRZ_CONFIG_2_MASK;
+			hdmi_write(hdmi, val, HDMI_SRZ_STR_2);
+
+			val = hdmiphy_config[i].config[3] & HDMI_SRZ_CONFIG_3_MASK;
+			hdmi_write(hdmi, val, HDMI_SRZ_CALCODE_EXT);
+
+			hdmi_write(hdmi, tx_rsvr_bits, HDMI_SRZ_TX_RSVR_BITS);
+
+			/*
+			 * Configure and power up the PHY PLL
+			 */
+			hdmi->event_received = false;
+			hdmi_write(hdmi, (pllctrl | HDMI_PLL_CFG_EN), HDMI_SRZ_PLL_CFG);
+
+			/* wait PLL interrupt */
+			wait_event_interruptible_timeout(hdmi->wait_event, hdmi->event_received,
+							 msecs_to_jiffies (HDMI_TIMEOUT_PLL_LOCK));
+
+			if ((hdmi_read(hdmi, HDMI_STA) & HDMI_STA_DLL_LCK) == 0) {
+				DRM_ERROR("hdmi phy pll not locked\n");
+				goto err;
+			}
+
+			/* Reset the HDMI_TX_PHY */
+			reset_control_assert(hdmi->reset);
+			usleep_range(15, 20);
+			reset_control_deassert(hdmi->reset);
+
+			return true;
+		}
+	}
+
+	/*
+	 * Default, power up the serializer with no pre-emphasis or
+	 * output swing correction
+	 */
+	hdmi_write(hdmi, cfg, HDMI_SRZ_CFG);
+	hdmi_write(hdmi, 0, HDMI_SRZ_PWR_CFG);
+	hdmi_write(hdmi, 0, HDMI_SRZ_STR_1);
+	hdmi_write(hdmi, 0, HDMI_SRZ_STR_2);
+	hdmi_write(hdmi, 0, HDMI_SRZ_CALCODE_EXT);
+	hdmi_write(hdmi, 0, HDMI_SRZ_TX_RSVR_BITS);
+
+	return true;
+
+err:
+	return false;
+}
+
+/**
+ * sti_hdmi_tx6g0c28phy_stop - Stop hdmi phy macro cell tx6g0c28
+ *
+ * @hdmi: pointer on the hdmi internal structure
+ */
+static void sti_hdmi_tx6g0c28phy_stop(struct sti_hdmi *hdmi)
+{
+	int val = 0;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	hdmi->event_received = false;
+
+	val = HDMI_SRZ_CFG_EN_SINK_TERM_DETECTION;
+	hdmi_write(hdmi, val, HDMI_SRZ_CFG);
+	hdmi_write(hdmi, 0, HDMI_SRZ_PLL_CFG);
+
+	/* wait PLL interrupt */
+	wait_event_interruptible_timeout(hdmi->wait_event,
+					 hdmi->event_received,
+					 msecs_to_jiffies
+					 (HDMI_TIMEOUT_PLL_LOCK));
+
+	if (hdmi_read(hdmi, HDMI_STA) & HDMI_STA_DLL_LCK)
+		DRM_ERROR("hdmi phy pll not well disabled\n");
+}
+
+struct hdmi_phy_ops tx6g0c28phy_ops = {
+	.start = sti_hdmi_tx6g0c28phy_start,
+	.stop = sti_hdmi_tx6g0c28phy_stop,
+};
diff --git a/drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.h b/drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.h
new file mode 100644
index 000000000000..55f622984b6b
--- /dev/null
+++ b/drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) Alain Volmat - 2023
+ * Author: Alain Volmat <avolmat@me.com>
+ */
+
+#ifndef _STI_HDMI_TX6G0C28PHY_H_
+#define _STI_HDMI_TX6G0C28PHY_H_
+
+#include "sti_hdmi.h"
+
+extern struct hdmi_phy_ops tx6g0c28phy_ops;
+
+#endif
-- 
2.40.1

From 4b585c399ad95d0bb51f42a6d66ffe43c031df10 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 20 Apr 2023 18:28:05 +0200
Subject: [PATCH 02/16] drm: sti: add support for VTG on the stih418 platform

VTG integrated into the STiH418 differ in the number of outputs
available and allocation of each output.  Indeed on STiH418, there
are 6 outputs (4 on the STiH407/STiH410) and HDMI is connected to
the 5th output in case of STiH418 while it is on the 1st output
in case of STiH407/STiH410.

Two new compatibles st,stih407-vtg and st,stih418-vtg are added
to differentiate the implementation, while st,vtg is kept for
legacy, behaving as st,stih407-vtg.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/sti_vtg.c | 66 +++++++++++++++++++++++++++++------
 1 file changed, 56 insertions(+), 10 deletions(-)

diff --git a/drivers/gpu/drm/sti/sti_vtg.c b/drivers/gpu/drm/sti/sti_vtg.c
index 5e5f82b6a5d9..fbaa560fca2c 100644
--- a/drivers/gpu/drm/sti/sti_vtg.c
+++ b/drivers/gpu/drm/sti/sti_vtg.c
@@ -60,6 +60,18 @@
 #define VTG_TOP_V_HD_4      0x012c
 #define VTG_BOT_V_HD_4      0x0130
 
+#define VTG_H_HD_5          0x0140
+#define VTG_TOP_V_VD_5      0x0144
+#define VTG_BOT_V_VD_5      0x0148
+#define VTG_TOP_V_HD_5      0x014c
+#define VTG_BOT_V_HD_5      0x0150
+
+#define VTG_H_HD_6          0x0160
+#define VTG_TOP_V_VD_6      0x0164
+#define VTG_BOT_V_VD_6      0x0168
+#define VTG_TOP_V_HD_6      0x016c
+#define VTG_BOT_V_HD_6      0x0170
+
 #define VTG_IRQ_BOTTOM      BIT(0)
 #define VTG_IRQ_TOP         BIT(1)
 #define VTG_IRQ_MASK        (VTG_IRQ_TOP | VTG_IRQ_BOTTOM)
@@ -92,7 +104,12 @@ struct sti_vtg_regs_offs {
 	u32 bot_v_hd;
 };
 
-#define VTG_MAX_SYNC_OUTPUT 4
+struct sti_vtg_data {
+	unsigned int nb_sync_output;
+	unsigned int hdmi_sync_id;
+};
+
+#define VTG_MAX_SYNC_OUTPUT 6
 static const struct sti_vtg_regs_offs vtg_regs_offs[VTG_MAX_SYNC_OUTPUT] = {
 	{ VTG_H_HD_1,
 	  VTG_TOP_V_VD_1, VTG_BOT_V_VD_1, VTG_TOP_V_HD_1, VTG_BOT_V_HD_1 },
@@ -101,7 +118,11 @@ static const struct sti_vtg_regs_offs vtg_regs_offs[VTG_MAX_SYNC_OUTPUT] = {
 	{ VTG_H_HD_3,
 	  VTG_TOP_V_VD_3, VTG_BOT_V_VD_3, VTG_TOP_V_HD_3, VTG_BOT_V_HD_3 },
 	{ VTG_H_HD_4,
-	  VTG_TOP_V_VD_4, VTG_BOT_V_VD_4, VTG_TOP_V_HD_4, VTG_BOT_V_HD_4 }
+	  VTG_TOP_V_VD_4, VTG_BOT_V_VD_4, VTG_TOP_V_HD_4, VTG_BOT_V_HD_4 },
+	{ VTG_H_HD_5,
+	  VTG_TOP_V_VD_5, VTG_BOT_V_VD_5, VTG_TOP_V_HD_5, VTG_BOT_V_HD_5 },
+	{ VTG_H_HD_6,
+	  VTG_TOP_V_VD_6, VTG_BOT_V_VD_6, VTG_TOP_V_HD_6, VTG_BOT_V_HD_6 }
 };
 
 /*
@@ -138,6 +159,7 @@ struct sti_vtg {
 	u32 irq_status;
 	struct raw_notifier_head notifier_list;
 	struct drm_crtc *crtc;
+	struct sti_vtg_data data;
 };
 
 struct sti_vtg *of_vtg_find(struct device_node *np)
@@ -252,7 +274,7 @@ static void vtg_set_mode(struct sti_vtg *vtg,
 	vtg_set_output_window(vtg->regs, mode);
 
 	/* Set hsync and vsync position for HDMI */
-	vtg_set_hsync_vsync_pos(&sync[VTG_SYNC_ID_HDMI - 1], HDMI_DELAY, mode);
+	vtg_set_hsync_vsync_pos(&sync[vtg->data.hdmi_sync_id - 1], HDMI_DELAY, mode);
 
 	/* Set hsync and vsync position for HD DCS */
 	vtg_set_hsync_vsync_pos(&sync[VTG_SYNC_ID_HDDCS - 1], 0, mode);
@@ -264,7 +286,7 @@ static void vtg_set_mode(struct sti_vtg *vtg,
 	vtg_set_hsync_vsync_pos(&sync[VTG_SYNC_ID_DVO - 1], DVO_DELAY, mode);
 
 	/* Progam the syncs outputs */
-	for (i = 0; i < VTG_MAX_SYNC_OUTPUT ; i++) {
+	for (i = 0; i < vtg->data.nb_sync_output ; i++) {
 		writel(sync[i].hsync,
 		       vtg->regs + vtg_regs_offs[i].h_hd);
 		writel(sync[i].vsync_line_top,
@@ -376,9 +398,28 @@ static irqreturn_t vtg_irq(int irq, void *arg)
 	return IRQ_WAKE_THREAD;
 }
 
+static const struct sti_vtg_data stih407_vtg_data = {
+	.nb_sync_output = 4,
+	.hdmi_sync_id = 1,
+};
+
+static const struct sti_vtg_data stih418_vtg_data = {
+	.nb_sync_output = 6,
+	.hdmi_sync_id = 5,
+};
+
+static const struct of_device_id vtg_of_match[] = {
+	{ .compatible = "st,vtg", .data = &stih407_vtg_data, },
+	{ .compatible = "st,stih407-vtg", .data = &stih407_vtg_data, },
+	{ .compatible = "st,stih418-vtg", .data = &stih418_vtg_data, },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, vtg_of_match);
+
 static int vtg_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
 	struct sti_vtg *vtg;
 	struct resource *res;
 	int ret;
@@ -387,6 +428,17 @@ static int vtg_probe(struct platform_device *pdev)
 	if (!vtg)
 		return -ENOMEM;
 
+	/* populate data structure depending on compatibility */
+	BUG_ON(!of_match_node(vtg_of_match, np)->data);
+
+	memcpy(&vtg->data, of_match_node(vtg_of_match, np)->data,
+	       sizeof(struct sti_vtg_data));
+
+	if (vtg->data.nb_sync_output > VTG_MAX_SYNC_OUTPUT) {
+		DRM_ERROR("Invalid number of VTG sync output\n");
+		return -EINVAL;
+	}
+
 	/* Get Memory ressources */
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
@@ -422,12 +474,6 @@ static int vtg_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct of_device_id vtg_of_match[] = {
-	{ .compatible = "st,vtg", },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(of, vtg_of_match);
-
 struct platform_driver sti_vtg_driver = {
 	.driver = {
 		.name = "sti-vtg",
-- 
2.40.1

From 19db8b6b70afb17ff1b2d342f8d2f86baa88f481 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 20 Apr 2023 18:58:33 +0200
Subject: [PATCH 03/16] drm: sti: add compositor support for stih418 platform

On the STiH418, a new clock (proc_mixer) must be enabled in order
to have the plane mixers properly behaving.  Add a new
st,stih418-compositor in order to describe the planes/mixers
available on this platform.  For the time being keep it simple with
only 4 planes and 2 mixers, others will be added in further commits.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/sti_compositor.c | 24 ++++++++++++++++++++++++
 drivers/gpu/drm/sti/sti_compositor.h |  2 ++
 drivers/gpu/drm/sti/sti_crtc.c       | 11 +++++++++++
 3 files changed, 37 insertions(+)

diff --git a/drivers/gpu/drm/sti/sti_compositor.c b/drivers/gpu/drm/sti/sti_compositor.c
index 142a8e1b4436..50d80e384d11 100644
--- a/drivers/gpu/drm/sti/sti_compositor.c
+++ b/drivers/gpu/drm/sti/sti_compositor.c
@@ -43,6 +43,21 @@ static const struct sti_compositor_data stih407_compositor_data = {
 	},
 };
 
+/*
+ * stiH418 compositor properties
+ */
+static const struct sti_compositor_data stih418_compositor_data = {
+	.nb_subdev = 6,
+	.subdev_desc = {
+			{STI_GPD_SUBDEV, (int)STI_GDP_0, 0x00000},
+			{STI_GPD_SUBDEV, (int)STI_GDP_1, 0x10000},
+			{STI_GPD_SUBDEV, (int)STI_GDP_2, 0x20000},
+			{STI_GPD_SUBDEV, (int)STI_GDP_3, 0x30000},
+			{STI_MIXER_MAIN_SUBDEV, STI_MIXER_MAIN, 0x100000},
+			{STI_MIXER_AUX_SUBDEV, STI_MIXER_AUX, 0x110000},
+	},
+};
+
 void sti_compositor_debugfs_init(struct sti_compositor *compo,
 				 struct drm_minor *minor)
 {
@@ -165,6 +180,9 @@ static const struct of_device_id compositor_of_match[] = {
 	{
 		.compatible = "st,stih407-compositor",
 		.data = &stih407_compositor_data,
+	}, {
+		.compatible = "st,stih418-compositor",
+		.data = &stih418_compositor_data,
 	}, {
 		/* end node */
 	}
@@ -232,6 +250,12 @@ static int sti_compositor_probe(struct platform_device *pdev)
 		return PTR_ERR(compo->clk_pix_aux);
 	}
 
+	compo->clk_proc_mixer = devm_clk_get_optional(dev, "proc_mixer");
+	if (IS_ERR(compo->clk_proc_mixer)) {
+		DRM_ERROR("Cannot get proc_mixer clock\n");
+		return PTR_ERR(compo->clk_proc_mixer);
+	}
+
 	/* Get reset resources */
 	compo->rst_main = devm_reset_control_get_shared(dev, "compo-main");
 	/* Take compo main out of reset */
diff --git a/drivers/gpu/drm/sti/sti_compositor.h b/drivers/gpu/drm/sti/sti_compositor.h
index 25bb01bdd013..1fb1d7d76328 100644
--- a/drivers/gpu/drm/sti/sti_compositor.h
+++ b/drivers/gpu/drm/sti/sti_compositor.h
@@ -56,6 +56,7 @@ struct sti_compositor_data {
  * @clk_compo_aux: clock for aux compo
  * @clk_pix_main: pixel clock for main path
  * @clk_pix_aux: pixel clock for aux path
+ * @clk_proc_mixer: clock for the mixers
  * @rst_main: reset control of the main path
  * @rst_aux: reset control of the aux path
  * @mixer: array of mixers
@@ -71,6 +72,7 @@ struct sti_compositor {
 	struct clk *clk_compo_aux;
 	struct clk *clk_pix_main;
 	struct clk *clk_pix_aux;
+	struct clk *clk_proc_mixer;
 	struct reset_control *rst_main;
 	struct reset_control *rst_aux;
 	struct sti_mixer *mixer[STI_MAX_MIXER];
diff --git a/drivers/gpu/drm/sti/sti_crtc.c b/drivers/gpu/drm/sti/sti_crtc.c
index 3c7154f2d5f3..d93764e99b0e 100644
--- a/drivers/gpu/drm/sti/sti_crtc.c
+++ b/drivers/gpu/drm/sti/sti_crtc.c
@@ -67,6 +67,12 @@ sti_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *mode)
 		pix_clk = compo->clk_pix_aux;
 	}
 
+	/* Enable the mixer processing clock (if applicable) */
+	if (clk_prepare_enable(compo->clk_proc_mixer)) {
+		DRM_INFO("Failed to prepare/enable processing mixer clk\n");
+		goto proc_mixer_error;
+	}
+
 	/* Prepare and enable the compo IP clock */
 	if (clk_prepare_enable(compo_clk)) {
 		DRM_INFO("Failed to prepare/enable compositor clk\n");
@@ -97,6 +103,8 @@ sti_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *mode)
 pix_error:
 	clk_disable_unprepare(compo_clk);
 compo_error:
+	clk_disable_unprepare(compo->clk_proc_mixer);
+proc_mixer_error:
 	return -EINVAL;
 }
 
@@ -122,6 +130,9 @@ static void sti_crtc_disable(struct drm_crtc *crtc)
 		clk_disable_unprepare(compo->clk_compo_aux);
 	}
 
+	/* Disable the mixer clock (if applicable) */
+	clk_disable_unprepare(compo->clk_proc_mixer);
+
 	mixer->status = STI_MIXER_DISABLED;
 }
 
-- 
2.40.1

From 0ab4afaebd9ffe76d6775fded77c110216863c8c Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 20 Apr 2023 19:33:35 +0200
Subject: [PATCH 04/16] drm: sti: add STih418 platform support in sti mixer

On the STiH418, since there are more planes attached to the
mixer, the bit field for each depth of is now coded using 4 bits
instead of 3 bits.  Some registers as well differ between STiH407
and STiH418 leading on relying on the st,stih418-compositor compatible
to distinguish proper behavior.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/sti_mixer.c | 71 ++++++++++++++++++++++++++-------
 1 file changed, 57 insertions(+), 14 deletions(-)

diff --git a/drivers/gpu/drm/sti/sti_mixer.c b/drivers/gpu/drm/sti/sti_mixer.c
index 7e5f14646625..9cd780403d7b 100644
--- a/drivers/gpu/drm/sti/sti_mixer.c
+++ b/drivers/gpu/drm/sti/sti_mixer.c
@@ -7,6 +7,7 @@
  */
 
 #include <linux/moduleparam.h>
+#include <linux/of.h>
 #include <linux/seq_file.h>
 
 #include <drm/drm_print.h>
@@ -23,10 +24,12 @@ module_param_named(bkgcolor, bkg_color, int, 0644);
 /* regs offset */
 #define GAM_MIXER_CTL      0x00
 #define GAM_MIXER_BKC      0x04
+#define GAM_MIXER_OFF	   0x08 /* Only for STiH418 */
 #define GAM_MIXER_BCO      0x0C
 #define GAM_MIXER_BCS      0x10
 #define GAM_MIXER_AVO      0x28
 #define GAM_MIXER_AVS      0x2C
+#define GAM_MIXER_CRB2     0x30 /* Only for STiH418 */
 #define GAM_MIXER_CRB      0x34
 #define GAM_MIXER_ACT      0x38
 #define GAM_MIXER_MBP      0x3C
@@ -102,13 +105,22 @@ static void mixer_dbg_ctl(struct seq_file *s, int val)
 		seq_puts(s, "Nothing");
 }
 
-static void mixer_dbg_crb(struct seq_file *s, int val)
+static void mixer_dbg_crb(struct seq_file *s, struct sti_mixer *mixer, u64 val)
 {
 	int i;
+	u32 shift, mask_id;
+
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor")) {
+		shift = 4;
+		mask_id = 0x0f;
+	} else {
+		shift = 3;
+		mask_id = 0x07;
+	}
 
 	seq_puts(s, "\tDepth: ");
 	for (i = 0; i < GAM_MIXER_NB_DEPTH_LEVEL; i++) {
-		switch (val & GAM_DEPTH_MASK_ID) {
+		switch (val & mask_id) {
 		case GAM_DEPTH_VID0_ID:
 			seq_puts(s, "VID0");
 			break;
@@ -133,7 +145,7 @@ static void mixer_dbg_crb(struct seq_file *s, int val)
 
 		if (i < GAM_MIXER_NB_DEPTH_LEVEL - 1)
 			seq_puts(s, " < ");
-		val = val >> 3;
+		val = val >> shift;
 	}
 }
 
@@ -149,6 +161,7 @@ static int mixer_dbg_show(struct seq_file *s, void *arg)
 {
 	struct drm_info_node *node = s->private;
 	struct sti_mixer *mixer = (struct sti_mixer *)node->info_ent->data;
+	u64 val;
 
 	seq_printf(s, "%s: (vaddr = 0x%p)",
 		   sti_mixer_to_str(mixer), mixer->regs);
@@ -161,11 +174,18 @@ static int mixer_dbg_show(struct seq_file *s, void *arg)
 	DBGFS_DUMP(GAM_MIXER_AVO);
 	DBGFS_DUMP(GAM_MIXER_AVS);
 	DBGFS_DUMP(GAM_MIXER_CRB);
-	mixer_dbg_crb(s, sti_mixer_reg_read(mixer, GAM_MIXER_CRB));
+	val = sti_mixer_reg_read(mixer, GAM_MIXER_CRB);
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor")) {
+		DBGFS_DUMP(GAM_MIXER_CRB2);
+		val |= ((u64)sti_mixer_reg_read(mixer, GAM_MIXER_CRB2) << 32);
+	}
+	mixer_dbg_crb(s, mixer, val);
 	DBGFS_DUMP(GAM_MIXER_ACT);
-	DBGFS_DUMP(GAM_MIXER_MBP);
-	DBGFS_DUMP(GAM_MIXER_MX0);
-	mixer_dbg_mxn(s, mixer->regs + GAM_MIXER_MX0);
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih407-compositor")) {
+		DBGFS_DUMP(GAM_MIXER_MBP);
+		DBGFS_DUMP(GAM_MIXER_MX0);
+		mixer_dbg_mxn(s, mixer->regs + GAM_MIXER_MX0);
+	}
 	seq_putc(s, '\n');
 	return 0;
 }
@@ -238,7 +258,16 @@ int sti_mixer_set_plane_depth(struct sti_mixer *mixer, struct sti_plane *plane)
 {
 	int plane_id, depth = plane->drm_plane.state->normalized_zpos;
 	unsigned int i;
-	u32 mask, val;
+	u64 mask, val;
+	u32 shift, mask_id;
+
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor")) {
+		shift = 4;
+		mask_id = 0x0f;
+	} else {
+		shift = 3;
+		mask_id = 0x07;
+	}
 
 	switch (plane->desc) {
 	case STI_GDP_0:
@@ -266,26 +295,37 @@ int sti_mixer_set_plane_depth(struct sti_mixer *mixer, struct sti_plane *plane)
 
 	/* Search if a previous depth was already assigned to the plane */
 	val = sti_mixer_reg_read(mixer, GAM_MIXER_CRB);
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor"))
+		val |= ((u64)sti_mixer_reg_read(mixer, GAM_MIXER_CRB2) << 32);
 	for (i = 0; i < GAM_MIXER_NB_DEPTH_LEVEL; i++) {
-		mask = GAM_DEPTH_MASK_ID << (3 * i);
-		if ((val & mask) == plane_id << (3 * i))
+		mask = mask_id << (shift * i);
+		if ((val & mask) == plane_id << (shift * i))
 			break;
 	}
 
-	mask |= GAM_DEPTH_MASK_ID << (3 * depth);
-	plane_id = plane_id << (3 * depth);
+	mask |= mask_id << (shift * depth);
+	plane_id = plane_id << (shift * depth);
 
 	DRM_DEBUG_DRIVER("%s %s depth=%d\n", sti_mixer_to_str(mixer),
 			 sti_plane_to_str(plane), depth);
 	dev_dbg(mixer->dev, "GAM_MIXER_CRB val 0x%x mask 0x%x\n",
-		plane_id, mask);
+		plane_id, (u32)(mask & 0xffffffff));
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor"))
+		dev_dbg(mixer->dev, "GAM_MIXER_CRB2 val 0x%x mask 0x%x\n",
+			plane_id, (u32)(mask >> 32));
 
 	val &= ~mask;
 	val |= plane_id;
-	sti_mixer_reg_write(mixer, GAM_MIXER_CRB, val);
+	sti_mixer_reg_write(mixer, GAM_MIXER_CRB, val & 0xffffffff);
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor"))
+		sti_mixer_reg_write(mixer, GAM_MIXER_CRB2, val >> 32);
 
 	dev_dbg(mixer->dev, "Read GAM_MIXER_CRB 0x%x\n",
 		sti_mixer_reg_read(mixer, GAM_MIXER_CRB));
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor"))
+		dev_dbg(mixer->dev, "Read GAM_MIXER_CRB2 0x%x\n",
+			sti_mixer_reg_read(mixer, GAM_MIXER_CRB2));
+
 	return 0;
 }
 
@@ -352,6 +392,9 @@ int sti_mixer_set_plane_status(struct sti_mixer *mixer,
 	val |= status ? mask : 0;
 	sti_mixer_reg_write(mixer, GAM_MIXER_CTL, val);
 
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor"))
+		sti_mixer_reg_write(mixer, GAM_MIXER_OFF, 0x02);
+
 	return 0;
 }
 
-- 
2.40.1

From 62612573037802a2a4c79d1147cd6b203aa026bb Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Sun, 28 May 2023 14:37:05 +0000
Subject: [PATCH 05/16] gpu: drm: sti: add support for stih418 in tvout

The tvout for stih407 and stih418 differ in the connection with the
vtg regarding to the hdmi output.  In order to cop with that, introduce
a new compatible st,stih418-tvout in order to have the hdmi_sync_id
being part of the data attached to each compatible.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/sti_tvout.c | 37 ++++++++++++++++++++++++++-------
 1 file changed, 29 insertions(+), 8 deletions(-)

diff --git a/drivers/gpu/drm/sti/sti_tvout.c b/drivers/gpu/drm/sti/sti_tvout.c
index 2499715a69b7..466da4dba047 100644
--- a/drivers/gpu/drm/sti/sti_tvout.c
+++ b/drivers/gpu/drm/sti/sti_tvout.c
@@ -118,6 +118,7 @@ struct sti_tvout {
 	struct drm_encoder *hda;
 	struct drm_encoder *dvo;
 	bool debugfs_registered;
+	unsigned int hdmi_sync_id;
 };
 
 struct sti_tvout_encoder {
@@ -130,6 +131,10 @@ struct sti_tvout_encoder {
 
 #define to_sti_tvout(x) to_sti_tvout_encoder(x)->tvout
 
+struct sti_tvout_data {
+	unsigned int hdmi_sync_id;
+};
+
 /* preformatter conversion matrix */
 static const u32 rgb_to_ycbcr_601[8] = {
 	0xF927082E, 0x04C9FEAB, 0x01D30964, 0xFA95FD3D,
@@ -359,14 +364,14 @@ static void tvout_hdmi_start(struct sti_tvout *tvout, bool main_path)
 		DRM_DEBUG_DRIVER("main vip for hdmi\n");
 		/* select the input sync for hdmi */
 		tvout_write(tvout,
-			    TVO_SYNC_MAIN_VTG_SET_REF | VTG_SYNC_ID_HDMI,
+			    TVO_SYNC_MAIN_VTG_SET_REF | tvout->hdmi_sync_id,
 			    TVO_HDMI_SYNC_SEL);
 		tvo_in_vid_format = TVO_MAIN_IN_VID_FORMAT;
 	} else {
 		DRM_DEBUG_DRIVER("aux vip for hdmi\n");
 		/* select the input sync for hdmi */
 		tvout_write(tvout,
-			    TVO_SYNC_AUX_VTG_SET_REF | VTG_SYNC_ID_HDMI,
+			    TVO_SYNC_AUX_VTG_SET_REF | tvout->hdmi_sync_id,
 			    TVO_HDMI_SYNC_SEL);
 		tvo_in_vid_format = TVO_AUX_IN_VID_FORMAT;
 	}
@@ -833,10 +838,26 @@ static const struct component_ops sti_tvout_ops = {
 	.unbind	= sti_tvout_unbind,
 };
 
+static const struct sti_tvout_data stih407_tvout_data = {
+	.hdmi_sync_id = 1,
+};
+
+static const struct sti_tvout_data stih418_tvout_data = {
+	.hdmi_sync_id = 5,
+};
+
+static const struct of_device_id tvout_of_match[] = {
+	{ .compatible = "st,stih407-tvout", .data = &stih407_tvout_data, },
+	{ .compatible = "st,stih418-tvout", .data = &stih418_tvout_data, },
+	{ /* end node */ }
+};
+MODULE_DEVICE_TABLE(of, tvout_of_match);
+
 static int sti_tvout_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct device_node *node = dev->of_node;
+	const struct sti_tvout_data *data;
 	struct sti_tvout *tvout;
 	struct resource *res;
 
@@ -851,6 +872,12 @@ static int sti_tvout_probe(struct platform_device *pdev)
 
 	tvout->dev = dev;
 
+	/* populate data structure depending on compatibility */
+	data = of_match_node(tvout_of_match, node)->data;
+	BUG_ON(!data);
+
+	tvout->hdmi_sync_id = data->hdmi_sync_id;
+
 	/* get memory resources */
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "tvout-reg");
 	if (!res) {
@@ -878,12 +905,6 @@ static int sti_tvout_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct of_device_id tvout_of_match[] = {
-	{ .compatible = "st,stih407-tvout", },
-	{ /* end node */ }
-};
-MODULE_DEVICE_TABLE(of, tvout_of_match);
-
 struct platform_driver sti_tvout_driver = {
 	.driver = {
 		.name = "sti-tvout",
-- 
2.40.1

From 0219063f2fe212a53f966838e4ce96414d9a9714 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Sun, 28 May 2023 14:40:14 +0000
Subject: [PATCH 06/16] gpu: drm: sti: remove VTG_SYNC_ID_HDMI from sti_vtg.h

Since the synchro signal used for hdmi output and coming from the
VTG differs between the stih407 and stih418 platforms, we cannot
rely anymore on hardcoded value and involve drivers use compatible
to figure out the value.
The macro VTG_SYNC_ID_HDMI can thus be removed.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/sti_vtg.h | 1 -
 1 file changed, 1 deletion(-)

diff --git a/drivers/gpu/drm/sti/sti_vtg.h b/drivers/gpu/drm/sti/sti_vtg.h
index 46faf141b2d9..bd0437bd1c8d 100644
--- a/drivers/gpu/drm/sti/sti_vtg.h
+++ b/drivers/gpu/drm/sti/sti_vtg.h
@@ -10,7 +10,6 @@
 #define VTG_TOP_FIELD_EVENT     1
 #define VTG_BOTTOM_FIELD_EVENT  2
 
-#define VTG_SYNC_ID_HDMI        1
 #define VTG_SYNC_ID_HDDCS       2
 #define VTG_SYNC_ID_HDF         3
 #define VTG_SYNC_ID_DVO         4
-- 
2.40.1

From f297d2ffaba9bfaade24cc5b3ea7f86bd200024b Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Fri, 21 Apr 2023 17:40:07 +0200
Subject: [PATCH 07/16] gpu: drm: sti: add support for GDPPLUS / stih418 GDPs

The STiH418 platform embeds two kinds of graphical planes (GDP),
so called GDPPLUS which has additional (yet unimplemented)
features compared to the GDP, and also the GDP.
Register map of GDPPLUS slightly differ from the GDP even if,
for common functionalities registers name and behavior are the
same (but not at same addresses).  For that purpose, this commit
rework the way of addressing the GDP(PLUS) registers.
For the time being only GDPPLUS are implemented in case of
STiH418, GDPs will be added in a further commit.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/sti_compositor.c |  12 +-
 drivers/gpu/drm/sti/sti_compositor.h |   1 +
 drivers/gpu/drm/sti/sti_gdp.c        | 232 +++++++++++++++------------
 drivers/gpu/drm/sti/sti_gdp.h        |   8 +-
 4 files changed, 149 insertions(+), 104 deletions(-)

diff --git a/drivers/gpu/drm/sti/sti_compositor.c b/drivers/gpu/drm/sti/sti_compositor.c
index 50d80e384d11..c0be9a10f268 100644
--- a/drivers/gpu/drm/sti/sti_compositor.c
+++ b/drivers/gpu/drm/sti/sti_compositor.c
@@ -49,10 +49,10 @@ static const struct sti_compositor_data stih407_compositor_data = {
 static const struct sti_compositor_data stih418_compositor_data = {
 	.nb_subdev = 6,
 	.subdev_desc = {
-			{STI_GPD_SUBDEV, (int)STI_GDP_0, 0x00000},
-			{STI_GPD_SUBDEV, (int)STI_GDP_1, 0x10000},
-			{STI_GPD_SUBDEV, (int)STI_GDP_2, 0x20000},
-			{STI_GPD_SUBDEV, (int)STI_GDP_3, 0x30000},
+			{STI_GPDPLUS_SUBDEV, (int)STI_GDP_0, 0x00000},
+			{STI_GPDPLUS_SUBDEV, (int)STI_GDP_1, 0x10000},
+			{STI_GPDPLUS_SUBDEV, (int)STI_GDP_2, 0x20000},
+			{STI_GPDPLUS_SUBDEV, (int)STI_GDP_3, 0x30000},
 			{STI_MIXER_MAIN_SUBDEV, STI_MIXER_MAIN, 0x100000},
 			{STI_MIXER_AUX_SUBDEV, STI_MIXER_AUX, 0x110000},
 	},
@@ -102,6 +102,7 @@ static int sti_compositor_bind(struct device *dev,
 					     compo->regs + desc[i].offset);
 			break;
 		case STI_GPD_SUBDEV:
+		case STI_GPDPLUS_SUBDEV:
 		case STI_CURSOR_SUBDEV:
 			/* Nothing to do, wait for the second round */
 			break;
@@ -135,7 +136,10 @@ static int sti_compositor_bind(struct device *dev,
 			}
 			break;
 		case STI_GPD_SUBDEV:
+		case STI_GPDPLUS_SUBDEV:
 			primary = sti_gdp_create(drm_dev, compo->dev,
+						 desc[i].type == STI_GPD_SUBDEV ? \
+						 STI_GDP_TYPE_GDP : STI_GDP_TYPE_GDPPLUS,
 						 desc[i].id,
 						 compo->regs + desc[i].offset,
 						 (1 << mixer_id) - 1,
diff --git a/drivers/gpu/drm/sti/sti_compositor.h b/drivers/gpu/drm/sti/sti_compositor.h
index 1fb1d7d76328..fdc655f78579 100644
--- a/drivers/gpu/drm/sti/sti_compositor.h
+++ b/drivers/gpu/drm/sti/sti_compositor.h
@@ -24,6 +24,7 @@ enum sti_compositor_subdev_type {
 	STI_MIXER_MAIN_SUBDEV,
 	STI_MIXER_AUX_SUBDEV,
 	STI_GPD_SUBDEV,
+	STI_GPDPLUS_SUBDEV,
 	STI_VID_SUBDEV,
 	STI_CURSOR_SUBDEV,
 };
diff --git a/drivers/gpu/drm/sti/sti_gdp.c b/drivers/gpu/drm/sti/sti_gdp.c
index 43c72c2604a0..c2619bb63e46 100644
--- a/drivers/gpu/drm/sti/sti_gdp.c
+++ b/drivers/gpu/drm/sti/sti_gdp.c
@@ -6,6 +6,7 @@
  *          for STMicroelectronics.
  */
 
+#define DEBUG
 #include <linux/dma-mapping.h>
 #include <linux/of.h>
 #include <linux/seq_file.h>
@@ -55,6 +56,7 @@ static struct gdp_format_to_str {
 		GDP2STR(ARGB4444)
 		};
 
+/* GDP register offsets */
 #define GAM_GDP_CTL_OFFSET      0x00
 #define GAM_GDP_AGC_OFFSET      0x04
 #define GAM_GDP_VPO_OFFSET      0x0C
@@ -67,8 +69,45 @@ static struct gdp_format_to_str {
 #define GAM_GDP_KEY2_OFFSET     0x2C
 #define GAM_GDP_PPT_OFFSET      0x34
 #define GAM_GDP_CML_OFFSET      0x3C
+#define GAM_GDP_NODE_SIZE	0x40
 #define GAM_GDP_MST_OFFSET      0x68
 
+/* GDPPLUS register offsets */
+#define	GAM_GDPPLUS_CTL_OFFSET	0x00
+#define	GAM_GDPPLUS_AGC_OFFSET	0x04
+#define	GAM_GDPPLUS_VPO_OFFSET	0x08
+#define	GAM_GDPPLUS_VPS_OFFSET	0x0C
+#define	GAM_GDPPLUS_PML_OFFSET	0x10
+#define	GAM_GDPPLUS_PMP_OFFSET	0x14
+#define	GAM_GDPPLUS_SIZE_OFFSET	0x18
+#define	GAM_GDPPLUS_NVN_OFFSET	0x1C
+#define	GAM_GDPPLUS_KEY1_OFFSET	0x20
+#define	GAM_GDPPLUS_KEY2_OFFSET	0x24
+#define	GAM_GDPPLUS_HFP_OFFSET	0x28
+#define	GAM_GDPPLUS_PPT_OFFSET	0x2C
+#define	GAM_GDPPLUS_VFP_OFFSET	0x30
+#define	GAM_GDPPLUS_CML_OFFSET	0x34
+#define	GAM_GDPPLUS_CROP_OFFSET	0x38
+#define	GAM_GDPPLUS_BT0_OFFSET	0x3C
+#define	GAM_GDPPLUS_BT1_OFFSET	0x40
+#define	GAM_GDPPLUS_BT2_OFFSET	0x44
+#define	GAM_GDPPLUS_BT3_OFFSET	0x48
+#define	GAM_GDPPLUS_BT4_OFFSET	0x4C
+#define	GAM_GDPPLUS_HSRC_OFFSET	0x50
+#define	GAM_GDPPLUS_HIP_OFFSET	0x54
+#define	GAM_GDPPLUS_HP1_OFFSET	0x58
+#define	GAM_GDPPLUS_HP2_OFFSET	0x5C
+#define	GAM_GDPPLUS_VSRC_OFFSET	0x60
+#define	GAM_GDPPLUS_VIP_OFFSET	0x64
+#define	GAM_GDPPLUS_VP1_OFFSET	0x68
+#define	GAM_GDPPLUS_VP2_OFFSET	0x6C
+#define GAM_GDPPLUS_NODE_SIZE	0x500
+
+/* Accessor for common registers */
+#define GAM_OFFSET(reg,type)	((type) == STI_GDP_TYPE_GDP ? GAM_GDP_ ## reg ## _OFFSET :\
+				 GAM_GDPPLUS_ ## reg ## _OFFSET)
+#define GAM_OFFSET_U32(reg,type)	(GAM_OFFSET(reg, type) >> 2)
+
 #define GAM_GDP_ALPHARANGE_255  BIT(5)
 #define GAM_GDP_AGC_FULL_RANGE  0x00808080
 #define GAM_GDP_PPT_IGNORE      (BIT(1) | BIT(0))
@@ -79,29 +118,10 @@ static struct gdp_format_to_str {
 #define GDP_NODE_NB_BANK        2
 #define GDP_NODE_PER_FIELD      2
 
-struct sti_gdp_node {
-	u32 gam_gdp_ctl;
-	u32 gam_gdp_agc;
-	u32 reserved1;
-	u32 gam_gdp_vpo;
-	u32 gam_gdp_vps;
-	u32 gam_gdp_pml;
-	u32 gam_gdp_pmp;
-	u32 gam_gdp_size;
-	u32 reserved2;
-	u32 gam_gdp_nvn;
-	u32 gam_gdp_key1;
-	u32 gam_gdp_key2;
-	u32 reserved3;
-	u32 gam_gdp_ppt;
-	u32 reserved4;
-	u32 gam_gdp_cml;
-};
-
 struct sti_gdp_node_list {
-	struct sti_gdp_node *top_field;
+	u32 *top_field;
 	dma_addr_t top_field_paddr;
-	struct sti_gdp_node *btm_field;
+	u32 *btm_field;
 	dma_addr_t btm_field_paddr;
 };
 
@@ -130,6 +150,7 @@ struct sti_gdp {
 	bool is_curr_top;
 	struct sti_gdp_node_list node_list[GDP_NODE_NB_BANK];
 	struct sti_vtg *vtg;
+	enum sti_gdp_type type;
 };
 
 #define to_sti_gdp(x) container_of(x, struct sti_gdp, plane)
@@ -145,8 +166,8 @@ static const uint32_t gdp_supported_formats[] = {
 	DRM_FORMAT_RGB888,
 };
 
-#define DBGFS_DUMP(reg) seq_printf(s, "\n  %-25s 0x%08X", #reg, \
-				   readl(gdp->regs + reg ## _OFFSET))
+#define DBGFS_DUMP(reg, offset) seq_printf(s, "\n  %-25s 0x%08X", #reg, \
+					   readl(gdp->regs + (offset)))
 
 static void gdp_dbg_ctl(struct seq_file *s, int val)
 {
@@ -226,26 +247,28 @@ static int gdp_dbg_show(struct seq_file *s, void *data)
 	seq_printf(s, "%s: (vaddr = 0x%p)",
 		   sti_plane_to_str(&gdp->plane), gdp->regs);
 
-	DBGFS_DUMP(GAM_GDP_CTL);
-	gdp_dbg_ctl(s, readl(gdp->regs + GAM_GDP_CTL_OFFSET));
-	DBGFS_DUMP(GAM_GDP_AGC);
-	DBGFS_DUMP(GAM_GDP_VPO);
-	gdp_dbg_vpo(s, readl(gdp->regs + GAM_GDP_VPO_OFFSET));
-	DBGFS_DUMP(GAM_GDP_VPS);
-	gdp_dbg_vps(s, readl(gdp->regs + GAM_GDP_VPS_OFFSET));
-	DBGFS_DUMP(GAM_GDP_PML);
-	DBGFS_DUMP(GAM_GDP_PMP);
-	DBGFS_DUMP(GAM_GDP_SIZE);
-	gdp_dbg_size(s, readl(gdp->regs + GAM_GDP_SIZE_OFFSET));
-	DBGFS_DUMP(GAM_GDP_NVN);
-	gdp_dbg_nvn(s, gdp, readl(gdp->regs + GAM_GDP_NVN_OFFSET));
-	DBGFS_DUMP(GAM_GDP_KEY1);
-	DBGFS_DUMP(GAM_GDP_KEY2);
-	DBGFS_DUMP(GAM_GDP_PPT);
-	gdp_dbg_ppt(s, readl(gdp->regs + GAM_GDP_PPT_OFFSET));
-	DBGFS_DUMP(GAM_GDP_CML);
-	DBGFS_DUMP(GAM_GDP_MST);
-	gdp_dbg_mst(s, readl(gdp->regs + GAM_GDP_MST_OFFSET));
+	DBGFS_DUMP(CTL, GAM_OFFSET(CTL, gdp->type));
+	gdp_dbg_ctl(s, readl(gdp->regs + GAM_OFFSET(CTL, gdp->type)));
+	DBGFS_DUMP(AGC, GAM_OFFSET(AGC, gdp->type));
+	DBGFS_DUMP(VPO, GAM_OFFSET(VPO, gdp->type));
+	gdp_dbg_vpo(s, readl(gdp->regs + GAM_OFFSET(VPO, gdp->type)));
+	DBGFS_DUMP(VPS, GAM_OFFSET(VPS, gdp->type));
+	gdp_dbg_vps(s, readl(gdp->regs + GAM_OFFSET(VPS, gdp->type)));
+	DBGFS_DUMP(PML, GAM_OFFSET(PML, gdp->type));
+	DBGFS_DUMP(PMP, GAM_OFFSET(PMP, gdp->type));
+	DBGFS_DUMP(SIZE, GAM_OFFSET(SIZE, gdp->type));
+	gdp_dbg_size(s, readl(gdp->regs + GAM_OFFSET(SIZE, gdp->type)));
+	DBGFS_DUMP(NVN, GAM_OFFSET(NVN, gdp->type));
+	gdp_dbg_nvn(s, gdp, readl(gdp->regs + GAM_OFFSET(NVN, gdp->type)));
+	DBGFS_DUMP(KEY1, GAM_OFFSET(KEY1, gdp->type));
+	DBGFS_DUMP(KEY2, GAM_OFFSET(KEY2, gdp->type));
+	DBGFS_DUMP(PPT, GAM_OFFSET(PPT, gdp->type));
+	gdp_dbg_ppt(s, readl(gdp->regs + GAM_OFFSET(PPT, gdp->type)));
+	DBGFS_DUMP(CML, GAM_OFFSET(CML, gdp->type));
+	if (gdp->type == STI_GDP_TYPE_GDP) {
+		DBGFS_DUMP(MST, GAM_GDP_MST_OFFSET);
+		gdp_dbg_mst(s, readl(gdp->regs + GAM_GDP_MST_OFFSET));
+	}
 
 	seq_puts(s, "\n\n");
 	if (!crtc)
@@ -257,26 +280,26 @@ static int gdp_dbg_show(struct seq_file *s, void *data)
 	return 0;
 }
 
-static void gdp_node_dump_node(struct seq_file *s, struct sti_gdp_node *node)
+static void gdp_node_dump_node(struct seq_file *s, u32 *node, enum sti_gdp_type type)
 {
 	seq_printf(s, "\t@:0x%p", node);
-	seq_printf(s, "\n\tCTL  0x%08X", node->gam_gdp_ctl);
-	gdp_dbg_ctl(s, node->gam_gdp_ctl);
-	seq_printf(s, "\n\tAGC  0x%08X", node->gam_gdp_agc);
-	seq_printf(s, "\n\tVPO  0x%08X", node->gam_gdp_vpo);
-	gdp_dbg_vpo(s, node->gam_gdp_vpo);
-	seq_printf(s, "\n\tVPS  0x%08X", node->gam_gdp_vps);
-	gdp_dbg_vps(s, node->gam_gdp_vps);
-	seq_printf(s, "\n\tPML  0x%08X", node->gam_gdp_pml);
-	seq_printf(s, "\n\tPMP  0x%08X", node->gam_gdp_pmp);
-	seq_printf(s, "\n\tSIZE 0x%08X", node->gam_gdp_size);
-	gdp_dbg_size(s, node->gam_gdp_size);
-	seq_printf(s, "\n\tNVN  0x%08X", node->gam_gdp_nvn);
-	seq_printf(s, "\n\tKEY1 0x%08X", node->gam_gdp_key1);
-	seq_printf(s, "\n\tKEY2 0x%08X", node->gam_gdp_key2);
-	seq_printf(s, "\n\tPPT  0x%08X", node->gam_gdp_ppt);
-	gdp_dbg_ppt(s, node->gam_gdp_ppt);
-	seq_printf(s, "\n\tCML  0x%08X\n", node->gam_gdp_cml);
+	seq_printf(s, "\n\tCTL  0x%08X", node[GAM_OFFSET_U32(CTL, type)]);
+	gdp_dbg_ctl(s, node[GAM_OFFSET_U32(CTL, type)]);
+	seq_printf(s, "\n\tAGC  0x%08X", node[GAM_OFFSET_U32(AGC, type)]);
+	seq_printf(s, "\n\tVPO  0x%08X", node[GAM_OFFSET_U32(VPO, type)]);
+	gdp_dbg_vpo(s, node[GAM_OFFSET_U32(VPO, type)]);
+	seq_printf(s, "\n\tVPS  0x%08X", node[GAM_OFFSET_U32(VPS, type)]);
+	gdp_dbg_vps(s, node[GAM_OFFSET_U32(VPS, type)]);
+	seq_printf(s, "\n\tPML  0x%08X", node[GAM_OFFSET_U32(PML, type)]);
+	seq_printf(s, "\n\tPMP  0x%08X", node[GAM_OFFSET_U32(PMP, type)]);
+	seq_printf(s, "\n\tSIZE 0x%08X", node[GAM_OFFSET_U32(SIZE, type)]);
+	gdp_dbg_size(s, node[GAM_OFFSET_U32(SIZE, type)]);
+	seq_printf(s, "\n\tNVN  0x%08X", node[GAM_OFFSET_U32(NVN, type)]);
+	seq_printf(s, "\n\tKEY1 0x%08X", node[GAM_OFFSET_U32(KEY1, type)]);
+	seq_printf(s, "\n\tKEY2 0x%08X", node[GAM_OFFSET_U32(KEY2, type)]);
+	seq_printf(s, "\n\tPPT  0x%08X", node[GAM_OFFSET_U32(PPT, type)]);
+	gdp_dbg_ppt(s, node[GAM_OFFSET_U32(PPT, type)]);
+	seq_printf(s, "\n\tCML  0x%08X\n", node[GAM_OFFSET_U32(CML, type)]);
 }
 
 static int gdp_node_dbg_show(struct seq_file *s, void *arg)
@@ -287,9 +310,9 @@ static int gdp_node_dbg_show(struct seq_file *s, void *arg)
 
 	for (b = 0; b < GDP_NODE_NB_BANK; b++) {
 		seq_printf(s, "\n%s[%d].top", sti_plane_to_str(&gdp->plane), b);
-		gdp_node_dump_node(s, gdp->node_list[b].top_field);
+		gdp_node_dump_node(s, gdp->node_list[b].top_field, gdp->type);
 		seq_printf(s, "\n%s[%d].btm", sti_plane_to_str(&gdp->plane), b);
-		gdp_node_dump_node(s, gdp->node_list[b].btm_field);
+		gdp_node_dump_node(s, gdp->node_list[b].btm_field, gdp->type);
 	}
 
 	return 0;
@@ -397,9 +420,10 @@ static int sti_gdp_get_alpharange(int format)
 static struct sti_gdp_node_list *sti_gdp_get_free_nodes(struct sti_gdp *gdp)
 {
 	int hw_nvn;
+	u32 nvn_off = GAM_OFFSET(NVN, gdp->type);
 	unsigned int i;
 
-	hw_nvn = readl(gdp->regs + GAM_GDP_NVN_OFFSET);
+	hw_nvn = readl(gdp->regs + nvn_off);
 	if (!hw_nvn)
 		goto end;
 
@@ -429,9 +453,10 @@ static
 struct sti_gdp_node_list *sti_gdp_get_current_nodes(struct sti_gdp *gdp)
 {
 	int hw_nvn;
+	u32 nvn_off = GAM_OFFSET(NVN, gdp->type);
 	unsigned int i;
 
-	hw_nvn = readl(gdp->regs + GAM_GDP_NVN_OFFSET);
+	hw_nvn = readl(gdp->regs + nvn_off);
 	if (!hw_nvn)
 		goto end;
 
@@ -456,13 +481,14 @@ struct sti_gdp_node_list *sti_gdp_get_current_nodes(struct sti_gdp *gdp)
 static void sti_gdp_disable(struct sti_gdp *gdp)
 {
 	unsigned int i;
+	u32 ppt_off = GAM_OFFSET_U32(PPT, gdp->type);
 
 	DRM_DEBUG_DRIVER("%s\n", sti_plane_to_str(&gdp->plane));
 
 	/* Set the nodes as 'to be ignored on mixer' */
 	for (i = 0; i < GDP_NODE_NB_BANK; i++) {
-		gdp->node_list[i].top_field->gam_gdp_ppt |= GAM_GDP_PPT_IGNORE;
-		gdp->node_list[i].btm_field->gam_gdp_ppt |= GAM_GDP_PPT_IGNORE;
+		gdp->node_list[i].top_field[ppt_off] |= GAM_GDP_PPT_IGNORE;
+		gdp->node_list[i].btm_field[ppt_off] |= GAM_GDP_PPT_IGNORE;
 	}
 
 	if (sti_vtg_unregister_client(gdp->vtg, &gdp->vtg_field_nb))
@@ -519,11 +545,16 @@ static void sti_gdp_init(struct sti_gdp *gdp)
 	struct device_node *np = gdp->dev->of_node;
 	dma_addr_t dma_addr;
 	void *base;
-	unsigned int i, size;
+	unsigned int i, size, gdp_node_size;
+
+	/* Check the type of GDP */
+	if (gdp->type == STI_GDP_TYPE_GDP)
+		gdp_node_size = GAM_GDP_NODE_SIZE;
+	else
+		gdp_node_size = GAM_GDPPLUS_NODE_SIZE;
 
 	/* Allocate all the nodes within a single memory page */
-	size = sizeof(struct sti_gdp_node) *
-	    GDP_NODE_PER_FIELD * GDP_NODE_NB_BANK;
+	size = gdp_node_size * GDP_NODE_PER_FIELD * GDP_NODE_NB_BANK;
 	base = dma_alloc_wc(gdp->dev, size, &dma_addr, GFP_KERNEL);
 
 	if (!base) {
@@ -541,8 +572,8 @@ static void sti_gdp_init(struct sti_gdp *gdp)
 		gdp->node_list[i].top_field_paddr = dma_addr;
 
 		DRM_DEBUG_DRIVER("node[%d].top_field=%p\n", i, base);
-		base += sizeof(struct sti_gdp_node);
-		dma_addr += sizeof(struct sti_gdp_node);
+		base += gdp_node_size;
+		dma_addr += gdp_node_size;
 
 		if (dma_addr & 0xF) {
 			DRM_ERROR("Mem alignment failed\n");
@@ -551,8 +582,8 @@ static void sti_gdp_init(struct sti_gdp *gdp)
 		gdp->node_list[i].btm_field = base;
 		gdp->node_list[i].btm_field_paddr = dma_addr;
 		DRM_DEBUG_DRIVER("node[%d].btm_field=%p\n", i, base);
-		base += sizeof(struct sti_gdp_node);
-		dma_addr += sizeof(struct sti_gdp_node);
+		base += gdp_node_size;
+		dma_addr += gdp_node_size;
 	}
 
 	if (of_device_is_compatible(np, "st,stih407-compositor")) {
@@ -717,7 +748,7 @@ static void sti_gdp_atomic_update(struct drm_plane *drm_plane,
 	struct drm_gem_dma_object *dma_obj;
 	struct sti_gdp_node_list *list;
 	struct sti_gdp_node_list *curr_list;
-	struct sti_gdp_node *top_field, *btm_field;
+	u32 *top_field, *btm_field;
 	u32 dma_updated_top;
 	u32 dma_updated_btm;
 	int format;
@@ -771,12 +802,12 @@ static void sti_gdp_atomic_update(struct drm_plane *drm_plane,
 		sti_plane_to_str(plane), top_field, btm_field);
 
 	/* build the top field */
-	top_field->gam_gdp_agc = GAM_GDP_AGC_FULL_RANGE;
-	top_field->gam_gdp_ctl = WAIT_NEXT_VSYNC;
+	top_field[GAM_OFFSET_U32(AGC, gdp->type)] = GAM_GDP_AGC_FULL_RANGE;
+	top_field[GAM_OFFSET_U32(CTL, gdp->type)] = WAIT_NEXT_VSYNC;
 	format = sti_gdp_fourcc2format(fb->format->format);
-	top_field->gam_gdp_ctl |= format;
-	top_field->gam_gdp_ctl |= sti_gdp_get_alpharange(format);
-	top_field->gam_gdp_ppt &= ~GAM_GDP_PPT_IGNORE;
+	top_field[GAM_OFFSET_U32(CTL, gdp->type)] |= format;
+	top_field[GAM_OFFSET_U32(CTL, gdp->type)] |= sti_gdp_get_alpharange(format);
+	top_field[GAM_OFFSET_U32(PPT, gdp->type)] &= ~GAM_GDP_PPT_IGNORE;
 
 	dma_obj = drm_fb_dma_get_gem_obj(fb, 0);
 
@@ -786,9 +817,9 @@ static void sti_gdp_atomic_update(struct drm_plane *drm_plane,
 
 	/* pixel memory location */
 	bpp = fb->format->cpp[0];
-	top_field->gam_gdp_pml = (u32) dma_obj->dma_addr + fb->offsets[0];
-	top_field->gam_gdp_pml += src_x * bpp;
-	top_field->gam_gdp_pml += src_y * fb->pitches[0];
+	top_field[GAM_OFFSET_U32(PML, gdp->type)] = (u32) dma_obj->dma_addr + fb->offsets[0];
+	top_field[GAM_OFFSET_U32(PML, gdp->type)] += src_x * bpp;
+	top_field[GAM_OFFSET_U32(PML, gdp->type)] += src_y * fb->pitches[0];
 
 	/* output parameters (clamped / cropped) */
 	dst_w = sti_gdp_get_dst(gdp->dev, dst_w, src_w);
@@ -797,23 +828,25 @@ static void sti_gdp_atomic_update(struct drm_plane *drm_plane,
 	yds = sti_vtg_get_line_number(*mode, dst_y + dst_h - 1);
 	xdo = sti_vtg_get_pixel_number(*mode, dst_x);
 	xds = sti_vtg_get_pixel_number(*mode, dst_x + dst_w - 1);
-	top_field->gam_gdp_vpo = (ydo << 16) | xdo;
-	top_field->gam_gdp_vps = (yds << 16) | xds;
+	top_field[GAM_OFFSET_U32(VPO, gdp->type)] = (ydo << 16) | xdo;
+	top_field[GAM_OFFSET_U32(VPS, gdp->type)] = (yds << 16) | xds;
 
 	/* input parameters */
 	src_w = dst_w;
-	top_field->gam_gdp_pmp = fb->pitches[0];
-	top_field->gam_gdp_size = src_h << 16 | src_w;
+	top_field[GAM_OFFSET_U32(PMP, gdp->type)] = fb->pitches[0];
+	top_field[GAM_OFFSET_U32(SIZE, gdp->type)] = src_h << 16 | src_w;
 
 	/* Same content and chained together */
-	memcpy(btm_field, top_field, sizeof(*btm_field));
-	top_field->gam_gdp_nvn = list->btm_field_paddr;
-	btm_field->gam_gdp_nvn = list->top_field_paddr;
+	memcpy(btm_field, top_field,
+	       gdp->type == STI_GDP_TYPE_GDP ?
+	       GAM_GDP_NODE_SIZE : GAM_GDPPLUS_NODE_SIZE);
+	top_field[GAM_OFFSET_U32(NVN, gdp->type)] = list->btm_field_paddr;
+	btm_field[GAM_OFFSET_U32(NVN, gdp->type)] = list->top_field_paddr;
 
 	/* Interlaced mode */
 	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
-		btm_field->gam_gdp_pml = top_field->gam_gdp_pml +
-					 fb->pitches[0];
+		btm_field[GAM_OFFSET_U32(PML, gdp->type)] =
+			top_field[GAM_OFFSET_U32(PML, gdp->type)] + fb->pitches[0];
 
 	/* Update the NVN field of the 'right' field of the current GDP node
 	 * (being used by the HW) with the address of the updated ('free') top
@@ -829,10 +862,10 @@ static void sti_gdp_atomic_update(struct drm_plane *drm_plane,
 	dma_updated_btm = list->btm_field_paddr;
 
 	dev_dbg(gdp->dev, "Current NVN:0x%X\n",
-		readl(gdp->regs + GAM_GDP_NVN_OFFSET));
+		readl(gdp->regs + GAM_OFFSET(NVN, gdp->type)));
 	dev_dbg(gdp->dev, "Posted buff: %lx current buff: %x\n",
 		(unsigned long) dma_obj->dma_addr,
-		readl(gdp->regs + GAM_GDP_PML_OFFSET));
+		readl(gdp->regs + GAM_OFFSET(PML, gdp->type)));
 
 	if (!curr_list) {
 		/* First update or invalid node should directly write in the
@@ -842,7 +875,7 @@ static void sti_gdp_atomic_update(struct drm_plane *drm_plane,
 
 		writel(gdp->is_curr_top ?
 				dma_updated_btm : dma_updated_top,
-				gdp->regs + GAM_GDP_NVN_OFFSET);
+				gdp->regs + GAM_OFFSET(NVN, gdp->type));
 		goto end;
 	}
 
@@ -851,15 +884,15 @@ static void sti_gdp_atomic_update(struct drm_plane *drm_plane,
 			/* Do not update in the middle of the frame, but
 			 * postpone the update after the bottom field has
 			 * been displayed */
-			curr_list->btm_field->gam_gdp_nvn = dma_updated_top;
+			curr_list->btm_field[GAM_OFFSET_U32(NVN, gdp->type)] = dma_updated_top;
 		} else {
 			/* Direct update to avoid one frame delay */
 			writel(dma_updated_top,
-			       gdp->regs + GAM_GDP_NVN_OFFSET);
+			       gdp->regs + GAM_OFFSET(NVN, gdp->type));
 		}
 	} else {
 		/* Direct update for progressive to avoid one frame delay */
-		writel(dma_updated_top, gdp->regs + GAM_GDP_NVN_OFFSET);
+		writel(dma_updated_top, gdp->regs + GAM_OFFSET(NVN, gdp->type));
 	}
 
 end:
@@ -914,7 +947,7 @@ static const struct drm_plane_funcs sti_gdp_plane_helpers_funcs = {
 };
 
 struct drm_plane *sti_gdp_create(struct drm_device *drm_dev,
-				 struct device *dev, int desc,
+				 struct device *dev, enum sti_gdp_type gdp_type, int desc,
 				 void __iomem *baseaddr,
 				 unsigned int possible_crtcs,
 				 enum drm_plane_type type)
@@ -932,6 +965,7 @@ struct drm_plane *sti_gdp_create(struct drm_device *drm_dev,
 	gdp->regs = baseaddr;
 	gdp->plane.desc = desc;
 	gdp->plane.status = STI_PLANE_DISABLED;
+	gdp->type = gdp_type;
 
 	gdp->vtg_field_nb.notifier_call = sti_gdp_field_cb;
 
diff --git a/drivers/gpu/drm/sti/sti_gdp.h b/drivers/gpu/drm/sti/sti_gdp.h
index deb07e34173d..b1f06a0c5c37 100644
--- a/drivers/gpu/drm/sti/sti_gdp.h
+++ b/drivers/gpu/drm/sti/sti_gdp.h
@@ -16,8 +16,14 @@
 struct drm_device;
 struct device;
 
+enum sti_gdp_type {
+	STI_GDP_TYPE_GDP,
+	STI_GDP_TYPE_GDPPLUS,
+};
+
 struct drm_plane *sti_gdp_create(struct drm_device *drm_dev,
-				 struct device *dev, int desc,
+				 struct device *dev, enum sti_gdp_type gdp_type,
+				 int desc,
 				 void __iomem *baseaddr,
 				 unsigned int possible_crtcs,
 				 enum drm_plane_type type);
-- 
2.40.1

From d0464cefc03175edb348a73923a6608c567bd14e Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 20 Apr 2023 22:19:37 +0200
Subject: [PATCH 08/16] clk: st: HACK: set several clocks as criticals

Set some clocks criticals while developing the drivers

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/clk/st/clk-flexgen.c | 30 +++++++++++++++---------------
 1 file changed, 15 insertions(+), 15 deletions(-)

diff --git a/drivers/clk/st/clk-flexgen.c b/drivers/clk/st/clk-flexgen.c
index 7ae4f656191e..a6858a87781f 100644
--- a/drivers/clk/st/clk-flexgen.c
+++ b/drivers/clk/st/clk-flexgen.c
@@ -458,9 +458,9 @@ static const struct clkgen_clk_out clkgen_stih418_c0_clk_out[] = {
 	{ .name = "clk-eth-phyref", },
 	{ .name = "clk-eth-ref-phyclk", },
 	{ .name = "clk-flash-promip", },
-	{ .name = "clk-main-disp", },
-	{ .name = "clk-aux-disp", },
-	{ .name = "clk-compo-dvp", },
+	{ .name = "clk-main-disp", .flags = CLK_IS_CRITICAL,},
+	{ .name = "clk-aux-disp", .flags = CLK_IS_CRITICAL,},
+	{ .name = "clk-compo-dvp", .flags = CLK_IS_CRITICAL,},
 	/* This clk needs to be on to keep bus interconnect alive */
 	{ .name = "clk-tx-icn-hades", .flags = CLK_IS_CRITICAL },
 	/* This clk needs to be on to keep bus interconnect alive */
@@ -536,22 +536,22 @@ static const struct clkgen_data clkgen_stih407_d2 = {
 };
 
 static const struct clkgen_clk_out clkgen_stih418_d2_clk_out[] = {
-	{ .name = "clk-pix-main-disp", },
+	{ .name = "clk-pix-main-disp", .flags = CLK_IS_CRITICAL,},
 	{ .name = "", },
 	{ .name = "", },
 	{ .name = "", },
 	{ .name = "", },
-	{ .name = "clk-tmds-hdmi-div2", },
-	{ .name = "clk-pix-aux-disp", },
-	{ .name = "clk-denc", },
-	{ .name = "clk-pix-hddac", },
-	{ .name = "clk-hddac", },
-	{ .name = "clk-sddac", },
-	{ .name = "clk-pix-dvo", },
-	{ .name = "clk-dvo", },
-	{ .name = "clk-pix-hdmi", },
-	{ .name = "clk-tmds-hdmi", },
-	{ .name = "clk-ref-hdmiphy", },
+	{ .name = "clk-tmds-hdmi-div2", .flags = CLK_IS_CRITICAL,},
+	{ .name = "clk-pix-aux-disp", .flags = CLK_IS_CRITICAL,},
+	{ .name = "clk-denc", .flags = CLK_IS_CRITICAL,},
+	{ .name = "clk-pix-hddac", .flags = CLK_IS_CRITICAL,},
+	{ .name = "clk-hddac", .flags = CLK_IS_CRITICAL,},
+	{ .name = "clk-sddac", .flags = CLK_IS_CRITICAL,},
+	{ .name = "clk-pix-dvo", .flags = CLK_IS_CRITICAL,},
+	{ .name = "clk-dvo", .flags = CLK_IS_CRITICAL,},
+	{ .name = "clk-pix-hdmi", .flags = CLK_IS_CRITICAL,},
+	{ .name = "clk-tmds-hdmi", .flags = CLK_IS_CRITICAL,},
+	{ .name = "clk-ref-hdmiphy", .flags = CLK_IS_CRITICAL,},
 	{ .name = "", }, { .name = "", }, { .name = "", }, { .name = "", },
 	{ .name = "", }, { .name = "", }, { .name = "", }, { .name = "", },
 	{ .name = "", }, { .name = "", }, { .name = "", }, { .name = "", },
-- 
2.40.1

From f902a052e56bc8830d5188e043830dfab5b88652 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 20 Apr 2023 17:21:22 +0200
Subject: [PATCH 09/16] ARM: dts: sti: move vtg_main / vtg_aux into
 stih407/stih410 dtsi

In preparation of introduction of display support in stih418, move
the vtg nodes into stih407.dtsi and stih410.dtsi since vtg nodes
will differ in case of the stih418 and thus cannot be kept as part
of the stih407-family.dtsi.

Compatible is also changed to st,stih407-vtg.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/boot/dts/stih407-family.dtsi | 13 -------------
 arch/arm/boot/dts/stih407.dtsi        | 12 ++++++++++++
 arch/arm/boot/dts/stih410.dtsi        | 12 ++++++++++++
 3 files changed, 24 insertions(+), 13 deletions(-)

diff --git a/arch/arm/boot/dts/stih407-family.dtsi b/arch/arm/boot/dts/stih407-family.dtsi
index 247197a2f003..7762a87ce1c6 100644
--- a/arch/arm/boot/dts/stih407-family.dtsi
+++ b/arch/arm/boot/dts/stih407-family.dtsi
@@ -294,19 +294,6 @@ syscfg_lpm: lpm-syscfg@94b5100 {
 			reg = <0x94b5100 0x1000>;
 		};
 
-		/* Display */
-		vtg_main: sti-vtg-main@8d02800 {
-			compatible = "st,vtg";
-			reg = <0x8d02800 0x200>;
-			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
-		};
-
-		vtg_aux: sti-vtg-aux@8d00200 {
-			compatible = "st,vtg";
-			reg = <0x8d00200 0x100>;
-			interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
-		};
-
 		serial@9830000 {
 			compatible = "st,asc";
 			reg = <0x9830000 0x2c>;
diff --git a/arch/arm/boot/dts/stih407.dtsi b/arch/arm/boot/dts/stih407.dtsi
index aca43d2bdaad..9ad85a90276c 100644
--- a/arch/arm/boot/dts/stih407.dtsi
+++ b/arch/arm/boot/dts/stih407.dtsi
@@ -8,6 +8,18 @@
 #include <dt-bindings/gpio/gpio.h>
 / {
 	soc {
+		vtg_main: sti-vtg-main@8d02800 {
+			compatible = "st,stih407-vtg";
+			reg = <0x8d02800 0x200>;
+			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		vtg_aux: sti-vtg-aux@8d00200 {
+			compatible = "st,stih407-vtg";
+			reg = <0x8d00200 0x100>;
+			interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
 		sti-display-subsystem@0 {
 			compatible = "st,sti-display-subsystem";
 			#address-cells = <1>;
diff --git a/arch/arm/boot/dts/stih410.dtsi b/arch/arm/boot/dts/stih410.dtsi
index 29e95e9d3229..583eba34e648 100644
--- a/arch/arm/boot/dts/stih410.dtsi
+++ b/arch/arm/boot/dts/stih410.dtsi
@@ -99,6 +99,18 @@ ehci1: usb@9a83e00 {
 			status = "disabled";
 		};
 
+		vtg_main: sti-vtg-main@8d02800 {
+			compatible = "st,stih407-vtg";
+			reg = <0x8d02800 0x200>;
+			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		vtg_aux: sti-vtg-aux@8d00200 {
+			compatible = "st,stih407-vtg";
+			reg = <0x8d00200 0x100>;
+			interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
 		sti-display-subsystem@0 {
 			compatible = "st,sti-display-subsystem";
 			#address-cells = <1>;
-- 
2.40.1

From 83c250861199e0a0cc89bf0e1f3661ee9a7cfbbb Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 20 Apr 2023 18:07:29 +0200
Subject: [PATCH 10/16] ARM: dts: sti: addition of display nodes for stih418
 platform

Addition of a first set of nodes (compositor/tvout/hdmi) in order
to allow graphic plane usage via HDMI on the stih418 based boards.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/boot/dts/stih418-clock.dtsi |   2 +-
 arch/arm/boot/dts/stih418.dtsi       | 142 +++++++++++++++++++++++++++
 2 files changed, 143 insertions(+), 1 deletion(-)

diff --git a/arch/arm/boot/dts/stih418-clock.dtsi b/arch/arm/boot/dts/stih418-clock.dtsi
index e1749e92a2e7..93641df58bf2 100644
--- a/arch/arm/boot/dts/stih418-clock.dtsi
+++ b/arch/arm/boot/dts/stih418-clock.dtsi
@@ -17,7 +17,7 @@ clk_sysin: clk-sysin {
 	clk_tmdsout_hdmi: clk-tmdsout-hdmi {
 		#clock-cells = <0>;
 		compatible = "fixed-clock";
-		clock-frequency = <0>;
+		clock-frequency = <594000000>;
 	};
 
 	clocks {
diff --git a/arch/arm/boot/dts/stih418.dtsi b/arch/arm/boot/dts/stih418.dtsi
index 8fb8b3af5e49..5d5ab1b83523 100644
--- a/arch/arm/boot/dts/stih418.dtsi
+++ b/arch/arm/boot/dts/stih418.dtsi
@@ -6,6 +6,7 @@
 #include "stih418-clock.dtsi"
 #include "stih407-family.dtsi"
 #include "stih410-pinctrl.dtsi"
+#include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/thermal/thermal.h>
 / {
 	cpus {
@@ -150,5 +151,146 @@ thermal: thermal@91a0000 {
 			interrupts = <GIC_SPI 205 IRQ_TYPE_EDGE_RISING>;
 			#thermal-sensor-cells = <0>;
 		};
+
+		sti-display-subsystem@0 {
+			compatible = "st,sti-display-subsystem";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			reg = <0 0>;
+			assigned-clocks = <&clk_s_d2_quadfs 0>,
+					  <&clk_s_d2_quadfs 1>,
+					  <&clk_s_d2_flexgen CLK_TMDS_HDMI_DIV2>,
+					  <&clk_s_d2_flexgen CLK_TMDS_HDMI>,
+					  <&clk_s_d2_flexgen CLK_PIX_MAIN_DISP>,
+					  <&clk_s_d2_flexgen CLK_PIX_AUX_DISP>,
+					  <&clk_s_c0_flexgen CLK_MAIN_DISP>,
+					  <&clk_s_c0_flexgen CLK_AUX_DISP>,
+					  <&clk_s_c0_flexgen CLK_COMPO_DVP>,
+					  <&clk_s_c0_flexgen CLK_PROC_MIXER>;
+
+			assigned-clock-parents = <0>,
+						 <0>,
+						 <&clk_tmdsout_hdmi>,
+						 <&clk_tmdsout_hdmi>,
+						 <&clk_s_d2_quadfs 0>,
+						 <&clk_s_d2_quadfs 1>,
+						 <&clk_s_c0_pll1 0>,
+						 <&clk_s_c0_pll1 0>,
+						 <&clk_s_c0_pll0 0>,
+						 <&clk_s_c0_pll0 0>;
+
+			assigned-clock-rates = <297000000>,
+					       <108000000>,
+					       <297000000>,
+					       <0>,
+					       <74250000>,
+					       <13500000>,
+					       <400000000>,
+					       <400000000>,
+					       <355000000>,
+					       <355000000>;
+
+			ranges;
+
+			sti_compo: sti-compositor@a600000 {
+				compatible = "st,stih418-compositor";
+				reg = <0xa600000 0x200000>;
+
+				clock-names = "compo_main",
+					      "compo_aux",
+					      "pix_main",
+					      "pix_aux",
+					      "proc_mixer";
+
+				clocks = <&clk_s_c0_flexgen CLK_MAIN_DISP>,
+					 <&clk_s_c0_flexgen CLK_AUX_DISP>,
+					 <&clk_s_d2_flexgen CLK_PIX_MAIN_DISP>,
+					 <&clk_s_d2_flexgen CLK_PIX_AUX_DISP>,
+					 <&clk_s_c0_flexgen CLK_PROC_MIXER>;
+
+				reset-names = "compo-main", "compo-aux";
+				resets = <&softreset STIH407_COMPO_SOFTRESET>,
+					 <&softreset STIH407_COMPO_SOFTRESET>;
+				st,vtg = <&vtg_main>, <&vtg_aux>;
+
+				status = "disabled";
+			};
+
+			sti_tvout: sti-tvout@a900000 {
+				compatible = "st,stih418-tvout";
+				reg = <0xa900000 0x1000>;
+				reg-names = "tvout-reg";
+				reset-names = "tvout";
+				resets = <&softreset STIH407_HDTVOUT_SOFTRESET>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				assigned-clocks = <&clk_s_d2_flexgen CLK_PIX_HDMI>,
+						  <&clk_s_d2_flexgen CLK_TMDS_HDMI>,
+						  <&clk_s_d2_flexgen CLK_REF_HDMIPHY>,
+						  <&clk_s_d0_flexgen CLK_PCM_0>,
+						  <&clk_s_d2_flexgen CLK_PIX_HDDAC>,
+						  <&clk_s_d2_flexgen CLK_HDDAC>;
+
+				assigned-clock-parents = <&clk_s_d2_quadfs 0>,
+							 <&clk_tmdsout_hdmi>,
+							 <&clk_s_d2_quadfs 0>,
+							 <&clk_s_d0_quadfs 0>,
+							 <&clk_s_d2_quadfs 0>,
+							 <&clk_s_d2_quadfs 0>;
+				assigned-clock-rates = <74250000>,
+						       <0>,
+						       <74250000>,
+						       <0>,
+						       <74250000>,
+						       <148500000>;
+
+				status = "disabled";
+			};
+
+			sti_hdmi: sti-hdmi@a804000 {
+				compatible = "st,stih418-hdmi";
+				reg = <0xa804000 0x1000>;
+				reg-names = "hdmi-reg";
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "irq";
+				clock-names = "pix",
+					      "tmds",
+					      "phy",
+					      "audio",
+					      "main_parent",
+					      "aux_parent";
+
+				clocks = <&clk_s_d2_flexgen CLK_PIX_HDMI>,
+					 <&clk_s_d2_flexgen CLK_TMDS_HDMI>,
+					 <&clk_s_d2_flexgen CLK_REF_HDMIPHY>,
+					 <&clk_s_d0_flexgen CLK_PCM_0>,
+					 <&clk_s_d2_quadfs 0>,
+					 <&clk_s_d2_quadfs 1>;
+
+				hdmi,hpd-gpio = <&pio5 3 GPIO_ACTIVE_LOW>;
+				reset-names = "hdmi";
+				resets = <&softreset STIH407_HDMI_TX_PHY_SOFTRESET>;
+
+				status = "disabled";
+			};
+		};
+
+		vtg_main: sti-vtg-main@a802800 {
+			compatible = "st,stih418-vtg";
+			reg = <0xa802800 0x200>;
+			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+
+			status = "disabled";
+		};
+
+		vtg_aux: sti-vtg-aux@a800200 {
+			compatible = "st,stih418-vtg";
+			reg = <0xa800200 0x100>;
+			interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+
+			status = "disabled";
+		};
 	};
 };
-- 
2.40.1

From 07091c6c65a369ecc1a34dbbd1676b02156d1d99 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 20 Apr 2023 18:08:44 +0200
Subject: [PATCH 11/16] ARM: dts: sti: enable basic display on stih418-b2264
 board

Enable the compositor, tvout and hdmi on the B2264 board.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/boot/dts/stih418-b2264.dts | 30 +++++++++++++++++++++++++++++
 1 file changed, 30 insertions(+)

diff --git a/arch/arm/boot/dts/stih418-b2264.dts b/arch/arm/boot/dts/stih418-b2264.dts
index 0e65759afea6..eacef143cb0b 100644
--- a/arch/arm/boot/dts/stih418-b2264.dts
+++ b/arch/arm/boot/dts/stih418-b2264.dts
@@ -115,6 +115,14 @@ st,pins {
 			};
 		};
 
+		hdmiddc: i2c@9541000 {
+			/* HDMI V1.3a supports Standard mode only */
+			clock-frequency = <100000>;
+			st,i2c-min-scl-pulse-width-us = <0>;
+			st,i2c-min-sda-pulse-width-us = <5>;
+
+			status = "okay";
+		};
 	};
 };
 
@@ -211,3 +219,25 @@ &sti_uni_player2 {
 &sti_sasg_codec {
 	status = "okay";
 };
+
+&sti_compo {
+	status = "okay";
+};
+
+&sti_tvout {
+	status = "okay";
+};
+
+&sti_hdmi {
+	ddc = <&hdmiddc>;
+
+	status = "okay";
+};
+
+&vtg_main {
+	status = "okay";
+};
+
+&vtg_aux {
+	status = "okay";
+};
-- 
2.40.1

From 2890f6fbb70e83b63f974b3e8b749df12f2899ea Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Fri, 21 Apr 2023 22:43:41 +0200
Subject: [PATCH 12/16] ARM: dts: sti: add the gpu node for the MALI-400 on
 stih418.dtsi

Add the gpu node for the MALI-400 found on stih418 soc.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/boot/dts/stih418.dtsi | 36 ++++++++++++++++++++++++++++++++++
 1 file changed, 36 insertions(+)

diff --git a/arch/arm/boot/dts/stih418.dtsi b/arch/arm/boot/dts/stih418.dtsi
index 5d5ab1b83523..b77de8b0b3a6 100644
--- a/arch/arm/boot/dts/stih418.dtsi
+++ b/arch/arm/boot/dts/stih418.dtsi
@@ -292,5 +292,41 @@ vtg_aux: sti-vtg-aux@a800200 {
 
 			status = "disabled";
 		};
+
+		gpu: gpu@9f00000 {
+			compatible = "arm,mali-400";
+			reg = <0x9f00000 0x10000>;
+			/* LIMA driver needs 2 clocks, use the same for both */
+			clocks = <&clk_s_c0_flexgen CLK_ICN_GPU>,
+				 <&clk_s_c0_flexgen CLK_ICN_GPU>;
+			clock-names = "bus", "core";
+			assigned-clocks = <&clk_s_c0_flexgen CLK_ICN_GPU>;
+			assigned-clock-rates = <400000000>;
+			resets = <&softreset STIH407_GPU_SOFTRESET>;
+			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "gp",
+					  "gpmmu",
+					  "pp0",
+					  "ppmmu0",
+					  "pp1",
+					  "ppmmu1",
+					  "pp2",
+					  "ppmmu2",
+					  "pp3",
+					  "ppmmu3";
+
+			status = "disabled";
+		};
+
+
 	};
 };
-- 
2.40.1

From f05ae8df975c9aa4b2c1c2f9310a54d47e76f816 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Fri, 21 Apr 2023 22:44:41 +0200
Subject: [PATCH 13/16] ARM: dts: sti: enable the gpu node on the
 stih418-b2264.dts

Enable the mali-400 on the 4KOpen.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/boot/dts/stih418-b2264.dts | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/arch/arm/boot/dts/stih418-b2264.dts b/arch/arm/boot/dts/stih418-b2264.dts
index eacef143cb0b..93cdfe3ddb92 100644
--- a/arch/arm/boot/dts/stih418-b2264.dts
+++ b/arch/arm/boot/dts/stih418-b2264.dts
@@ -241,3 +241,7 @@ &vtg_main {
 &vtg_aux {
 	status = "okay";
 };
+
+&gpu {
+	status = "okay";
+};
-- 
2.40.1

From 96479d27a4f4038d548db9d1febdc574741dd68b Mon Sep 17 00:00:00 2001
From: Jerome Audu <jau@free.fr>
Date: Wed, 10 May 2023 23:24:34 +0200
Subject: [PATCH 14/16] ARM: dts: sti: enable HDMI audio output on
 stih418-b2264

---
 arch/arm/boot/dts/stih418-b2264.dts | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/arch/arm/boot/dts/stih418-b2264.dts b/arch/arm/boot/dts/stih418-b2264.dts
index 93cdfe3ddb92..ecf5c6ba3427 100644
--- a/arch/arm/boot/dts/stih418-b2264.dts
+++ b/arch/arm/boot/dts/stih418-b2264.dts
@@ -90,6 +90,21 @@ codec {
 				sound-dai = <&sti_sasg_codec 1>;
 			};
 		};
+
+		simple-audio-card,dai-link@1 {
+			reg = <1>;
+			/* HDMI */
+			format = "i2s";
+			mclk-fs = <128>;
+			cpu {
+				sound-dai = <&sti_uni_player0>;
+			};
+
+			codec {
+				sound-dai = <&sti_hdmi>;
+			};
+		};
+
 	};
 
 	soc {
@@ -216,6 +231,10 @@ &sti_uni_player2 {
 	status = "okay";
 };
 
+&sti_uni_player0 {
+	status = "okay";
+};
+
 &sti_sasg_codec {
 	status = "okay";
 };
-- 
2.40.1

From ceefe9635d53d3546cfeb6310bd83fb5ccd1609b Mon Sep 17 00:00:00 2001
From: Jerome Audu <jau@free.fr>
Date: Wed, 17 May 2023 23:18:50 +0200
Subject: [PATCH 15/16] ARM: dts: sti: add STi-CEC node on stih418.dtsi

Signed-off-by: Jerome Audu <jau@free.fr>
---
 arch/arm/boot/dts/stih418.dtsi | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/arch/arm/boot/dts/stih418.dtsi b/arch/arm/boot/dts/stih418.dtsi
index b77de8b0b3a6..956eb995e1c2 100644
--- a/arch/arm/boot/dts/stih418.dtsi
+++ b/arch/arm/boot/dts/stih418.dtsi
@@ -293,6 +293,19 @@ vtg_aux: sti-vtg-aux@a800200 {
 			status = "disabled";
 		};
 
+		cec: cec@94a087c {
+			compatible = "st,stih-cec";
+			reg = <0x94a087c 0x64>;
+			clocks = <&clk_sysin>;
+			clock-names = "cec-clk";
+			interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "cec-irq";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_cec0_default>;
+			resets = <&softreset STIH407_LPM_SOFTRESET>;
+			hdmi-phandle = <&sti_hdmi>;
+		};
+
 		gpu: gpu@9f00000 {
 			compatible = "arm,mali-400";
 			reg = <0x9f00000 0x10000>;
-- 
2.40.1

From 550a779f2418b3d1510df2d0392d66b8fbb31f99 Mon Sep 17 00:00:00 2001
From: Jerome Audu <jau@free.fr>
Date: Thu, 18 May 2023 00:13:23 +0200
Subject: [PATCH 16/16] ARM: dts: sti: enable STi-CEC on stih418-b2264

Signed-off-by: Jerome Audu <jau@free.fr>
---
 arch/arm/boot/dts/stih418-b2264.dts | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/arch/arm/boot/dts/stih418-b2264.dts b/arch/arm/boot/dts/stih418-b2264.dts
index ecf5c6ba3427..13179669b7f8 100644
--- a/arch/arm/boot/dts/stih418-b2264.dts
+++ b/arch/arm/boot/dts/stih418-b2264.dts
@@ -261,6 +261,10 @@ &vtg_aux {
 	status = "okay";
 };
 
+&cec {
+	status = "okay";
+};
+
 &gpu {
 	status = "okay";
 };
-- 
2.40.1

