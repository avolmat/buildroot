From c8e62b29b3cb9e929b280da103022f63b442ecc2 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Mon, 20 Apr 2020 21:35:14 +0200
Subject: [PATCH 01/72] dt-bindings: pci: st-pcie: PCIe controller found on STi
 platforms

Addition of the bindings for the Designware based PCIe controller
that can be found on STi platforms such as STiH407, STiH410 or STiH418.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 .../devicetree/bindings/pci/snps,dw-pcie.yaml |   3 +
 .../devicetree/bindings/pci/st,st-pcie.yaml   | 112 ++++++++++++++++++
 2 files changed, 115 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/pci/st,st-pcie.yaml

diff --git a/Documentation/devicetree/bindings/pci/snps,dw-pcie.yaml b/Documentation/devicetree/bindings/pci/snps,dw-pcie.yaml
index 205326fb2d75..ee0867f331f1 100644
--- a/Documentation/devicetree/bindings/pci/snps,dw-pcie.yaml
+++ b/Documentation/devicetree/bindings/pci/snps,dw-pcie.yaml
@@ -101,6 +101,9 @@ properties:
             Outbound iATU-capable memory-region which will be used to access
             the peripheral PCIe devices configuration space.
           const: config
+        - description:
+            mem regions: fixme!
+          const: mem-window
         - description:
             Vendor-specific CSR names. Consider using the generic names above
             for new bindings.
diff --git a/Documentation/devicetree/bindings/pci/st,st-pcie.yaml b/Documentation/devicetree/bindings/pci/st,st-pcie.yaml
new file mode 100644
index 000000000000..4d19657f3ec2
--- /dev/null
+++ b/Documentation/devicetree/bindings/pci/st,st-pcie.yaml
@@ -0,0 +1,112 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/pci/st,st-pcie.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: PCIe RC controller on ST STi platform
+
+maintainers:
+  - Alain Volmat <avolmat@me.com>
+
+allOf:
+  - $ref: /schemas/pci/snps,dw-pcie.yaml#
+
+properties:
+  compatible:
+    const: st,stih407-pcie
+
+  reg:
+    items:
+      - description: Controller control and status registers.
+      - description: PCIe configuration registers.
+      - description: Memory made available to the controller
+
+  reg-names:
+    items:
+      - const: dbi
+      - const: config
+      - const: mem-window
+
+  interrupts:
+    maxItems: 1
+
+  resets:
+    items:
+    - description: Controller reset
+    - description: Powerdown reset
+    minItems: 1
+
+  reset-names:
+    items:
+      - const: softreset
+      - const: powerdown
+    minItems: 1
+
+  phys:
+    maxItems: 1
+
+  phy-names:
+    const: pcie
+
+  reset-gpios: true
+
+  st,syscfg:
+    $ref: "/schemas/types.yaml#/definitions/phandle-array"
+    description: syscfg node phandle and offsets of the 2 registers
+                 controlling root complex and ltssm.
+
+required:
+  - interrupts
+  - '#interrupt-cells'
+  - interrupt-map
+  - interrupt-map-mask
+  - resets
+  - reset-names
+  - phys
+  - phy-names
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+    #include <dt-bindings/interrupt-controller/irq.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+    #include <dt-bindings/phy/phy.h>
+    #include <dt-bindings/reset/stih407-resets.h>
+    pcie1: pcie@9b10000 {
+      compatible = "st,stih407-pcie";
+      device_type = "pci";
+      #address-cells = <3>;
+      #size-cells = <2>;
+      reg = <0x09b10000 0x1000>,
+            <0x3fff0000 0x10000>,
+            <0x40000000 0xc0000000>;
+      reg-names = "dbi", "config", "mem-window";
+
+      #interrupt-cells = <1>;
+      interrupts = <GIC_SPI 175 IRQ_TYPE_LEVEL_HIGH>;
+      interrupt-names = "msi";
+      interrupt-map-mask = <0 0 0 7>;
+      interrupt-map = <0 0 0 1 &intc GIC_SPI 171 IRQ_TYPE_LEVEL_HIGH>,
+                      <0 0 0 2 &intc GIC_SPI 172 IRQ_TYPE_LEVEL_HIGH>,
+                      <0 0 0 3 &intc GIC_SPI 173 IRQ_TYPE_LEVEL_HIGH>,
+                      <0 0 0 4 &intc GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH>;
+
+      st,syscfg = <&syscfg_core 0xdc 0xe4>;
+
+      ranges = <0x82000000 0 0x30000000 0x30000000 0 0x05550000>, /* non-prefetchable memory */
+               <0xc2000000 0 0x35550000 0x35550000 0 0x0AAA0000>; /* prefetchable memory */
+      bus-range = <0x00 0xff>;
+
+      resets = <&softreset STIH407_PCIE1_SOFTRESET>,
+               <&powerdown STIH407_PCIE1_POWERDOWN>;
+
+      reset-names = "softreset", "powerdown";
+
+      phys = <&phy_port1 PHY_TYPE_PCIE>;
+      phy-names = "pcie";
+
+      reset-gpios = <&pio34 5 GPIO_ACTIVE_LOW>;
+    };
-- 
2.48.1

From 808865ff23eb8ae3a7c11b3735bc113030696511 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Sun, 22 Mar 2020 13:05:15 +0100
Subject: [PATCH 02/72] pci: dwc: pcie-st: Add PCIe driver for STi platforms

Addition of the PCIe driver (supporting RC) for controllers
found on some STi platforms such as STiH407, STiH410 or
STiH418.
The controller is based on the designware PCIe controller.

Signed-off-by: Alain Volmat <avolmat@me.com>

v2: update Kconfig depends
    reorder in makefile
    rework of reset_gpio using gpiod
    don't cut at 80 characters but instead 100 characters
    integrated st_pcie_board_reset content into start_link
---
 drivers/pci/controller/dwc/Kconfig    |  11 +
 drivers/pci/controller/dwc/Makefile   |   1 +
 drivers/pci/controller/dwc/pcie-sti.c | 379 ++++++++++++++++++++++++++
 3 files changed, 391 insertions(+)
 create mode 100644 drivers/pci/controller/dwc/pcie-sti.c

diff --git a/drivers/pci/controller/dwc/Kconfig b/drivers/pci/controller/dwc/Kconfig
index b6d6778b0698..55be73ee511a 100644
--- a/drivers/pci/controller/dwc/Kconfig
+++ b/drivers/pci/controller/dwc/Kconfig
@@ -459,4 +459,15 @@ config PCIE_VISCONTI_HOST
 	  Say Y here if you want PCIe controller support on Toshiba Visconti SoC.
 	  This driver supports TMPV7708 SoC.
 
+config PCIE_STI
+	bool "STMicroelectronics PCIe Controller for STi SoCs"
+	depends on ARCH_STI || COMPILE_TEST
+	depends on OF && PCI_MSI_IRQ_DOMAIN
+	select PCIE_DW_HOST
+	help
+	  Enable PCIe controller support on STMicroelectronics STi SoCs.
+	  This controller is based on Designware hardware and therefore
+	  the driver re-uses the Designware core functions to implement
+	  the driver.
+
 endmenu
diff --git a/drivers/pci/controller/dwc/Makefile b/drivers/pci/controller/dwc/Makefile
index a8308d9ea986..5dd028001a96 100644
--- a/drivers/pci/controller/dwc/Makefile
+++ b/drivers/pci/controller/dwc/Makefile
@@ -23,6 +23,7 @@ obj-$(CONFIG_PCIE_KEEMBAY) += pcie-keembay.o
 obj-$(CONFIG_PCIE_KIRIN) += pcie-kirin.o
 obj-$(CONFIG_PCIE_HISI_STB) += pcie-histb.o
 obj-$(CONFIG_PCI_MESON) += pci-meson.o
+obj-$(CONFIG_PCIE_STI) += pcie-sti.o
 obj-$(CONFIG_PCIE_TEGRA194) += pcie-tegra194.o
 obj-$(CONFIG_PCIE_UNIPHIER) += pcie-uniphier.o
 obj-$(CONFIG_PCIE_UNIPHIER_EP) += pcie-uniphier-ep.o
diff --git a/drivers/pci/controller/dwc/pcie-sti.c b/drivers/pci/controller/dwc/pcie-sti.c
new file mode 100644
index 000000000000..2d8cc1bbbb44
--- /dev/null
+++ b/drivers/pci/controller/dwc/pcie-sti.c
@@ -0,0 +1,379 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2021 STMicroelectronics
+ *
+ * STMicroelectronics PCI express Driver for STi SoCs.
+ * ST PCIe IPs are built around a Synopsys IP Core.
+ *
+ * Authors: Fabrice Gasnier <fabrice.gasnier@foss.st.com>
+ *          Alain Volmat <avolmat@me.com>
+ */
+
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <linux/of_pci.h>
+#include <linux/of_platform.h>
+#include <linux/phy/phy.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+
+#include "pcie-designware.h"
+
+/* RC_ADDRESS_TRANSLATION Registers */
+#define TRANSLATION_CONTROL		0x900
+/* Controls if area is inclusive or exclusive */
+#define RC_PASS_ADDR_RANGE		BIT(1)
+
+/* Base of area reserved for config accesses. Fixed size of 64K. */
+#define CFG_BASE_ADDRESS		0x92c
+#define CFG_REGION_SIZE			65536
+#define CFG_SPACE1_OFFSET		0x1000
+
+/* First 4K of config space has this BDF (bus,device,function) */
+#define FUNC0_BDF_NUM			0x930
+
+/* Mem regions */
+#define IN0_MEM_ADDR_START		0x964
+#define IN0_MEM_ADDR_LIMIT		0x968
+#define IN1_MEM_ADDR_START		0x974
+#define IN1_MEM_ADDR_LIMIT		0x978
+
+/* syscfg1 bits */
+#define PCIE_APP_LTSSM_ENABLE		BIT(2)
+/* syscfg0 bits */
+#define PCIE_TYPE_ROOT_COMPLEX		BIT(0)
+
+/* st,syscfg offsets */
+#define SYSCFG0_REG	1
+#define SYSCFG1_REG	2
+
+#define to_st_pcie(x)	dev_get_drvdata((x)->dev)
+
+/**
+ * struct st_pcie - private data of the controller
+ * @dw: designware pcie
+ * @syscfg0: PCIe conf register setting root complex, regmap offset
+ * @syscfg1: PCIe conf register for PCIE_APP_LTSSM_ENABLE, regmap offset
+ * @phy: associated pcie phy
+ * @lmi: memory made available to the controller
+ * @regmap: Syscfg registers bank in which PCIe port is configured
+ * @pwr: power control
+ * @rst: reset control
+ * @reset_gpio: optional reset gpio
+ * @config_window_start: start address of 64K config space area
+ */
+struct st_pcie {
+	struct dw_pcie *dw;
+	int syscfg0;
+	int syscfg1;
+	struct phy *phy;
+	struct resource	*lmi;
+	struct regmap *regmap;
+	struct reset_control *pwr;
+	struct reset_control *rst;
+	struct gpio_desc *reset_gpio;
+	phys_addr_t config_window_start;
+};
+
+/*
+ * The PCI express core IP expects the following arrangement on it's address
+ * bus (slv_haddr) when driving config cycles.
+ * bus_number		[31:24]
+ * dev_number		[23:19]
+ * func_number		[18:16]
+ * unused		[15:12]
+ * ext_reg_number	[11:8]
+ * reg_number		[7:2]
+ *
+ * Bits [15:12] are unused.
+ *
+ * In the glue logic there is a 64K region of address space that can be
+ * written/read to generate config cycles. The base address of this is
+ * controlled by CFG_BASE_ADDRESS. There are 8 16 bit registers called
+ * FUNC0_BDF_NUM to FUNC8_BDF_NUM. These split the bottom half of the 64K
+ * window into 8 regions at 4K boundaries. These control the bus, device and
+ * function number you are trying to talk to.
+ *
+ * The decision on whether to generate a type 0 or type 1 access is controlled
+ * by bits 15:12 of the address you write to.  If they are zero, then a type 0
+ * is generated, if anything else it will be a type 1. Thus the bottom 4K
+ * region controlled by FUNC0_BDF_NUM can only generate type 0, all the others
+ * can only generate type 1.
+ *
+ * We only use FUNC0_BDF_NUM and FUNC1_BDF_NUM. Which one you use is selected
+ * by bit 12 of the address you write to. The selected register is then used
+ * for the top 16 bits of the slv_haddr to form the bus/dev/func, bit 15:12 are
+ * wired to zero, and bits 11:2 form the address of the register you want to
+ * read in config space.
+ *
+ * We always write FUNC0_BDF_NUM as a 32 bit write. So if we want type 1
+ * accesses we have to shift by 16 so in effect we are writing to FUNC1_BDF_NUM
+ */
+static inline u32 bdf_num(int bus, int devfn, int is_root_bus)
+{
+	return ((bus << 8) | devfn) << (is_root_bus ? 0 : 16);
+}
+
+static void __iomem *st_pcie_other_map_bus(struct pci_bus *bus, unsigned int devfn, int where)
+{
+	struct pcie_port *pp = bus->sysdata;
+	struct dw_pcie *dw = to_dw_pcie_from_pp(pp);
+	u32 bdf;
+
+	bdf = bdf_num(bus->number, devfn, pci_is_root_bus(bus));
+
+	/* Set the config packet devfn */
+	dw_pcie_writel_dbi(dw, FUNC0_BDF_NUM, bdf);
+	dw_pcie_readl_dbi(dw, FUNC0_BDF_NUM);
+
+	return pp->va_cfg0_base + where + (pci_is_root_bus(bus->parent) ? 0 : CFG_SPACE1_OFFSET);
+}
+
+static struct pci_ops st_child_pcie_ops = {
+	.map_bus = st_pcie_other_map_bus,
+	.read = pci_generic_config_read,
+	.write = pci_generic_config_write,
+};
+
+static void st_pcie_hw_setup(struct dw_pcie *dw)
+{
+	struct st_pcie *pcie = to_st_pcie(dw);
+
+	/* Set up the config window to the top of the PCI address space */
+	dw_pcie_writel_dbi(dw, CFG_BASE_ADDRESS, pcie->config_window_start);
+
+	/*
+	 * Open up memory to the PCI controller. We could do slightly
+	 * better than this and exclude the kernel text segment and bss etc.
+	 * They are base/limit registers so can be of arbitrary alignment
+	 * presumably
+	 */
+	dw_pcie_writel_dbi(dw, IN0_MEM_ADDR_START, pcie->lmi->start);
+	dw_pcie_writel_dbi(dw, IN0_MEM_ADDR_LIMIT, pcie->lmi->end);
+
+	/* Disable the 2nd region */
+	dw_pcie_writel_dbi(dw, IN1_MEM_ADDR_START, ~0);
+	dw_pcie_writel_dbi(dw, IN1_MEM_ADDR_LIMIT, 0);
+
+	dw_pcie_writel_dbi(dw, TRANSLATION_CONTROL, RC_PASS_ADDR_RANGE);
+}
+
+static int st_pcie_init(struct pcie_port *pp)
+{
+	struct dw_pcie *dw = to_dw_pcie_from_pp(pp);
+	struct st_pcie *pcie = to_st_pcie(dw);
+	int ret;
+
+	/* Set device type : Root Complex */
+	ret = regmap_write(pcie->regmap, pcie->syscfg0, PCIE_TYPE_ROOT_COMPLEX);
+	if (ret < 0) {
+		dev_err(dw->dev, "unable to set device type\n");
+		return ret;
+	}
+
+	ret = reset_control_deassert(pcie->pwr);
+	if (ret) {
+		dev_err(dw->dev, "unable to bring out of powerdown\n");
+		return ret;
+	}
+
+	ret = reset_control_deassert(pcie->rst);
+	if (ret) {
+		dev_err(dw->dev, "unable to bring out of softreset\n");
+		return ret;
+	}
+
+	usleep_range(1000, 2000);
+
+	return ret;
+}
+
+static int st_pcie_control_ltssm(struct dw_pcie *dw, bool enable)
+{
+	struct st_pcie *pcie = to_st_pcie(dw);
+
+	return regmap_update_bits(pcie->regmap, pcie->syscfg1, PCIE_APP_LTSSM_ENABLE,
+				  FIELD_PREP(PCIE_APP_LTSSM_ENABLE, enable));
+}
+
+static int st_pcie_host_init(struct pcie_port *pp)
+{
+	struct dw_pcie *dw = to_dw_pcie_from_pp(pp);
+	struct st_pcie *pcie = to_st_pcie(dw);
+	int err;
+
+	pcie->config_window_start = pp->cfg0_base;
+
+	/*
+	 * "Override" default ops provided by designware driver as STI
+	 * PCIe uses its own translation unit rather than iATU
+	 */
+	pp->bridge->child_ops = &st_child_pcie_ops;
+
+	/*
+	 * We have to initialise the PCIe cell on some hardware before we can
+	 * talk to the phy
+	 */
+	err = st_pcie_init(pp);
+	if (err)
+		return err;
+
+	err = st_pcie_control_ltssm(dw, false);
+	if (err) {
+		dev_err(dw->dev, "disable ltssm failed, %d\n", err);
+		return err;
+	}
+
+	/* Init the associated miphy */
+	err = phy_init(pcie->phy);
+	if (err < 0) {
+		dev_err(dw->dev, "Cannot init PHY: %d\n", err);
+		return err;
+	}
+
+	return 0;
+}
+
+static int st_pcie_start_link(struct dw_pcie *dw)
+{
+	struct st_pcie *pcie = to_st_pcie(dw);
+	int err;
+
+	/* Do all the register poking */
+	st_pcie_hw_setup(dw);
+
+	if (pcie->reset_gpio) {
+		/* Engage PERST# signal */
+		gpiod_set_value(pcie->reset_gpio, 1);
+
+		/* PERST# signal must stay asserted for at least 100us (Tperst-clk) */
+		usleep_range(100, 200);
+
+		/* Release PERST# signal */
+		gpiod_set_value(pcie->reset_gpio, 0);
+	}
+
+	/* Re-enable the link, link training must begin shortly after reset */
+	err = st_pcie_control_ltssm(dw, true);
+	if (err) {
+		dev_err(dw->dev, "enable ltssm failed, %d\n", err);
+		return err;
+	}
+
+	err = dw_pcie_wait_for_link(dw);
+	if (err) {
+		dev_err(dw->dev, "wait for link failed, %d\n", err);
+		return err;
+	}
+
+	/*
+	 * PCIe specification states that you should not issue any config
+	 * requests until 100ms after asserting reset, so we enforce that here
+	 */
+	if  (pcie->reset_gpio)
+		msleep(100);
+
+	return 0;
+}
+
+static struct dw_pcie_host_ops st_pcie_host_ops = {
+	.host_init = st_pcie_host_init,
+};
+
+static const struct dw_pcie_ops dw_pcie_ops = {
+	.start_link = st_pcie_start_link,
+};
+
+static int __init st_pcie_probe(struct platform_device *pdev)
+{
+	struct st_pcie *pcie;
+	struct dw_pcie *dw;
+	struct device_node *np = pdev->dev.of_node;
+	struct pcie_port *pp;
+	int ret;
+
+	pcie = devm_kzalloc(&pdev->dev, sizeof(*pcie), GFP_KERNEL);
+	if (!pcie)
+		return -ENOMEM;
+
+	dw = devm_kzalloc(&pdev->dev, sizeof(*dw), GFP_KERNEL);
+	if (!dw)
+		return -ENOMEM;
+	pcie->dw = dw;
+	dw->dev = &pdev->dev;
+	dw->ops = &dw_pcie_ops;
+
+	pp = &dw->pp;
+	pp->ops = &st_pcie_host_ops;
+
+	/* mem regions */
+	pcie->lmi = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mem-window");
+	if (!pcie->lmi)
+		return -ENXIO;
+
+	/* regmap registers for PCIe IP configuration */
+	pcie->regmap = syscon_regmap_lookup_by_phandle(np, "st,syscfg");
+	if (IS_ERR(pcie->regmap))
+		return dev_err_probe(&pdev->dev, PTR_ERR(pcie->regmap),
+				     "No syscfg phandle specified\n");
+
+	ret = of_property_read_u32_index(np, "st,syscfg", SYSCFG0_REG, &pcie->syscfg0);
+	if (ret) {
+		dev_err(&pdev->dev, "can't get syscfg0 offset (%d)\n", ret);
+		return ret;
+	}
+
+	ret = of_property_read_u32_index(np, "st,syscfg", SYSCFG1_REG, &pcie->syscfg1);
+	if (ret) {
+		dev_err(&pdev->dev, "can't get syscfg1 offset (%d)\n", ret);
+		return ret;
+	}
+
+	/* powerdown / resets */
+	pcie->pwr = devm_reset_control_get_optional(&pdev->dev, "powerdown");
+	if (IS_ERR(pcie->pwr))
+		return dev_err_probe(&pdev->dev, PTR_ERR(pcie->pwr),
+				     "Error getting powerdown reset control\n");
+
+	pcie->rst = devm_reset_control_get(&pdev->dev, "softreset");
+	if (IS_ERR(pcie->rst))
+		return dev_err_probe(&pdev->dev, PTR_ERR(pcie->rst),
+				     "Error getting softreset control\n");
+
+	/* phy */
+	pcie->phy = devm_phy_get(&pdev->dev, "pcie");
+	if (IS_ERR(pcie->phy))
+		return dev_err_probe(&pdev->dev, PTR_ERR(pcie->phy), "no PHY configured\n");
+
+	/* Claim the GPIO for PRST# if available */
+	pcie->reset_gpio = devm_gpiod_get_optional(&pdev->dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(pcie->reset_gpio))
+		return dev_err_probe(&pdev->dev, PTR_ERR(pcie->reset_gpio),
+				     "Cannot request reset-gpios\n");
+
+	platform_set_drvdata(pdev, pcie);
+
+	ret = dw_pcie_host_init(pp);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "failed to initialize host\n");
+
+	return 0;
+}
+
+static const struct of_device_id st_pcie_of_match[] = {
+	{ .compatible = "st,stih407-pcie", },
+	{ },
+};
+
+static struct platform_driver st_pcie_driver __refdata = {
+	.probe  = st_pcie_probe,
+	.driver = {
+		.name = "st-pcie",
+		.of_match_table = st_pcie_of_match,
+	},
+};
+builtin_platform_driver(st_pcie_driver);
-- 
2.48.1

From e3d62c245ab8f4102867c06640a1c61262a25f79 Mon Sep 17 00:00:00 2001
From: Jerome Audu <jerome.audu@st.com>
Date: Mon, 5 Sep 2022 13:40:55 +0200
Subject: [PATCH 03/72] pci: dwc: sti : Rename struct pcie_port to dw_pcie_rp

All of the DW PCIe core driver entities except the pcie_port struct have
names with the "dw_" prefix to distinguish local and common PCIe name
spaces, and endpoint-related entities have an "_ep" suffix.

based on 60b3c27fb9b92b8b55cd8bdcc444c3f7cb556652
---
 drivers/pci/controller/dwc/pcie-sti.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/pci/controller/dwc/pcie-sti.c b/drivers/pci/controller/dwc/pcie-sti.c
index 2d8cc1bbbb44..a069ef110801 100644
--- a/drivers/pci/controller/dwc/pcie-sti.c
+++ b/drivers/pci/controller/dwc/pcie-sti.c
@@ -120,7 +120,7 @@ static inline u32 bdf_num(int bus, int devfn, int is_root_bus)
 
 static void __iomem *st_pcie_other_map_bus(struct pci_bus *bus, unsigned int devfn, int where)
 {
-	struct pcie_port *pp = bus->sysdata;
+	struct dw_pcie_rp *pp = bus->sysdata;
 	struct dw_pcie *dw = to_dw_pcie_from_pp(pp);
 	u32 bdf;
 
@@ -162,7 +162,7 @@ static void st_pcie_hw_setup(struct dw_pcie *dw)
 	dw_pcie_writel_dbi(dw, TRANSLATION_CONTROL, RC_PASS_ADDR_RANGE);
 }
 
-static int st_pcie_init(struct pcie_port *pp)
+static int st_pcie_init(struct dw_pcie_rp *pp)
 {
 	struct dw_pcie *dw = to_dw_pcie_from_pp(pp);
 	struct st_pcie *pcie = to_st_pcie(dw);
@@ -200,7 +200,7 @@ static int st_pcie_control_ltssm(struct dw_pcie *dw, bool enable)
 				  FIELD_PREP(PCIE_APP_LTSSM_ENABLE, enable));
 }
 
-static int st_pcie_host_init(struct pcie_port *pp)
+static int st_pcie_host_init(struct dw_pcie_rp *pp)
 {
 	struct dw_pcie *dw = to_dw_pcie_from_pp(pp);
 	struct st_pcie *pcie = to_st_pcie(dw);
@@ -293,7 +293,7 @@ static int __init st_pcie_probe(struct platform_device *pdev)
 	struct st_pcie *pcie;
 	struct dw_pcie *dw;
 	struct device_node *np = pdev->dev.of_node;
-	struct pcie_port *pp;
+	struct dw_pcie_rp *pp;
 	int ret;
 
 	pcie = devm_kzalloc(&pdev->dev, sizeof(*pcie), GFP_KERNEL);
-- 
2.48.1

From 531585b5fd727f6ed920573bab91a155045838ad Mon Sep 17 00:00:00 2001
From: Jerome Audu <jerome.audu@st.com>
Date: Mon, 26 Dec 2022 15:44:52 +0100
Subject: [PATCH 04/72] pci: dwc: pcie-st: PCI_MSI_IRQ_DOMAIN -> PCI_MSI

---
 drivers/pci/controller/dwc/Kconfig | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/pci/controller/dwc/Kconfig b/drivers/pci/controller/dwc/Kconfig
index 55be73ee511a..150b19bdc792 100644
--- a/drivers/pci/controller/dwc/Kconfig
+++ b/drivers/pci/controller/dwc/Kconfig
@@ -462,7 +462,7 @@ config PCIE_VISCONTI_HOST
 config PCIE_STI
 	bool "STMicroelectronics PCIe Controller for STi SoCs"
 	depends on ARCH_STI || COMPILE_TEST
-	depends on OF && PCI_MSI_IRQ_DOMAIN
+	depends on OF && PCI_MSI
 	select PCIE_DW_HOST
 	help
 	  Enable PCIe controller support on STMicroelectronics STi SoCs.
-- 
2.48.1

From 08b4f96cbdb641b84d1bdc3d8fe58e702dda8353 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Sat, 19 Dec 2020 17:07:21 +0100
Subject: [PATCH 05/72] MAINTAINERS: add entry for ST STI PCIE driver

Add PCIE Driver entry for STI family from ST Microelectronics.

Signed-off-by: Alain Volmat <avolmat@me.com>

v2: identical to v1
---
 MAINTAINERS | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/MAINTAINERS b/MAINTAINERS
index 0fa7c5728f1e..94a58034a346 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -17955,6 +17955,12 @@ L:	linux-samsung-soc@vger.kernel.org
 S:	Maintained
 F:	drivers/pci/controller/dwc/pci-exynos.c
 
+PCI DRIVER FOR ST STI PLATFORM
+M:	Alain Volmat <avolmat@me.com>
+L:	linux-pci@vger.kernel.org
+S:	Maintained
+F:	drivers/pci/controller/dwc/pcie-sti.c
+
 PCI DRIVER FOR SYNOPSYS DESIGNWARE
 M:	Jingoo Han <jingoohan1@gmail.com>
 M:	Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
-- 
2.48.1

From d59000d4c1229f8b2ce0067bed502a1b69bc528e Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Sat, 4 Dec 2021 22:38:28 +0100
Subject: [PATCH 06/72] ARM: dts: sti: add the PCIe controller node within
 stih407-family

Add the pcie1 entry within stih407-family dtsi.

Signed-off-by: Alain Volmat <avolmat@me.com>

v2: remove useless line break
    change reset lines order
---
 arch/arm/boot/dts/st/stih407-family.dtsi | 40 ++++++++++++++++++++++++
 1 file changed, 40 insertions(+)

diff --git a/arch/arm/boot/dts/st/stih407-family.dtsi b/arch/arm/boot/dts/st/stih407-family.dtsi
index 35a55aef7f4b..6d5941a1101b 100644
--- a/arch/arm/boot/dts/st/stih407-family.dtsi
+++ b/arch/arm/boot/dts/st/stih407-family.dtsi
@@ -661,6 +661,46 @@ spifsm: spifsm@9022000 {
 			status = "disabled";
 		};
 
+		pcie1: pcie@9b10000 {
+			compatible = "st,stih407-pcie";
+			device_type = "pci";
+			reg = <0x09b10000 0x00001000>,	/* cntrl registers */
+			      <0x3fff0000 0x00010000>,	/* config space */
+			      <0x40000000 0xc0000000>;	/* lmi mem window */
+
+			reg-names = "dbi",
+				    "config",
+				    "mem-window";
+
+			st,syscfg = <&syscfg_core 0xdc 0xe4>;
+
+			#interrupt-cells = <1>;
+			interrupts = <GIC_SPI 175 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "msi";
+			interrupt-map-mask = <0 0 0 7>;
+			interrupt-map = <0 0 0 1 &intc GIC_SPI 171 IRQ_TYPE_LEVEL_HIGH>,
+					<0 0 0 2 &intc GIC_SPI 172 IRQ_TYPE_LEVEL_HIGH>,
+					<0 0 0 3 &intc GIC_SPI 173 IRQ_TYPE_LEVEL_HIGH>,
+					<0 0 0 4 &intc GIC_SPI 174 IRQ_TYPE_LEVEL_HIGH>;
+
+			#address-cells = <3>;
+			#size-cells = <2>;
+			/* non-prefetchable and prefetchable */
+			ranges = <0x82000000 0 0x30000000 0x30000000 0 0x05550000>,
+				 <0xc2000000 0 0x35550000 0x35550000 0 0x0AAA0000>;
+			bus-range = <0x00 0xff>;
+
+			resets = <&softreset STIH407_PCIE1_SOFTRESET>,
+				 <&powerdown STIH407_PCIE1_POWERDOWN>;
+
+			reset-names = "softreset", "powerdown";
+
+			phys = <&phy_port1 PHY_TYPE_PCIE>;
+			phy-names = "pcie";
+
+			status = "disabled";
+		};
+
 		sata0: sata@9b20000 {
 			compatible = "st,ahci";
 			reg = <0x9b20000 0x1000>;
-- 
2.48.1

From d722b0fc55b51bf345c79100b9eb019972ce700e Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Wed, 8 Dec 2021 18:39:26 +0100
Subject: [PATCH 07/72] ARM: dts: sti: enable PCIe on the stih418-b2264 board

Enable the PCIe controller with proper reset gpio pin for this board.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/boot/dts/st/stih418-b2264.dts | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/arch/arm/boot/dts/st/stih418-b2264.dts b/arch/arm/boot/dts/st/stih418-b2264.dts
index fdc16e9f5822..3bd65566ed2e 100644
--- a/arch/arm/boot/dts/st/stih418-b2264.dts
+++ b/arch/arm/boot/dts/st/stih418-b2264.dts
@@ -130,6 +130,11 @@ &ohci1 {
 	status = "okay";
 };
 
+&pcie1 {
+	reset-gpios = <&pio34 5 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
 &pwm1 {
 	status = "okay";
 };
-- 
2.48.1

From 766362595234e4de19841bb5324b89586a765d13 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Wed, 1 Apr 2020 11:58:33 +0200
Subject: [PATCH 08/72] mtd: st_spi_fsm: disable QuadSPI write mode

NOT TO BE UPSTREAMED - temporary workaround in order to
enable write on the SPINor.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/mtd/devices/st_spi_fsm.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/drivers/mtd/devices/st_spi_fsm.c b/drivers/mtd/devices/st_spi_fsm.c
index dba584fa2a53..adf8eeb03a35 100644
--- a/drivers/mtd/devices/st_spi_fsm.c
+++ b/drivers/mtd/devices/st_spi_fsm.c
@@ -368,7 +368,9 @@ static struct flash_info flash_types[] = {
 	{ "n25q128", 0x20ba18, 0, 64 * 1024,  256, N25Q_FLAG, 108,
 	  stfsm_n25q_config },
 	{ "n25q256", 0x20ba19, 0, 64 * 1024,  512,
-	  N25Q_FLAG | FLASH_FLAG_32BIT_ADDR, 108, stfsm_n25q_config },
+	  (N25Q_FLAG | FLASH_FLAG_32BIT_ADDR) &
+	  ~(FLASH_FLAG_WRITE_1_1_4 | FLASH_FLAG_WRITE_1_4_4),
+	  108, stfsm_n25q_config },
 
 	/*
 	 * Spansion S25FLxxxP
-- 
2.48.1

From df32910b674775a54b99187e5f750f9e95722182 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Sun, 22 Mar 2020 13:06:36 +0100
Subject: [PATCH 09/72] Revert "ARM: sti: remove pen_release and boot_lock"

This reverts commit 704cfd7f5f71c6bc6cdfaa63a16ed0f72882b1a1.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/mach-sti/Makefile  |  2 +-
 arch/arm/mach-sti/headsmp.S | 43 ++++++++++++++++++
 arch/arm/mach-sti/platsmp.c | 88 +++++++++++++++++++++++++++++++------
 3 files changed, 118 insertions(+), 15 deletions(-)
 create mode 100644 arch/arm/mach-sti/headsmp.S

diff --git a/arch/arm/mach-sti/Makefile b/arch/arm/mach-sti/Makefile
index 7e2a58257401..523b36bbaba6 100644
--- a/arch/arm/mach-sti/Makefile
+++ b/arch/arm/mach-sti/Makefile
@@ -1,3 +1,3 @@
 # SPDX-License-Identifier: GPL-2.0-only
-obj-$(CONFIG_SMP)		+= platsmp.o
+obj-$(CONFIG_SMP)		+= platsmp.o headsmp.o
 obj-$(CONFIG_ARCH_STI) 		+= board-dt.o
diff --git a/arch/arm/mach-sti/headsmp.S b/arch/arm/mach-sti/headsmp.S
new file mode 100644
index 000000000000..e0ad451700d5
--- /dev/null
+++ b/arch/arm/mach-sti/headsmp.S
@@ -0,0 +1,43 @@
+/*
+ *  arch/arm/mach-sti/headsmp.S
+ *
+ * Copyright (C) 2013 STMicroelectronics (R&D) Limited.
+ *		http://www.st.com
+ *
+ * Cloned from linux/arch/arm/mach-vexpress/headsmp.S
+ *
+ *  Copyright (c) 2003 ARM Limited
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+/*
+ * ST specific entry point for secondary CPUs.  This provides
+ * a "holding pen" into which all secondary cores are held until we're
+ * ready for them to initialise.
+ */
+ENTRY(sti_secondary_startup)
+	mrc	p15, 0, r0, c0, c0, 5
+	and	r0, r0, #15
+	adr	r4, 1f
+	ldmia	r4, {r5, r6}
+	sub	r4, r4, r5
+	add	r6, r6, r4
+pen:	ldr	r7, [r6]
+	cmp	r7, r0
+	bne	pen
+
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
+	b	secondary_startup
+ENDPROC(sti_secondary_startup)
+
+1:	.long	.
+	.long	pen_release
diff --git a/arch/arm/mach-sti/platsmp.c b/arch/arm/mach-sti/platsmp.c
index e2ba04b562be..358d0ac708fc 100644
--- a/arch/arm/mach-sti/platsmp.c
+++ b/arch/arm/mach-sti/platsmp.c
@@ -25,33 +25,82 @@
 
 #include "smp.h"
 
-static u32 __iomem *cpu_strt_ptr;
+static void write_pen_release(int val)
+{
+	pen_release = val;
+	smp_wmb();
+	sync_cache_w(&pen_release);
+}
+
+static DEFINE_SPINLOCK(boot_lock);
+
+static void sti_secondary_init(unsigned int cpu)
+{
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	write_pen_release(-1);
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
 
 static int sti_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
-	unsigned long entry_pa = __pa_symbol(secondary_startup);
+	unsigned long timeout;
 
 	/*
-	 * Secondary CPU is initialised and started by a U-BOOTROM firmware.
-	 * Secondary CPU is spinning and waiting for a write at cpu_strt_ptr.
-	 * Writing secondary_startup address at cpu_strt_ptr makes it to
-	 * jump directly to secondary_startup().
+	 * set synchronisation state between this boot processor
+	 * and the secondary one
 	 */
-	__raw_writel(entry_pa, cpu_strt_ptr);
+	spin_lock(&boot_lock);
 
-	/* wmb so that data is actually written before cache flush is done */
-	smp_wmb();
-	sync_cache_w(cpu_strt_ptr);
+	/*
+	 * The secondary processor is waiting to be released from
+	 * the holding pen - release it, then wait for it to flag
+	 * that it has been released by resetting pen_release.
+	 *
+	 * Note that "pen_release" is the hardware CPU ID, whereas
+	 * "cpu" is Linux's internal ID.
+	 */
+	write_pen_release(cpu_logical_map(cpu));
 
-	return 0;
+	/*
+	 * Send the secondary CPU a soft interrupt, thereby causing
+	 * it to jump to the secondary entrypoint.
+	 */
+	arch_send_wakeup_ipi_mask(cpumask_of(cpu));
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		smp_rmb();
+		if (pen_release == -1)
+			break;
+
+		udelay(10);
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return pen_release != -1 ? -ENOSYS : 0;
 }
 
 static void __init sti_smp_prepare_cpus(unsigned int max_cpus)
 {
 	struct device_node *np;
 	void __iomem *scu_base;
+	u32 __iomem *cpu_strt_ptr;
 	u32 release_phys;
 	int cpu;
+	unsigned long entry_pa = __pa_symbol(sti_secondary_startup);
 
 	np = of_find_compatible_node(NULL, NULL, "arm,cortex-a9-scu");
 
@@ -79,8 +128,8 @@ static void __init sti_smp_prepare_cpus(unsigned int max_cpus)
 		}
 
 		/*
-		 * cpu-release-addr is usually configured in SBC DMEM but can
-		 * also be in RAM.
+		 * holding pen is usually configured in SBC DMEM but can also be
+		 * in RAM.
 		 */
 
 		if (!memblock_is_memory(release_phys))
@@ -90,11 +139,22 @@ static void __init sti_smp_prepare_cpus(unsigned int max_cpus)
 			cpu_strt_ptr =
 				(u32 __iomem *)phys_to_virt(release_phys);
 
-		set_cpu_possible(cpu, true);
+		__raw_writel(entry_pa, cpu_strt_ptr);
+
+		/*
+		 * wmb so that data is actually written
+		 * before cache flush is done
+		 */
+		smp_wmb();
+		sync_cache_w(cpu_strt_ptr);
+
+		if (!memblock_is_memory(release_phys))
+			iounmap(cpu_strt_ptr);
 	}
 }
 
 const struct smp_operations sti_smp_ops __initconst = {
 	.smp_prepare_cpus	= sti_smp_prepare_cpus,
+	.smp_secondary_init	= sti_secondary_init,
 	.smp_boot_secondary	= sti_boot_secondary,
 };
-- 
2.48.1

From 383ef6c8397888490ae70ad2920d85bc674b190f Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Sun, 22 Mar 2020 13:06:54 +0100
Subject: [PATCH 10/72] arm: mach-sti: add back pen_release volatile

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/mach-sti/platsmp.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/arch/arm/mach-sti/platsmp.c b/arch/arm/mach-sti/platsmp.c
index 358d0ac708fc..fc50c66aed5c 100644
--- a/arch/arm/mach-sti/platsmp.c
+++ b/arch/arm/mach-sti/platsmp.c
@@ -25,6 +25,9 @@
 
 #include "smp.h"
 
+/* XXX pen_release is cargo culted code - DO NOT COPY XXX */
+volatile int pen_release = -1;
+
 static void write_pen_release(int val)
 {
 	pen_release = val;
-- 
2.48.1

From d78b813c96b7bd752ec20a5ec5df74b7f5edae06 Mon Sep 17 00:00:00 2001
From: Sudeep Holla <sudeep.holla@arm.com>
Date: Mon, 23 Feb 2015 18:28:10 +0000
Subject: [PATCH 16/72] ARM: kernel: add support for cpu cache information

This patch adds support for cacheinfo on ARM platforms.

On ARMv7, the cache hierarchy can be identified through Cache Level ID
register(CLIDR) while the cache geometry is provided by Cache Size ID
register(CCSIDR).

On architecture versions before ARMv7, CLIDR and CCSIDR is not
implemented. The cache type register(CTR) provides both cache hierarchy
and geometry if implemented. For implementations that doesn't support
CTR, we need to list the probable value of CTR if it was implemented
along with the cpuid for the sake of simplicity to handle them.

Since the architecture doesn't provide any way of detecting the cpus
sharing particular cache, device tree is used fo the same purpose.
On non-DT platforms, first level caches are per-cpu while higher level
caches are assumed system-wide.

This is based on the newly introduced generic cacheinfo infrastructure
through the commit 246246cbde5e ("drivers: base: support cpu cache
information interface to userspace via sysfs")

Signed-off-by: Sudeep Holla <sudeep.holla@arm.com>
Tested-by: Stephen Boyd <sboyd@codeaurora.org>
Cc: Russell King <linux@arm.linux.org.uk>
Cc: Will Deacon <will.deacon@arm.com>
Cc: linux-arm-kernel@lists.infradead.org
---
 arch/arm/kernel/Makefile    |   1 +
 arch/arm/kernel/cacheinfo.c | 282 ++++++++++++++++++++++++++++++++++++
 arch/arm/mm/Kconfig         |  13 ++
 3 files changed, 296 insertions(+)
 create mode 100644 arch/arm/kernel/cacheinfo.c

diff --git a/arch/arm/kernel/Makefile b/arch/arm/kernel/Makefile
index aaae31b8c4a5..84e7e30043d4 100644
--- a/arch/arm/kernel/Makefile
+++ b/arch/arm/kernel/Makefile
@@ -38,6 +38,7 @@ obj-y		+= entry-v7m.o v7m.o
 else
 obj-y		+= entry-armv.o
 endif
+obj-$(CONFIG_CPU_HAS_CACHE) += cacheinfo.o
 
 obj-$(CONFIG_MMU)		+= bugs.o
 obj-$(CONFIG_CPU_IDLE)		+= cpuidle.o
diff --git a/arch/arm/kernel/cacheinfo.c b/arch/arm/kernel/cacheinfo.c
new file mode 100644
index 000000000000..0c4a67dcbcaf
--- /dev/null
+++ b/arch/arm/kernel/cacheinfo.c
@@ -0,0 +1,282 @@
+/*
+ *  ARM cacheinfo support
+ *
+ *  Copyright (C) 2015 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/bitops.h>
+#include <linux/cacheinfo.h>
+#include <linux/cpu.h>
+#include <linux/compiler.h>
+#include <linux/of.h>
+
+#include <asm/cputype.h>
+#include <asm/processor.h>
+#include <asm/system_info.h>
+
+#define cache_is_armv7() \
+	(cpu_architecture() >= CPU_ARCH_ARMv7 && !armv6_extended())
+#define MAX_CACHE_LEVEL		(cache_is_armv7() ? 7 : 1)
+
+#define CTR_CTYPE_SHIFT		24
+#define CTR_CTYPE_MASK		(1 << CTR_CTYPE_SHIFT)
+
+struct ctr_info {
+	unsigned int cpuid_part;
+	unsigned int ctr;
+};
+
+/*
+ *  Cache Type Register
+ *  +---------------------------------+
+ *  | 31 29 | 28 25 |24| 23 12 | 11 0 |
+ *  +---------------------------------+
+ *  | 0 0 0 | Ctype | S| Dsize | Isize|
+ *  +---------------------------------+
+ * The table below encodes only Dsize and Isize
+ */
+static struct ctr_info cache_ctr_list[] = {
+	{0x4400a100, 0x0016A16A }, /* SA-110:  32kB D$, 32kB I$ */
+	{0x4400a110, 0x0012A16A }, /* SA-1100: 16kB D$, 32kB I$ */
+	{0x6900b110, 0x0012A16A }, /* SA-1110: 16kB D$, 32kB I$ */
+};
+
+/*
+ * List of CPUs reported as ARMv7 but don't implement CLIDR,
+ * CSSELR and CCSIDR. Cache information is still available from CTR
+ */
+static int armv6_ext_cpuid_part[] = {
+	0x4100b020, /* ARM11MP */
+	0x4100b760, /* ARM1176 */
+};
+
+static bool armv6_extended(void)
+{
+	int i, cpuid_part = read_cpuid_part();
+
+	for (i = 0; i < ARRAY_SIZE(armv6_ext_cpuid_part); i++)
+		if (armv6_ext_cpuid_part[i] == cpuid_part)
+			return true;
+	return false;
+}
+
+static int get_unimplemented_ctr(unsigned int *ctr)
+{
+	int i, cpuid_part = read_cpuid_part();
+
+	for (i = 0; i < ARRAY_SIZE(cache_ctr_list); i++)
+		if (cache_ctr_list[i].cpuid_part == cpuid_part) {
+			*ctr = cache_ctr_list[i].ctr;
+			return 0;
+		}
+	return -ENOENT;
+}
+
+static unsigned int get_ctr(void)
+{
+	unsigned int ctr;
+
+	if (get_unimplemented_ctr(&ctr))
+		ctr = read_cpuid_cachetype();
+	return ctr;
+}
+
+static enum cache_type __get_cache_type(int level)
+{
+	if (level > MAX_CACHE_LEVEL)
+		return CACHE_TYPE_NOCACHE;
+	return get_ctr() & CTR_CTYPE_MASK ?
+		CACHE_TYPE_SEPARATE : CACHE_TYPE_UNIFIED;
+}
+
+/*
+ *  +---------------------------------+
+ *  | 9  8  7  6 | 5  4  3 | 2 | 1  0 |
+ *  +---------------------------------+
+ *  |    size    |  assoc  | m |  len |
+ *  +---------------------------------+
+ * linelen        = 1 << (len + 3)
+ * multiplier     = 2 + m
+ * nsets          = 1 << (size + 6 - assoc - len)
+ * associativity  = multiplier << (assoc - 1)
+ * cache_size     = multiplier << (size + 8)
+ */
+#define CTR_LINESIZE_MASK	0x3
+#define CTR_MULTIPLIER_SHIFT	2
+#define CTR_MULTIPLIER_MASK	0x1
+#define CTR_ASSOCIAT_SHIFT	3
+#define CTR_ASSOCIAT_MASK	0x7
+#define CTR_SIZE_SHIFT		6
+#define CTR_SIZE_MASK		0xF
+#define CTR_DCACHE_SHIFT	12
+
+static void __ci_leaf_init(enum cache_type type, struct cacheinfo *this_leaf)
+{
+	unsigned int size, multiplier, assoc, len, tmp = get_ctr();
+
+	if (type == CACHE_TYPE_DATA)
+		tmp >>= CTR_DCACHE_SHIFT;
+
+	len = tmp & CTR_LINESIZE_MASK;
+	size = (tmp >> CTR_SIZE_SHIFT) & CTR_SIZE_MASK;
+	assoc = (tmp >> CTR_ASSOCIAT_SHIFT) & CTR_ASSOCIAT_MASK;
+	multiplier = ((tmp >> CTR_MULTIPLIER_SHIFT) & CTR_MULTIPLIER_MASK) + 2;
+
+	this_leaf->type = type;
+	this_leaf->coherency_line_size = 1 << (len + 3);
+	this_leaf->number_of_sets = 1 << (size + 6 - assoc - len);
+	this_leaf->ways_of_associativity = multiplier << (assoc - 1);
+	this_leaf->size = multiplier << (size + 8);
+}
+
+/* Ctypen, bits[3(n - 1) + 2 : 3(n - 1)], for n = 1 to 7 */
+#define CLIDR_CTYPE_SHIFT(level)	(3 * (level - 1))
+#define CLIDR_CTYPE_MASK(level)		(7 << CLIDR_CTYPE_SHIFT(level))
+#define CLIDR_CTYPE(clidr, level)	\
+	(((clidr) & CLIDR_CTYPE_MASK(level)) >> CLIDR_CTYPE_SHIFT(level))
+
+static inline enum cache_type __armv7_get_cache_type(int level)
+{
+	unsigned int clidr;
+
+	if (level > MAX_CACHE_LEVEL)
+		return CACHE_TYPE_NOCACHE;
+	asm volatile ("mrc p15, 1, %0, c0, c0, 1" : "=r" (clidr));
+	return CLIDR_CTYPE(clidr, level);
+}
+
+/*
+ * NumSets, bits[27:13] - (Number of sets in cache) - 1
+ * Associativity, bits[12:3] - (Associativity of cache) - 1
+ * LineSize, bits[2:0] - (Log2(Number of words in cache line)) - 2
+ */
+#define CCSIDR_WRITE_THROUGH		BIT(31)
+#define CCSIDR_WRITE_BACK		BIT(30)
+#define CCSIDR_READ_ALLOCATE		BIT(29)
+#define CCSIDR_WRITE_ALLOCATE		BIT(28)
+#define CCSIDR_LINESIZE_MASK		0x7
+#define CCSIDR_LINESIZE(x)		((x) & CCSIDR_LINESIZE_MASK)
+#define CCSIDR_ASSOCIATIVITY_SHIFT	3
+#define CCSIDR_ASSOCIATIVITY_MASK	0x3ff
+#define CCSIDR_ASSOCIATIVITY(x)	\
+	(((x) >> CCSIDR_ASSOCIATIVITY_SHIFT) & CCSIDR_ASSOCIATIVITY_MASK)
+#define CCSIDR_NUMSETS_SHIFT		13
+#define CCSIDR_NUMSETS_MASK		0x7fff
+#define CCSIDR_NUMSETS(x) \
+	(((x) >> CCSIDR_NUMSETS_SHIFT) & CCSIDR_NUMSETS_MASK)
+
+#define CACHE_LINESIZE(x)		(16 << CCSIDR_LINESIZE(x))
+#define CACHE_NUMSETS(x)		(CCSIDR_NUMSETS(x) + 1)
+#define CACHE_ASSOCIATIVITY(x)		(CCSIDR_ASSOCIATIVITY(x) + 1)
+
+/*
+ * Cache Size Selection Register(CSSELR) selects which Cache Size ID
+ * Register(CCSIDR) is accessible by specifying the required cache
+ * level and the cache type. We need to ensure that no one else changes
+ * CSSELR by calling this in non-preemtible context
+ */
+static u32 __attribute_const__ cache_get_ccsidr(u32 csselr)
+{
+	u32 ccsidr;
+
+	/* Put value into CSSELR */
+	asm volatile ("mcr p15, 2, %0, c0, c0, 0" : : "r" (csselr));
+	isb();
+	/* Read result out of CCSIDR */
+	asm volatile ("mrc p15, 1, %0, c0, c0, 0" : "=r" (ccsidr));
+
+	return ccsidr;
+}
+
+static void __armv7_ci_leaf_init(enum cache_type type,
+				 struct cacheinfo *this_leaf)
+{
+	bool is_icache = type & CACHE_TYPE_INST;
+	u32 tmp = cache_get_ccsidr((this_leaf->level - 1) << 1 | is_icache);
+
+	this_leaf->type = type;
+	this_leaf->coherency_line_size = CACHE_LINESIZE(tmp);
+	this_leaf->number_of_sets = CACHE_NUMSETS(tmp);
+	this_leaf->ways_of_associativity = CACHE_ASSOCIATIVITY(tmp);
+	this_leaf->size = this_leaf->number_of_sets *
+	    this_leaf->coherency_line_size * this_leaf->ways_of_associativity;
+	this_leaf->attributes =
+		((tmp & CCSIDR_WRITE_THROUGH) ? CACHE_WRITE_THROUGH : 0) |
+		((tmp & CCSIDR_WRITE_BACK) ? CACHE_WRITE_BACK : 0) |
+		((tmp & CCSIDR_READ_ALLOCATE) ? CACHE_READ_ALLOCATE : 0) |
+		((tmp & CCSIDR_WRITE_ALLOCATE) ? CACHE_WRITE_ALLOCATE : 0);
+}
+
+static inline enum cache_type get_cache_type(int level)
+{
+	if (cache_is_armv7())
+		return __armv7_get_cache_type(level);
+	return __get_cache_type(level);
+}
+
+static void ci_leaf_init(struct cacheinfo *this_leaf,
+			 enum cache_type type, unsigned int level)
+{
+	this_leaf->level = level;
+	if (cache_is_armv7())
+		__armv7_ci_leaf_init(type, this_leaf);
+	else
+		__ci_leaf_init(type, this_leaf);
+}
+
+static int __init_cache_level(unsigned int cpu)
+{
+	unsigned int ctype, level, leaves;
+	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);
+
+	for (level = 1, leaves = 0; level <= MAX_CACHE_LEVEL; level++) {
+		ctype = get_cache_type(level);
+		if (ctype == CACHE_TYPE_NOCACHE) {
+			level--;
+			break;
+		}
+		/* Separate instruction and data caches */
+		leaves += (ctype == CACHE_TYPE_SEPARATE) ? 2 : 1;
+	}
+
+	this_cpu_ci->num_levels = level;
+	this_cpu_ci->num_leaves = leaves;
+
+	return 0;
+}
+
+static int __populate_cache_leaves(unsigned int cpu)
+{
+	unsigned int level, idx;
+	enum cache_type type;
+	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);
+	struct cacheinfo *this_leaf = this_cpu_ci->info_list;
+
+	for (idx = 0, level = 1; level <= this_cpu_ci->num_levels &&
+	     idx < this_cpu_ci->num_leaves; idx++, level++) {
+		type = get_cache_type(level);
+		if (type == CACHE_TYPE_SEPARATE) {
+			ci_leaf_init(this_leaf++, CACHE_TYPE_DATA, level);
+			ci_leaf_init(this_leaf++, CACHE_TYPE_INST, level);
+		} else {
+			ci_leaf_init(this_leaf++, type, level);
+		}
+	}
+	return 0;
+}
+
+DEFINE_SMP_CALL_CACHE_FUNCTION(init_cache_level)
+DEFINE_SMP_CALL_CACHE_FUNCTION(populate_cache_leaves)
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index 2b6f50dd5478..217e4f2486cd 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -522,30 +522,42 @@ config CPU_PABRT_V7
 # The cache model
 config CPU_CACHE_V4
 	bool
+	select CPU_HAS_CACHE
 
 config CPU_CACHE_V4WT
 	bool
+	select CPU_HAS_CACHE
 
 config CPU_CACHE_V4WB
 	bool
+	select CPU_HAS_CACHE
 
 config CPU_CACHE_V6
 	bool
+	select CPU_HAS_CACHE
 
 config CPU_CACHE_V7
 	bool
+	select CPU_HAS_CACHE
 
 config CPU_CACHE_NOP
 	bool
+	select CPU_HAS_CACHE
 
 config CPU_CACHE_VIVT
 	bool
+	select CPU_HAS_CACHE
 
 config CPU_CACHE_VIPT
 	bool
+	select CPU_HAS_CACHE
 
 config CPU_CACHE_FA
 	bool
+	select CPU_HAS_CACHE
+
+config CPU_HAS_CACHE
+	bool
 
 config CPU_CACHE_V7M
 	bool
@@ -940,6 +952,7 @@ config VDSO
 
 config OUTER_CACHE
 	bool
+	select CPU_HAS_CACHE
 
 config OUTER_CACHE_SYNC
 	bool
-- 
2.48.1

From 4c02489af372d63cd9c1439687acea3ba22bdbe5 Mon Sep 17 00:00:00 2001
From: Jerome AUDU <jau@free.fr>
Date: Mon, 20 Sep 2021 14:41:15 +0200
Subject: [PATCH 17/72] ARM: kernel: cacheinfo: Get rid of
 DEFINE_SMP_CALL_CACHE_FUNCTION()

Needed after 4b92d4add5f6:
drivers: base: cacheinfo: Get rid of DEFINE_SMP_CALL_CACHE_FUNCTION()

DEFINE_SMP_CALL_CACHE_FUNCTION() was usefel before the CPU hotplug rework
to ensure that the cache related functions are called on the upcoming CPU
because the notifier itself could run on any online CPU.

Signed-off-by: Jerome AUDU <jau@free.fr>
---
 arch/arm/kernel/cacheinfo.c | 7 ++-----
 1 file changed, 2 insertions(+), 5 deletions(-)

diff --git a/arch/arm/kernel/cacheinfo.c b/arch/arm/kernel/cacheinfo.c
index 0c4a67dcbcaf..c5ccf114bcb5 100644
--- a/arch/arm/kernel/cacheinfo.c
+++ b/arch/arm/kernel/cacheinfo.c
@@ -237,7 +237,7 @@ static void ci_leaf_init(struct cacheinfo *this_leaf,
 		__ci_leaf_init(type, this_leaf);
 }
 
-static int __init_cache_level(unsigned int cpu)
+int init_cache_level(unsigned int cpu)
 {
 	unsigned int ctype, level, leaves;
 	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);
@@ -258,7 +258,7 @@ static int __init_cache_level(unsigned int cpu)
 	return 0;
 }
 
-static int __populate_cache_leaves(unsigned int cpu)
+int populate_cache_leaves(unsigned int cpu)
 {
 	unsigned int level, idx;
 	enum cache_type type;
@@ -277,6 +277,3 @@ static int __populate_cache_leaves(unsigned int cpu)
 	}
 	return 0;
 }
-
-DEFINE_SMP_CALL_CACHE_FUNCTION(init_cache_level)
-DEFINE_SMP_CALL_CACHE_FUNCTION(populate_cache_leaves)
-- 
2.48.1

From fc13902f1011639f521da60b077b14341ac5bcfa Mon Sep 17 00:00:00 2001
From: Jerome Audu <jerome.audu@st.com>
Date: Wed, 3 Mar 2021 18:26:12 +0100
Subject: [PATCH 18/72] dts: arm: stih418-b2264: port1 (USB3 ?) of miphy28

---
 arch/arm/boot/dts/st/stih418-b2264.dts | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/arch/arm/boot/dts/st/stih418-b2264.dts b/arch/arm/boot/dts/st/stih418-b2264.dts
index 3bd65566ed2e..2b96a89b99ba 100644
--- a/arch/arm/boot/dts/st/stih418-b2264.dts
+++ b/arch/arm/boot/dts/st/stih418-b2264.dts
@@ -120,6 +120,9 @@ phy_port0: port@9b22000 {
 		st,sata-gen = <2>; /* SATA GEN3 */
 		st,osc-rdy;
 	};
+	phy_port1: port@9b2a000 {
+		st,osc-force-ext;
+	};
 };
 
 &mmc0 {
-- 
2.48.1

From ee845dce04a4c2f536b33cf450e3e672b35246c7 Mon Sep 17 00:00:00 2001
From: Jerome Audu <jerome.audu@st.com>
Date: Wed, 3 Mar 2021 18:31:25 +0100
Subject: [PATCH 19/72] dts: arm: stih418-b2264: partitions for SPINOR

---
 arch/arm/boot/dts/st/stih418-b2264.dts | 27 ++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/arch/arm/boot/dts/st/stih418-b2264.dts b/arch/arm/boot/dts/st/stih418-b2264.dts
index 2b96a89b99ba..784acb465221 100644
--- a/arch/arm/boot/dts/st/stih418-b2264.dts
+++ b/arch/arm/boot/dts/st/stih418-b2264.dts
@@ -152,6 +152,33 @@ &sbc_serial0 {
 
 &spifsm {
 	status = "okay";
+	partitions {
+		compatible = "fixed-partitions";
+		#address-cells = <1>;
+		#size-cells = <1>;
+
+		partition@0 {
+			label = "PBL"; /* 768Ko */
+			reg = < 0x0 0xc0000 >;
+			read-only;
+		};
+
+		partition@1 {
+			label = "u-boot-env"; /* 64Ko */
+			reg = < 0xc0000 0x10000 >;
+		};
+
+		partition@2 {
+			label = "mac-address-eth0"; /* 192Ko */
+			reg = < 0xd0000 0x30000 >;
+			read-only;
+		};
+
+		partition@3 {
+			label = "FIT"; /* 31 Mo */
+			reg = < 0x100000 0x1F00000 >;
+		};
+	};
 };
 
 &st_dwc3 {
-- 
2.48.1

From a17cd79ef9380bcbf8fc19c6c4eca0c1209d2f12 Mon Sep 17 00:00:00 2001
From: Jerome Audu <jerome.audu@st.com>
Date: Wed, 23 Aug 2023 10:48:29 +0200
Subject: [PATCH 20/72] ARM: dts: sti: Introduce 4KOpen-Box (stih418-b2264-box)
 board

# Conflicts:
#	arch/arm/boot/dts/Makefile
---
 arch/arm/boot/dts/st/Makefile              |  3 ++-
 arch/arm/boot/dts/st/stih418-b2264-box.dts | 14 ++++++++++++++
 2 files changed, 16 insertions(+), 1 deletion(-)
 create mode 100644 arch/arm/boot/dts/st/stih418-b2264-box.dts

diff --git a/arch/arm/boot/dts/st/Makefile b/arch/arm/boot/dts/st/Makefile
index eab3a9bd435f..4be5e4a252ae 100644
--- a/arch/arm/boot/dts/st/Makefile
+++ b/arch/arm/boot/dts/st/Makefile
@@ -17,7 +17,8 @@ dtb-$(CONFIG_ARCH_STI) += \
 	stih410-b2120.dtb \
 	stih410-b2260.dtb \
 	stih418-b2199.dtb \
-	stih418-b2264.dtb
+	stih418-b2264.dtb \
+	stih418-b2264-box.dtb
 dtb-$(CONFIG_ARCH_STM32) += \
 	stm32f429-disco.dtb \
 	stm32f469-disco.dtb \
diff --git a/arch/arm/boot/dts/st/stih418-b2264-box.dts b/arch/arm/boot/dts/st/stih418-b2264-box.dts
new file mode 100644
index 000000000000..162bd77dd993
--- /dev/null
+++ b/arch/arm/boot/dts/st/stih418-b2264-box.dts
@@ -0,0 +1,14 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2021 STMicroelectronics
+ * Author: Jerome Audu <jerome.audu@st.com>
+ */
+/dts-v1/;
+
+#include "stih418-b2264.dts"
+/ {
+	model = "STiH418 B2264 with Box";
+	compatible = "st,stih418-b2264-box", "st,stih418-b2264", "st,stih418";
+	soc {
+	};
+};
-- 
2.48.1

From 12c7eb620f4377183c65ade593c9c362a306d60f Mon Sep 17 00:00:00 2001
From: Jerome Audu <jerome.audu@st.com>
Date: Thu, 4 Mar 2021 22:11:15 +0100
Subject: [PATCH 21/72] dts: arm: stih418-b2264-box: I2C available on Pin 3 /
 Pin 5 of the GPIO 40 pins connector

---
 arch/arm/boot/dts/st/stih418-b2264-box.dts | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/arch/arm/boot/dts/st/stih418-b2264-box.dts b/arch/arm/boot/dts/st/stih418-b2264-box.dts
index 162bd77dd993..81d0b1c4238c 100644
--- a/arch/arm/boot/dts/st/stih418-b2264-box.dts
+++ b/arch/arm/boot/dts/st/stih418-b2264-box.dts
@@ -10,5 +10,15 @@ / {
 	model = "STiH418 B2264 with Box";
 	compatible = "st,stih418-b2264-box", "st,stih418-b2264", "st,stih418";
 	soc {
+		/* I2C available on Pin 3 / Pin 5 of the GPIO 40 pins connector */
+		i2c@9540000 {
+			status = "okay";
+		};
 	};
 };
+
+&pwm1 {
+	pinctrl-0    = <&pinctrl_pwm1_chan0_default
+			&pinctrl_pwm1_chan1_default
+			&pinctrl_pwm1_chan3_default>;
+};
-- 
2.48.1

From f74048dd367144c2e3ef2704e8044a8ee01c93dd Mon Sep 17 00:00:00 2001
From: Jerome Audu <jerome.audu@st.com>
Date: Thu, 4 Mar 2021 22:13:51 +0100
Subject: [PATCH 22/72] dts: arm: stih418-b2264-box: enable SSD1306 OLED
 controller

---
 arch/arm/boot/dts/st/stih418-b2264-box.dts | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/arch/arm/boot/dts/st/stih418-b2264-box.dts b/arch/arm/boot/dts/st/stih418-b2264-box.dts
index 81d0b1c4238c..c87f518e745e 100644
--- a/arch/arm/boot/dts/st/stih418-b2264-box.dts
+++ b/arch/arm/boot/dts/st/stih418-b2264-box.dts
@@ -13,6 +13,17 @@ soc {
 		/* I2C available on Pin 3 / Pin 5 of the GPIO 40 pins connector */
 		i2c@9540000 {
 			status = "okay";
+			/* Define SSD1306 OLED controller based on ssd1307fb
+			 * and with I2C address 0x3c
+			 */
+			ssd1307: oled@3c {
+				compatible = "solomon,ssd1306fb-i2c";
+				reg = <0x3c>;
+				solomon,height = <64>;
+				solomon,width = <128>;
+				solomon,page-offset = <0>;
+				solomon,com-invdir;
+			};
 		};
 	};
 };
-- 
2.48.1

From 8ced1241c66dee5b3adfba5cfa909b00d9a7336d Mon Sep 17 00:00:00 2001
From: Jerome Audu <jerome.audu@st.com>
Date: Thu, 4 Mar 2021 22:24:09 +0100
Subject: [PATCH 23/72] dts: arm: stih418-b2264-box: front panel leds
 declaration

---
 arch/arm/boot/dts/st/stih418-b2264-box.dts | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/arch/arm/boot/dts/st/stih418-b2264-box.dts b/arch/arm/boot/dts/st/stih418-b2264-box.dts
index c87f518e745e..b756badabc15 100644
--- a/arch/arm/boot/dts/st/stih418-b2264-box.dts
+++ b/arch/arm/boot/dts/st/stih418-b2264-box.dts
@@ -25,6 +25,15 @@ ssd1307: oled@3c {
 				solomon,com-invdir;
 			};
 		};
+
+		leds {
+			compatible = "gpio-leds";
+			red {
+				label = "Front Panel LED";
+				gpios = <&pio4 1 GPIO_ACTIVE_HIGH>;
+				linux,default-trigger = "heartbeat";
+			};
+		};
 	};
 };
 
-- 
2.48.1

From 20a9a74a02f8e446d060870c601d49bb4aff4814 Mon Sep 17 00:00:00 2001
From: Jerome AUDU <jau@free.fr>
Date: Wed, 29 Sep 2021 17:08:06 +0200
Subject: [PATCH 28/72] cpufreq: sti: align to mainline requierement

Signed-off-by: Jerome AUDU <jau@free.fr>
---
 arch/arm/boot/dts/st/stih418-b2264.dts | 4 ----
 drivers/clocksource/Kconfig            | 1 +
 2 files changed, 1 insertion(+), 4 deletions(-)

diff --git a/arch/arm/boot/dts/st/stih418-b2264.dts b/arch/arm/boot/dts/st/stih418-b2264.dts
index 784acb465221..ae7af368e26d 100644
--- a/arch/arm/boot/dts/st/stih418-b2264.dts
+++ b/arch/arm/boot/dts/st/stih418-b2264.dts
@@ -62,10 +62,6 @@ opp03 {
 			opp-hz = /bits/ 64 <1200000000>;
 			opp-microvolt = <784000>;
 		};
-		opp04 {
-			opp-hz = /bits/ 64 <1500000000>;
-			opp-microvolt = <784000>;
-		};
 	};
 
 	aliases {
diff --git a/drivers/clocksource/Kconfig b/drivers/clocksource/Kconfig
index 487c85259967..ca4b95fcedf0 100644
--- a/drivers/clocksource/Kconfig
+++ b/drivers/clocksource/Kconfig
@@ -387,6 +387,7 @@ config ARM_GLOBAL_TIMER
 
 config ARM_GT_INITIAL_PRESCALER_VAL
 	int "ARM global timer initial prescaler value"
+	default 12 if ARCH_STI
 	default 2 if ARCH_ZYNQ
 	default 1
 	depends on ARM_GLOBAL_TIMER
-- 
2.48.1

From 2d54c5d17d664238f57af7a13fb8dc5ef1c26eaf Mon Sep 17 00:00:00 2001
From: Jerome Audu <jerome.audu@st.com>
Date: Fri, 10 Dec 2021 14:07:14 +0100
Subject: [PATCH 30/72] pci: dwc: pcie-st: enable module support

---
 drivers/pci/controller/dwc/Kconfig    | 2 +-
 drivers/pci/controller/dwc/pcie-sti.c | 7 ++++++-
 2 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/drivers/pci/controller/dwc/Kconfig b/drivers/pci/controller/dwc/Kconfig
index 150b19bdc792..e38c731c0cf5 100644
--- a/drivers/pci/controller/dwc/Kconfig
+++ b/drivers/pci/controller/dwc/Kconfig
@@ -460,7 +460,7 @@ config PCIE_VISCONTI_HOST
 	  This driver supports TMPV7708 SoC.
 
 config PCIE_STI
-	bool "STMicroelectronics PCIe Controller for STi SoCs"
+	tristate "STMicroelectronics PCIe Controller for STi SoCs"
 	depends on ARCH_STI || COMPILE_TEST
 	depends on OF && PCI_MSI
 	select PCIE_DW_HOST
diff --git a/drivers/pci/controller/dwc/pcie-sti.c b/drivers/pci/controller/dwc/pcie-sti.c
index a069ef110801..f6f49871a52e 100644
--- a/drivers/pci/controller/dwc/pcie-sti.c
+++ b/drivers/pci/controller/dwc/pcie-sti.c
@@ -368,6 +368,7 @@ static const struct of_device_id st_pcie_of_match[] = {
 	{ .compatible = "st,stih407-pcie", },
 	{ },
 };
+MODULE_DEVICE_TABLE(of, st_pcie_of_match);
 
 static struct platform_driver st_pcie_driver __refdata = {
 	.probe  = st_pcie_probe,
@@ -376,4 +377,8 @@ static struct platform_driver st_pcie_driver __refdata = {
 		.of_match_table = st_pcie_of_match,
 	},
 };
-builtin_platform_driver(st_pcie_driver);
+module_platform_driver(st_pcie_driver);
+
+MODULE_AUTHOR("Alain Volmat <avolmat@me.com>");
+MODULE_DESCRIPTION("STi PCIe Controller driver");
+MODULE_LICENSE("GPL v2");
-- 
2.48.1

From edf6d67f80067102d0804e78a1a75b70c1995f47 Mon Sep 17 00:00:00 2001
From: Jerome Audu <jerome.audu@st.com>
Date: Fri, 10 Dec 2021 16:02:17 +0100
Subject: [PATCH 31/72] pci: dwc: pcie-st: fix probe entry

__init can't be user with probe function since it call be call
several time due to -DEFERT. And __init keyword tells the linker to
place the code in a dedicated section into the kernel object file.
This section is known in advance to the kernel, and freed when
the module is loaded and the init function finished

https://www.oreilly.com/library/view/linux-device-drivers/9781785280009/e636c201-5e6f-4ddb-a4b3-9bd72f71b9b0.xhtml
---
 drivers/pci/controller/dwc/pcie-sti.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/pci/controller/dwc/pcie-sti.c b/drivers/pci/controller/dwc/pcie-sti.c
index f6f49871a52e..c54eda6d80c9 100644
--- a/drivers/pci/controller/dwc/pcie-sti.c
+++ b/drivers/pci/controller/dwc/pcie-sti.c
@@ -288,7 +288,7 @@ static const struct dw_pcie_ops dw_pcie_ops = {
 	.start_link = st_pcie_start_link,
 };
 
-static int __init st_pcie_probe(struct platform_device *pdev)
+static int st_pcie_probe(struct platform_device *pdev)
 {
 	struct st_pcie *pcie;
 	struct dw_pcie *dw;
-- 
2.48.1

From 4afdb8b2aaf21870d50fe1f6a10eba31658aff59 Mon Sep 17 00:00:00 2001
From: Jerome Audu <jerome.audu@st.com>
Date: Fri, 12 Jan 2024 15:01:48 +0100
Subject: [PATCH 32/72] pci: dwc: pcie-st: Drop host prefix from struct
 dw_pcie_host_ops members

Aligned with this commit:
    commit aea370b2aec9 ("PCI: dwc: Drop host prefix from struct dw_pcie_host_ops members")
---
 drivers/pci/controller/dwc/pcie-sti.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/drivers/pci/controller/dwc/pcie-sti.c b/drivers/pci/controller/dwc/pcie-sti.c
index c54eda6d80c9..39300e336c65 100644
--- a/drivers/pci/controller/dwc/pcie-sti.c
+++ b/drivers/pci/controller/dwc/pcie-sti.c
@@ -18,6 +18,7 @@
 #include <linux/of_pci.h>
 #include <linux/of_platform.h>
 #include <linux/phy/phy.h>
+#include <linux/platform_device.h>
 #include <linux/regmap.h>
 #include <linux/reset.h>
 
@@ -281,7 +282,7 @@ static int st_pcie_start_link(struct dw_pcie *dw)
 }
 
 static struct dw_pcie_host_ops st_pcie_host_ops = {
-	.host_init = st_pcie_host_init,
+	.init = st_pcie_host_init,
 };
 
 static const struct dw_pcie_ops dw_pcie_ops = {
@@ -290,9 +291,10 @@ static const struct dw_pcie_ops dw_pcie_ops = {
 
 static int st_pcie_probe(struct platform_device *pdev)
 {
+	struct device *dev = &pdev->dev;
 	struct st_pcie *pcie;
 	struct dw_pcie *dw;
-	struct device_node *np = pdev->dev.of_node;
+	struct device_node *np = dev->of_node;
 	struct dw_pcie_rp *pp;
 	int ret;
 
-- 
2.48.1

From ba6b7902d53fe0483a2b5cddba40c668696fca1c Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 28 Jul 2022 19:18:46 +0200
Subject: [PATCH 33/72] ARM: dts: sti: move sti-sasg-codec node outside of soc

Being placed as a child of the syscon-core node, the sti-sasg-codec
driver is not properly probed.  In order to fix this it has to be
moved outside of the syscon-core node but since it doesn't have
a reg property, it is now placed outside of the soc part to avoid
getting W=1 warnings.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/boot/dts/st/stih407-family.dtsi | 14 +++++++-------
 arch/arm/boot/dts/st/stihxxx-b2120.dtsi  | 14 ++++++--------
 2 files changed, 13 insertions(+), 15 deletions(-)

diff --git a/arch/arm/boot/dts/st/stih407-family.dtsi b/arch/arm/boot/dts/st/stih407-family.dtsi
index 6d5941a1101b..c1c0e964e515 100644
--- a/arch/arm/boot/dts/st/stih407-family.dtsi
+++ b/arch/arm/boot/dts/st/stih407-family.dtsi
@@ -234,6 +234,13 @@ st231_delta: st231-delta {
 		mboxes = <&mailbox0 0 0>, <&mailbox3 0 1>, <&mailbox0 0 1>, <&mailbox3 0 0>;
 	};
 
+	sti_sasg_codec: sti-sasg-codec {
+		compatible = "st,stih407-sas-codec";
+		#sound-dai-cells = <1>;
+		status = "disabled";
+		st,syscfg = <&syscfg_core>;
+	};
+
 	delta0 {
 		compatible = "st,st-delta";
 		clock-names = "delta",
@@ -279,13 +286,6 @@ syscfg_sbc_reg: fvdp-lite-syscfg@9600000 {
 		syscfg_core: core-syscfg@92b0000 {
 			compatible = "st,stih407-core-syscfg", "syscon";
 			reg = <0x92b0000 0x1000>;
-
-			sti_sasg_codec: sti-sasg-codec {
-				compatible = "st,stih407-sas-codec";
-				#sound-dai-cells = <1>;
-				status = "disabled";
-				st,syscfg = <&syscfg_core>;
-			};
 		};
 
 		syscfg_lpm: lpm-syscfg@94b5100 {
diff --git a/arch/arm/boot/dts/st/stihxxx-b2120.dtsi b/arch/arm/boot/dts/st/stihxxx-b2120.dtsi
index 8d9a2dfa76f1..aec49602421b 100644
--- a/arch/arm/boot/dts/st/stihxxx-b2120.dtsi
+++ b/arch/arm/boot/dts/st/stihxxx-b2120.dtsi
@@ -82,6 +82,12 @@ phy_port1: port@9b2a000 {
 		};
 	};
 
+	sti_sasg_codec: sti-sasg-codec {
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_spdif_out>;
+	};
+
 	soc {
 		sbc_serial0: serial@9530000 {
 			status = "okay";
@@ -194,13 +200,5 @@ sti_uni_player2: sti-uni-player@8d82000 {
 		sti_uni_player3: sti-uni-player@8d85000 {
 			status = "okay";
 		};
-
-		syscfg_core: core-syscfg@92b0000 {
-			sti_sasg_codec: sti-sasg-codec {
-				status = "okay";
-				pinctrl-names = "default";
-				pinctrl-0 = <&pinctrl_spdif_out>;
-			};
-		};
 	};
 };
-- 
2.48.1

From ce08afe667c83e8a60f4a6c09460059e8e30faeb Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 28 Jul 2022 19:20:57 +0200
Subject: [PATCH 34/72] ARM: dt: sti: enable analog audio output on
 stih418-b2264

The 4KOpen board (B2264) has an analog audio output available.
This commit enables it by relying on the sti-uni-player2 and
sti-sasg-codec.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/boot/dts/st/stih418-b2264.dts | 31 ++++++++++++++++++++++++++
 1 file changed, 31 insertions(+)

diff --git a/arch/arm/boot/dts/st/stih418-b2264.dts b/arch/arm/boot/dts/st/stih418-b2264.dts
index ae7af368e26d..95775a379974 100644
--- a/arch/arm/boot/dts/st/stih418-b2264.dts
+++ b/arch/arm/boot/dts/st/stih418-b2264.dts
@@ -69,6 +69,29 @@ aliases {
 		ethernet0 = &ethernet0;
 	};
 
+	sound: sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "STI-B2264";
+		status = "okay";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		simple-audio-card,dai-link@0 {
+			reg = <0>;
+			/* DAC */
+			format = "i2s";
+			mclk-fs = <256>;
+			frame-inversion;
+			cpu {
+				sound-dai = <&sti_uni_player2>;
+			};
+
+			codec {
+				sound-dai = <&sti_sasg_codec 1>;
+			};
+		};
+	};
+
 	leds {
 		compatible = "gpio-leds";
 		led-green {
@@ -180,3 +203,11 @@ partition@3 {
 &st_dwc3 {
 	status = "okay";
 };
+
+&sti_uni_player2 {
+	status = "okay";
+};
+
+&sti_sasg_codec {
+	status = "okay";
+};
-- 
2.48.1

From 73ee428a925e038c4eae195057321ea86fffbf37 Mon Sep 17 00:00:00 2001
From: Jerome AUDU <jau@free.fr>
Date: Fri, 2 Sep 2022 11:59:21 +0200
Subject: [PATCH 35/72] ARM: dts: sti: enable USB3 LPM on dwc3 controleur

Enable USB3 LPM support and also enable u1/u2 quirk
to keep gadget working with lpm

Signed-off-by: Jerome AUDU <jau@free.fr>
---
 arch/arm/boot/dts/st/stih407-family.dtsi | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/arch/arm/boot/dts/st/stih407-family.dtsi b/arch/arm/boot/dts/st/stih407-family.dtsi
index c1c0e964e515..c65e89358042 100644
--- a/arch/arm/boot/dts/st/stih407-family.dtsi
+++ b/arch/arm/boot/dts/st/stih407-family.dtsi
@@ -775,6 +775,9 @@ dwc3: usb@9900000 {
 				phys = <&usb2_picophy0>,
 				       <&phy_port2 PHY_TYPE_USB3>;
 				snps,dis_u3_susphy_quirk;
+				snps,usb3_lpm_capable;
+				snps,dis-u1-entry-quirk;
+				snps,dis-u2-entry-quirk;
 			};
 		};
 
-- 
2.48.1

From 2cc2cfd50a1fe47ed2a2b5f4e257495b98851a27 Mon Sep 17 00:00:00 2001
From: Jerome AUDU <jau@free.fr>
Date: Mon, 9 Jan 2023 15:01:58 +0100
Subject: [PATCH 36/72] usb: dwc3: st: Switch from CONFIG_PM_SLEEP guards to
 pm_sleep_ptr()

Letting the compiler remove these functions when the kernel is built
without CONFIG_PM_SLEEP support is simpler and less error prone than the
use of #ifdef based kernel configuration guards.

Link: https://lore.kernel.org/r/20220801114211.36267-6-andriy.shevchenko@linux.intel.com
Signed-off-by: Jerome AUDU <jau@free.fr>
---
 drivers/usb/dwc3/dwc3-st.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/drivers/usb/dwc3/dwc3-st.c b/drivers/usb/dwc3/dwc3-st.c
index e16c3237180e..ef7c43008946 100644
--- a/drivers/usb/dwc3/dwc3-st.c
+++ b/drivers/usb/dwc3/dwc3-st.c
@@ -309,7 +309,6 @@ static void st_dwc3_remove(struct platform_device *pdev)
 	reset_control_assert(dwc3_data->rstc_rst);
 }
 
-#ifdef CONFIG_PM_SLEEP
 static int st_dwc3_suspend(struct device *dev)
 {
 	struct st_dwc3 *dwc3_data = dev_get_drvdata(dev);
@@ -343,9 +342,8 @@ static int st_dwc3_resume(struct device *dev)
 
 	return 0;
 }
-#endif /* CONFIG_PM_SLEEP */
 
-static SIMPLE_DEV_PM_OPS(st_dwc3_dev_pm_ops, st_dwc3_suspend, st_dwc3_resume);
+static DEFINE_SIMPLE_DEV_PM_OPS(st_dwc3_dev_pm_ops, st_dwc3_suspend, st_dwc3_resume);
 
 static const struct of_device_id st_dwc3_match[] = {
 	{ .compatible = "st,stih407-dwc3" },
@@ -360,7 +358,7 @@ static struct platform_driver st_dwc3_driver = {
 	.driver = {
 		.name = "usb-st-dwc3",
 		.of_match_table = st_dwc3_match,
-		.pm = &st_dwc3_dev_pm_ops,
+		.pm = pm_sleep_ptr(&st_dwc3_dev_pm_ops),
 	},
 };
 
-- 
2.48.1

From f248acafbe7c676241fef71abbebb370fb2e4894 Mon Sep 17 00:00:00 2001
From: Jerome AUDU <jau@free.fr>
Date: Mon, 9 Jan 2023 15:11:43 +0100
Subject: [PATCH 37/72] mmc: sdhci-st: Switch from CONFIG_PM_SLEEP guards to
 pm_sleep_ptr()

Letting the compiler remove these functions when the kernel is built
without CONFIG_PM_SLEEP support is simpler and less error prone than the
use of #ifdef based kernel configuration guards.

Link: https://lore.kernel.org/r/20220801114211.36267-6-andriy.shevchenko@linux.intel.com
Signed-off-by: Jerome AUDU <jau@free.fr>
---
 drivers/mmc/host/sdhci-st.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/drivers/mmc/host/sdhci-st.c b/drivers/mmc/host/sdhci-st.c
index 4973e08a98f8..901e431976ce 100644
--- a/drivers/mmc/host/sdhci-st.c
+++ b/drivers/mmc/host/sdhci-st.c
@@ -447,7 +447,6 @@ static void sdhci_st_remove(struct platform_device *pdev)
 	reset_control_assert(rstc);
 }
 
-#ifdef CONFIG_PM_SLEEP
 static int sdhci_st_suspend(struct device *dev)
 {
 	struct sdhci_host *host = dev_get_drvdata(dev);
@@ -494,9 +493,8 @@ static int sdhci_st_resume(struct device *dev)
 
 	return sdhci_resume_host(host);
 }
-#endif
 
-static SIMPLE_DEV_PM_OPS(sdhci_st_pmops, sdhci_st_suspend, sdhci_st_resume);
+static DEFINE_SIMPLE_DEV_PM_OPS(sdhci_st_pmops, sdhci_st_suspend, sdhci_st_resume);
 
 static const struct of_device_id st_sdhci_match[] = {
 	{ .compatible = "st,sdhci" },
@@ -511,7 +509,7 @@ static struct platform_driver sdhci_st_driver = {
 	.driver = {
 		   .name = "sdhci-st",
 		   .probe_type = PROBE_PREFER_ASYNCHRONOUS,
-		   .pm = &sdhci_st_pmops,
+		   .pm = pm_sleep_ptr(&sdhci_st_pmops),
 		   .of_match_table = st_sdhci_match,
 		  },
 };
-- 
2.48.1

From ef191cdfd147644fe2214c634dde033fb8bf88ad Mon Sep 17 00:00:00 2001
From: Jerome AUDU <jau@free.fr>
Date: Mon, 9 Jan 2023 15:16:59 +0100
Subject: [PATCH 38/72] mtd: st_spi_fsm: Switch from CONFIG_PM_SLEEP guards to
 pm_sleep_ptr()

Letting the compiler remove these functions when the kernel is built
without CONFIG_PM_SLEEP support is simpler and less error prone than the
use of #ifdef based kernel configuration guards.

Link: https://lore.kernel.org/r/20220801114211.36267-6-andriy.shevchenko@linux.intel.com
Signed-off-by: Jerome AUDU <jau@free.fr>
---
 drivers/mtd/devices/st_spi_fsm.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/drivers/mtd/devices/st_spi_fsm.c b/drivers/mtd/devices/st_spi_fsm.c
index adf8eeb03a35..98bf98ed0b97 100644
--- a/drivers/mtd/devices/st_spi_fsm.c
+++ b/drivers/mtd/devices/st_spi_fsm.c
@@ -2106,7 +2106,6 @@ static void stfsm_remove(struct platform_device *pdev)
 	WARN_ON(mtd_device_unregister(&fsm->mtd));
 }
 
-#ifdef CONFIG_PM_SLEEP
 static int stfsmfsm_suspend(struct device *dev)
 {
 	struct stfsm *fsm = dev_get_drvdata(dev);
@@ -2122,9 +2121,8 @@ static int stfsmfsm_resume(struct device *dev)
 
 	return clk_prepare_enable(fsm->clk);
 }
-#endif
 
-static SIMPLE_DEV_PM_OPS(stfsm_pm_ops, stfsmfsm_suspend, stfsmfsm_resume);
+static DEFINE_SIMPLE_DEV_PM_OPS(stfsm_pm_ops, stfsmfsm_suspend, stfsmfsm_resume);
 
 static const struct of_device_id stfsm_match[] = {
 	{ .compatible = "st,spi-fsm", },
@@ -2138,7 +2136,7 @@ static struct platform_driver stfsm_driver = {
 	.driver		= {
 		.name	= "st-spi-fsm",
 		.of_match_table = stfsm_match,
-		.pm     = &stfsm_pm_ops,
+		.pm     = pm_sleep_ptr(&stfsm_pm_ops),
 	},
 };
 module_platform_driver(stfsm_driver);
-- 
2.48.1

From 222be853c1d825fa71e981612115d64e4e6b35ee Mon Sep 17 00:00:00 2001
From: Jerome AUDU <jau@free.fr>
Date: Mon, 9 Jan 2023 15:21:59 +0100
Subject: [PATCH 39/72] ahci: st: Switch from CONFIG_PM_SLEEP guards to
 pm_sleep_ptr()

Letting the compiler remove these functions when the kernel is built
without CONFIG_PM_SLEEP support is simpler and less error prone than the
use of #ifdef based kernel configuration guards.

Link: https://lore.kernel.org/r/20220801114211.36267-6-andriy.shevchenko@linux.intel.com
Signed-off-by: Jerome AUDU <jau@free.fr>
---
 drivers/ata/ahci_st.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/drivers/ata/ahci_st.c b/drivers/ata/ahci_st.c
index 6b9b4a1dfa15..4336c8a6e208 100644
--- a/drivers/ata/ahci_st.c
+++ b/drivers/ata/ahci_st.c
@@ -176,7 +176,6 @@ static int st_ahci_probe(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM_SLEEP
 static int st_ahci_suspend(struct device *dev)
 {
 	struct ata_host *host = dev_get_drvdata(dev);
@@ -221,9 +220,8 @@ static int st_ahci_resume(struct device *dev)
 
 	return ahci_platform_resume_host(dev);
 }
-#endif
 
-static SIMPLE_DEV_PM_OPS(st_ahci_pm_ops, st_ahci_suspend, st_ahci_resume);
+static DEFINE_SIMPLE_DEV_PM_OPS(st_ahci_pm_ops, st_ahci_suspend, st_ahci_resume);
 
 static const struct of_device_id st_ahci_match[] = {
 	{ .compatible = "st,ahci", },
@@ -234,7 +232,7 @@ MODULE_DEVICE_TABLE(of, st_ahci_match);
 static struct platform_driver st_ahci_driver = {
 	.driver = {
 		.name = DRV_NAME,
-		.pm = &st_ahci_pm_ops,
+		.pm = pm_sleep_ptr(&st_ahci_pm_ops),
 		.of_match_table = st_ahci_match,
 	},
 	.probe = st_ahci_probe,
-- 
2.48.1

From 7a6dd0cd9ee1a65a8019eb7b203464d5779b9ce2 Mon Sep 17 00:00:00 2001
From: Jerome AUDU <jau@free.fr>
Date: Mon, 9 Jan 2023 15:26:13 +0100
Subject: [PATCH 40/72] net: stmmac: sti: Switch from CONFIG_PM_SLEEP guards to
 pm_sleep_ptr()

Letting the compiler remove these functions when the kernel is built
without CONFIG_PM_SLEEP support is simpler and less error prone than the
use of #ifdef based kernel configuration guards.

Link: https://lore.kernel.org/r/20220801114211.36267-6-andriy.shevchenko@linux.intel.com
Signed-off-by: Jerome AUDU <jau@free.fr>
---
 drivers/net/ethernet/stmicro/stmmac/dwmac-sti.c | 8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-sti.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-sti.c
index a6ff02d905a9..21ad4fc9163a 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-sti.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-sti.c
@@ -321,7 +321,6 @@ static void sti_dwmac_remove(struct platform_device *pdev)
 	clk_disable_unprepare(dwmac->clk);
 }
 
-#ifdef CONFIG_PM_SLEEP
 static int sti_dwmac_suspend(struct device *dev)
 {
 	struct sti_dwmac *dwmac = get_stmmac_bsp_priv(dev);
@@ -341,10 +340,9 @@ static int sti_dwmac_resume(struct device *dev)
 
 	return stmmac_resume(dev);
 }
-#endif /* CONFIG_PM_SLEEP */
 
-static SIMPLE_DEV_PM_OPS(sti_dwmac_pm_ops, sti_dwmac_suspend,
-					   sti_dwmac_resume);
+static DEFINE_SIMPLE_DEV_PM_OPS(sti_dwmac_pm_ops, sti_dwmac_suspend,
+						  sti_dwmac_resume);
 
 static const struct sti_dwmac_of_data stih4xx_dwmac_data = {
 	.fix_retime_src = stih4xx_fix_retime_src,
@@ -361,7 +359,7 @@ static struct platform_driver sti_dwmac_driver = {
 	.remove = sti_dwmac_remove,
 	.driver = {
 		.name           = "sti-dwmac",
-		.pm		= &sti_dwmac_pm_ops,
+		.pm		= pm_sleep_ptr(&sti_dwmac_pm_ops),
 		.of_match_table = sti_dwmac_match,
 	},
 };
-- 
2.48.1

From 9a88a742625b20e323e048700fd6eb7bb76e258f Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Tue, 17 Jan 2023 22:48:30 +0100
Subject: [PATCH 41/72] spi: st: replace ifdef CONFIG_PM with pm_sleep_ptr
 usage

Avoid ifdef CONFIG_PM and ifdef CONFIG_PM_SLEEP sections with
the code and rely on pm_sleep_ptr to set pm ops.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/spi/spi-st-ssc4.c | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/drivers/spi/spi-st-ssc4.c b/drivers/spi/spi-st-ssc4.c
index 4cff976ab16f..5cc452447410 100644
--- a/drivers/spi/spi-st-ssc4.c
+++ b/drivers/spi/spi-st-ssc4.c
@@ -378,7 +378,6 @@ static void spi_st_remove(struct platform_device *pdev)
 	pinctrl_pm_select_sleep_state(&pdev->dev);
 }
 
-#ifdef CONFIG_PM
 static int spi_st_runtime_suspend(struct device *dev)
 {
 	struct spi_controller *host = dev_get_drvdata(dev);
@@ -403,9 +402,7 @@ static int spi_st_runtime_resume(struct device *dev)
 
 	return ret;
 }
-#endif
 
-#ifdef CONFIG_PM_SLEEP
 static int spi_st_suspend(struct device *dev)
 {
 	struct spi_controller *host = dev_get_drvdata(dev);
@@ -429,7 +426,6 @@ static int spi_st_resume(struct device *dev)
 
 	return pm_runtime_force_resume(dev);
 }
-#endif
 
 static const struct dev_pm_ops spi_st_pm = {
 	SET_SYSTEM_SLEEP_PM_OPS(spi_st_suspend, spi_st_resume)
@@ -445,7 +441,7 @@ MODULE_DEVICE_TABLE(of, stm_spi_match);
 static struct platform_driver spi_st_driver = {
 	.driver = {
 		.name = "spi-st",
-		.pm = &spi_st_pm,
+		.pm = pm_sleep_ptr(&spi_st_pm),
 		.of_match_table = of_match_ptr(stm_spi_match),
 	},
 	.probe = spi_st_probe,
-- 
2.48.1

From 8e8ba4d42d8e18b02d0e005598c93cd940a43c60 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Tue, 17 Jan 2023 22:50:11 +0100
Subject: [PATCH 42/72] spi: st: does not mandate chip select gpio

The spi controller itself does not mandate to have a proper
chip select defined so no need to enforce a valid cs_gpio.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/spi/spi-st-ssc4.c | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/drivers/spi/spi-st-ssc4.c b/drivers/spi/spi-st-ssc4.c
index 5cc452447410..0c5a6919c347 100644
--- a/drivers/spi/spi-st-ssc4.c
+++ b/drivers/spi/spi-st-ssc4.c
@@ -183,11 +183,6 @@ static int spi_st_setup(struct spi_device *spi)
 		return -EINVAL;
 	}
 
-	if (!spi_get_csgpiod(spi, 0)) {
-		dev_err(&spi->dev, "no valid gpio assigned\n");
-		return -EINVAL;
-	}
-
 	spi_st_clk = clk_get_rate(spi_st->clk);
 
 	/* Set SSC_BRF */
-- 
2.48.1

From 46dcb9755ea9dc715281ea89e6f1dbc1963334dc Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Mon, 23 Jan 2023 21:08:54 +0100
Subject: [PATCH 43/72] ARM: sti: removal of stih415/stih416 related entries

ST's STiH415 and STiH416 platforms have already been removed since
a while.  Remove some remaining bits within the mach-sti.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/mach-sti/board-dt.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/arch/arm/mach-sti/board-dt.c b/arch/arm/mach-sti/board-dt.c
index 488084b61b4a..1aaf61184685 100644
--- a/arch/arm/mach-sti/board-dt.c
+++ b/arch/arm/mach-sti/board-dt.c
@@ -10,8 +10,6 @@
 #include "smp.h"
 
 static const char *const stih41x_dt_match[] __initconst = {
-	"st,stih415",
-	"st,stih416",
 	"st,stih407",
 	"st,stih410",
 	"st,stih418",
-- 
2.48.1

From 39976d5cf7d89110def4bb05a91183867e4e9465 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Tue, 24 Jan 2023 21:11:13 +0100
Subject: [PATCH 44/72] fixup! ARM: sti: removal of stih415/stih416 related
 entries

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/mach-sti/Kconfig | 20 +-------------------
 1 file changed, 1 insertion(+), 19 deletions(-)

diff --git a/arch/arm/mach-sti/Kconfig b/arch/arm/mach-sti/Kconfig
index b3842c971d31..e58699e13e1a 100644
--- a/arch/arm/mach-sti/Kconfig
+++ b/arch/arm/mach-sti/Kconfig
@@ -19,31 +19,13 @@ menuconfig ARCH_STI
 	select PL310_ERRATA_769419 if CACHE_L2X0
 	select RESET_CONTROLLER
 	help
-	  Include support for STMicroelectronics' STiH415/416, STiH407/10 and
+	  Include support for STMicroelectronics' STiH407/10 and
 	  STiH418 family SoCs using the Device Tree for discovery.  More
 	  information can be found in Documentation/arch/arm/sti/ and
 	  Documentation/devicetree.
 
 if ARCH_STI
 
-config SOC_STIH415
-	bool "STiH415 STMicroelectronics Consumer Electronics family"
-	default y
-	help
-	  This enables support for STMicroelectronics Digital Consumer
-	  Electronics family StiH415 parts, primarily targeted at set-top-box
-	  and other digital audio/video applications using Flattned Device
-	  Trees.
-
-config SOC_STIH416
-	bool "STiH416 STMicroelectronics Consumer Electronics family"
-	default y
-	help
-	  This enables support for STMicroelectronics Digital Consumer
-	  Electronics family StiH416 parts, primarily targeted at set-top-box
-	  and other digital audio/video applications using Flattened Device
-	  Trees.
-
 config SOC_STIH407
 	bool "STiH407 STMicroelectronics Consumer Electronics family"
 	default y
-- 
2.48.1

From 03b42f58ca2f0f262d90b0143e8ac64bfadfbe47 Mon Sep 17 00:00:00 2001
From: Jerome AUDU <jau@free.fr>
Date: Fri, 14 Apr 2023 21:32:05 +0200
Subject: [PATCH 45/72] rtlwifi: add protection before calling
 {enable|disable}_interrupt()

Detected on pcie/rtl8192ce embedded armv7/arm64 plaform
Call to {enable|disable}_interrupt() seem not enought protected,
so, add extra protection to avoid collision

    Without this patch (randomly)
    [  184.243426] rcu: INFO: rcu_sched self-detected stall on CPU
    [  184.249008] rcu:     0-....: (8405 ticks this GP) idle=df74/1/0x40000002 softirq=3607/3607 fqs=2972
    [  184.257790]  (t=8407 jiffies g=6613 q=56899 ncpus=4)
    [  184.257803] CPU: 0 PID: 1059 Comm: ifconfig Not tainted 6.2.7 #3
    [  184.257813] Hardware name: STi SoC with Flattened Device Tree
    [  184.257818] PC is at pci_read32_sync+0x10/0x14 [rtl_pci]
    [  184.257860] LR is at rtl92ce_enable_interrupt+0x4c/0x8c [rtl8192ce]
    [  184.257921] pc : [<bf46d03c>]    lr : [<bf478e44>]    psr: 20060013
    [  184.257928] sp : f1375ce0  ip : bf451b34  fp : c14f3c00
    [  184.257933] r10: c2c4b780  r9 : c28f4000  r8 : c15b18bc
    [  184.257938] r7 : 00000000  r6 : c15bd880  r5 : c15bc880  r4 : c15b1880
    [  184.257944] r3 : f09e8000  r2 : 00000730  r1 : f09e8120  r0 : 00001b5f
    [  184.257950] Flags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none
    [  184.257959] Control: 10c5387d  Table: 86c0804a  DAC: 00000051
    [  184.257970]  pci_read32_sync [rtl_pci] from rtl92ce_enable_interrupt+0x4c/0x8c [rtl8192ce]
    [  184.258018]  rtl92ce_enable_interrupt [rtl8192ce] from rtl_pci_start+0xbc/0x18c [rtl_pci]
    [  184.258059]  rtl_pci_start [rtl_pci] from rtl_op_start+0x58/0x7c [rtlwifi]
    [  184.258269]  rtl_op_start [rtlwifi] from drv_start+0x4c/0x10c [mac80211]
    [  184.259512]  drv_start [mac80211] from ieee80211_do_open+0x370/0x6d8 [mac80211]
    [  184.260444]  ieee80211_do_open [mac80211] from ieee80211_open+0x60/0x84 [mac80211]
    [  184.261374]  ieee80211_open [mac80211] from __dev_open+0xfc/0x1d0
    [  184.261860]  __dev_open from __dev_change_flags+0x190/0x214
    [  184.261878]  __dev_change_flags from dev_change_flags+0x20/0x5c
    [  184.261894]  dev_change_flags from devinet_ioctl+0x7a8/0x7dc
    [  184.261918]  devinet_ioctl from inet_ioctl+0x1a4/0x244
    [  184.261937]  inet_ioctl from sock_ioctl+0x4dc/0x5b8
    [  184.261962]  sock_ioctl from sys_ioctl+0x510/0xbd8
    [  184.261985]  sys_ioctl from ret_fast_syscall+0x0/0x1c

this can be reproduced using NetworkManager
or with this simple script: (~1-2min to deadlock)
$ while : ; do ifconfig wlan0 up; ifconfig wlan0 done; echo -n "."; done'

Signed-off-by: Jerome AUDU <jau@free.fr>
---
 drivers/net/wireless/realtek/rtlwifi/core.c | 18 +++++++++++++++++-
 drivers/net/wireless/realtek/rtlwifi/pci.c  |  5 +++++
 drivers/net/wireless/realtek/rtlwifi/ps.c   |  3 +++
 3 files changed, 25 insertions(+), 1 deletion(-)

diff --git a/drivers/net/wireless/realtek/rtlwifi/core.c b/drivers/net/wireless/realtek/rtlwifi/core.c
index 7537f04b1930..16165f330924 100644
--- a/drivers/net/wireless/realtek/rtlwifi/core.c
+++ b/drivers/net/wireless/realtek/rtlwifi/core.c
@@ -212,6 +212,7 @@ static int rtl_op_add_interface(struct ieee80211_hw *hw,
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	unsigned long flags;
 	int err = 0;
 	u8 retry_limit = 0x30;
 
@@ -235,8 +236,10 @@ static int rtl_op_add_interface(struct ieee80211_hw *hw,
 			rtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,
 				"NL80211_IFTYPE_STATION\n");
 			mac->beacon_enabled = 0;
+			spin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);
 			rtlpriv->cfg->ops->update_interrupt_mask(hw, 0,
 					rtlpriv->cfg->maps[RTL_IBSS_INT_MASKS]);
+			spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
 		}
 		break;
 	case NL80211_IFTYPE_ADHOC:
@@ -244,7 +247,9 @@ static int rtl_op_add_interface(struct ieee80211_hw *hw,
 			"NL80211_IFTYPE_ADHOC\n");
 
 		mac->link_state = MAC80211_LINKED;
+		spin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);
 		rtlpriv->cfg->ops->set_bcn_reg(hw);
+		spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
 		if (rtlpriv->rtlhal.current_bandtype == BAND_ON_2_4G)
 			mac->basic_rates = 0xfff;
 		else
@@ -262,7 +267,9 @@ static int rtl_op_add_interface(struct ieee80211_hw *hw,
 			"NL80211_IFTYPE_AP\n");
 
 		mac->link_state = MAC80211_LINKED;
+		spin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);
 		rtlpriv->cfg->ops->set_bcn_reg(hw);
+		spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
 		if (rtlpriv->rtlhal.current_bandtype == BAND_ON_2_4G)
 			mac->basic_rates = 0xfff;
 		else
@@ -321,6 +328,7 @@ static void rtl_op_remove_interface(struct ieee80211_hw *hw,
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	unsigned long flags;
 
 	mutex_lock(&rtlpriv->locks.conf_mutex);
 
@@ -330,8 +338,10 @@ static void rtl_op_remove_interface(struct ieee80211_hw *hw,
 	    vif->type == NL80211_IFTYPE_MESH_POINT) {
 		if (mac->beacon_enabled == 1) {
 			mac->beacon_enabled = 0;
+			spin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);
 			rtlpriv->cfg->ops->update_interrupt_mask(hw, 0,
 					rtlpriv->cfg->maps[RTL_IBSS_INT_MASKS]);
+			spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
 		}
 	}
 
@@ -1025,6 +1035,7 @@ static void rtl_op_bss_info_changed(struct ieee80211_hw *hw,
 	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
 	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
 	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	unsigned long flags;
 
 	mutex_lock(&rtlpriv->locks.conf_mutex);
 	if (vif->type == NL80211_IFTYPE_ADHOC ||
@@ -1040,10 +1051,11 @@ static void rtl_op_bss_info_changed(struct ieee80211_hw *hw,
 				/*start hw beacon interrupt. */
 				/*rtlpriv->cfg->ops->set_bcn_reg(hw); */
 				mac->beacon_enabled = 1;
+				spin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);
 				rtlpriv->cfg->ops->update_interrupt_mask(hw,
 						rtlpriv->cfg->maps
 						[RTL_IBSS_INT_MASKS], 0);
-
+				spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
 				if (rtlpriv->cfg->ops->linked_set_reg)
 					rtlpriv->cfg->ops->linked_set_reg(hw);
 				send_beacon_frame(hw, vif);
@@ -1056,16 +1068,20 @@ static void rtl_op_bss_info_changed(struct ieee80211_hw *hw,
 					"ADHOC DISABLE BEACON\n");
 
 				mac->beacon_enabled = 0;
+				spin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);
 				rtlpriv->cfg->ops->update_interrupt_mask(hw, 0,
 						rtlpriv->cfg->maps
 						[RTL_IBSS_INT_MASKS]);
+				spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
 			}
 		}
 		if (changed & BSS_CHANGED_BEACON_INT) {
 			rtl_dbg(rtlpriv, COMP_BEACON, DBG_TRACE,
 				"BSS_CHANGED_BEACON_INT\n");
 			mac->beacon_interval = bss_conf->beacon_int;
+			spin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);
 			rtlpriv->cfg->ops->set_bcn_intv(hw);
+			spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
 		}
 	}
 
diff --git a/drivers/net/wireless/realtek/rtlwifi/pci.c b/drivers/net/wireless/realtek/rtlwifi/pci.c
index 0eafc4d125f9..7406e6b62b28 100644
--- a/drivers/net/wireless/realtek/rtlwifi/pci.c
+++ b/drivers/net/wireless/realtek/rtlwifi/pci.c
@@ -1681,6 +1681,7 @@ static int rtl_pci_start(struct ieee80211_hw *hw)
 	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
 	struct rtl_mac *rtlmac = rtl_mac(rtl_priv(hw));
 	struct rtl_btc_ops *btc_ops = rtlpriv->btcoexist.btc_ops;
+	unsigned long flags;
 
 	int err;
 
@@ -1707,7 +1708,9 @@ static int rtl_pci_start(struct ieee80211_hw *hw)
 	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RETRY_LIMIT,
 			&rtlmac->retry_long);
 
+	spin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);
 	rtlpriv->cfg->ops->enable_interrupt(hw);
+	spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
 	rtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, "enable_interrupt OK\n");
 
 	rtl_init_rx_config(hw);
@@ -1744,7 +1747,9 @@ static void rtl_pci_stop(struct ieee80211_hw *hw)
 	set_hal_stop(rtlhal);
 
 	rtlpci->driver_is_goingto_unload = true;
+	spin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);
 	rtlpriv->cfg->ops->disable_interrupt(hw);
+	spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
 	cancel_work_sync(&rtlpriv->works.lps_change_work);
 
 	spin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flags);
diff --git a/drivers/net/wireless/realtek/rtlwifi/ps.c b/drivers/net/wireless/realtek/rtlwifi/ps.c
index 6241e4fed4f6..f781e4a3ab5d 100644
--- a/drivers/net/wireless/realtek/rtlwifi/ps.c
+++ b/drivers/net/wireless/realtek/rtlwifi/ps.c
@@ -13,6 +13,7 @@ bool rtl_ps_enable_nic(struct ieee80211_hw *hw)
 	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
 	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
 	struct rtl_mac *rtlmac = rtl_mac(rtl_priv(hw));
+        unsigned long flags;
 
 	/*<1> reset trx ring */
 	if (rtlhal->interface == INTF_PCI)
@@ -35,7 +36,9 @@ bool rtl_ps_enable_nic(struct ieee80211_hw *hw)
 			cfg80211_get_chandef_type(&hw->conf.chandef));
 
 	/*<3> Enable Interrupt */
+        spin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);
 	rtlpriv->cfg->ops->enable_interrupt(hw);
+        spin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);
 
 	/*<enable timer> */
 	rtl_watch_dog_timer_callback(&rtlpriv->works.watchdog_timer);
-- 
2.48.1

From 7a0dacf8e0b1c1f5bbd48e15bb254c592a2c8cbd Mon Sep 17 00:00:00 2001
From: Jerome Audu <jau@free.fr>
Date: Mon, 24 Jul 2023 13:46:47 +0200
Subject: [PATCH 46/72] ARM: dts: stih418-b2264: enable uart1

---
 arch/arm/boot/dts/st/stih407-family.dtsi | 2 +-
 arch/arm/boot/dts/st/stih418-b2264.dts   | 5 +++++
 2 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/arch/arm/boot/dts/st/stih407-family.dtsi b/arch/arm/boot/dts/st/stih407-family.dtsi
index c65e89358042..478415ad2103 100644
--- a/arch/arm/boot/dts/st/stih407-family.dtsi
+++ b/arch/arm/boot/dts/st/stih407-family.dtsi
@@ -350,7 +350,7 @@ sbc_serial0: serial@9530000 {
 			status = "disabled";
 		};
 
-		serial@9531000 {
+		sbc_serial1: serial@9531000 {
 			compatible = "st,asc";
 			reg = <0x9531000 0x2c>;
 			interrupts = <GIC_SPI 139 IRQ_TYPE_LEVEL_HIGH>;
diff --git a/arch/arm/boot/dts/st/stih418-b2264.dts b/arch/arm/boot/dts/st/stih418-b2264.dts
index 95775a379974..a15f4572ba14 100644
--- a/arch/arm/boot/dts/st/stih418-b2264.dts
+++ b/arch/arm/boot/dts/st/stih418-b2264.dts
@@ -66,6 +66,7 @@ opp03 {
 
 	aliases {
 		serial0 = &sbc_serial0;
+		serial1 = &sbc_serial1;
 		ethernet0 = &ethernet0;
 	};
 
@@ -169,6 +170,10 @@ &sbc_serial0 {
 	status = "okay";
 };
 
+&sbc_serial1 {
+	status = "okay";
+};
+
 &spifsm {
 	status = "okay";
 	partitions {
-- 
2.48.1

From 88aeefcc4640b490c897d9004e0aec7f67e2f760 Mon Sep 17 00:00:00 2001
From: Jerome Audu <jau@free.fr>
Date: Wed, 10 May 2023 21:19:36 +0200
Subject: [PATCH 47/72] drivers: regulator: add vsense voltage regulator driver

This is the voltage regulator driver to manage the vsense inside the ST flash
sub-system that is used for configuring MMC, NAND, SPI voltages.

Signed-off-by: JGiuseppe Cavallaro <peppe.cavallaro@st.com>
---
 .../bindings/regulator/st-flashss.txt         |  24 ++
 drivers/regulator/Kconfig                     |   8 +
 drivers/regulator/Makefile                    |   1 +
 drivers/regulator/st-flashss.c                | 251 ++++++++++++++++++
 4 files changed, 284 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/regulator/st-flashss.txt
 create mode 100644 drivers/regulator/st-flashss.c

diff --git a/Documentation/devicetree/bindings/regulator/st-flashss.txt b/Documentation/devicetree/bindings/regulator/st-flashss.txt
new file mode 100644
index 000000000000..6bb622d04c90
--- /dev/null
+++ b/Documentation/devicetree/bindings/regulator/st-flashss.txt
@@ -0,0 +1,24 @@
+ST Voltage regulator for FlashSS vsense
+
+This is the voltage regulator driver to manage the vsense inside the ST flash
+sub-system that is used for configuring MMC, NAND, SPI voltages.
+
+Required properties:
+- compatible: can be "st,vmmc", "st,vnand" or "st,vspi" because it is shared
+  among these devices inside the ST FlashSS. Currently it is only tested on
+  MMC.
+
+Required properties:
+- regulator-name: regulator name.
+- reg: is the vsense top config base address in the flashSS hardware.
+
+Any property defined as part of the core regulator
+binding, defined in regulator.txt, can also be used.
+
+Example:
+
+vmmc_reg: voltage-regulator {
+	compatible = "st,vmmc";
+	regulator-name = "vmmc0";
+	reg = <0x9061004 0x4>;
+};
diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index 39297f7d8177..2b9410b3338b 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -1373,6 +1373,14 @@ config REGULATOR_SLG51000
 	  The SLG51000 is seven compact and customizable low dropout
 	  regulators.
 
+config REGULATOR_ST_FLASHSS
+	tristate "STMicroelectronics FlashSS regulator"
+	depends on ARCH_STI && OF
+	help
+	  This driver provides support for the voltage regulators available
+	  inside the FlashSS embedded in some ST SoCs:
+	  e.g. STiH407/STiH410/STiH418 and STi8416.
+
 config REGULATOR_STM32_BOOSTER
 	tristate "STMicroelectronics STM32 BOOSTER"
 	depends on ARCH_STM32 || COMPILE_TEST
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index 3d5a803dce8a..376e6199ec77 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -160,6 +160,7 @@ obj-$(CONFIG_REGULATOR_S5M8767) += s5m8767.o
 obj-$(CONFIG_REGULATOR_SC2731) += sc2731-regulator.o
 obj-$(CONFIG_REGULATOR_SKY81452) += sky81452-regulator.o
 obj-$(CONFIG_REGULATOR_SLG51000) += slg51000-regulator.o
+obj-$(CONFIG_REGULATOR_ST_FLASHSS) += st-flashss.o
 obj-$(CONFIG_REGULATOR_STM32_BOOSTER) += stm32-booster.o
 obj-$(CONFIG_REGULATOR_STM32_VREFBUF) += stm32-vrefbuf.o
 obj-$(CONFIG_REGULATOR_STM32_PWR) += stm32-pwr.o
diff --git a/drivers/regulator/st-flashss.c b/drivers/regulator/st-flashss.c
new file mode 100644
index 000000000000..7f193fc1f4d2
--- /dev/null
+++ b/drivers/regulator/st-flashss.c
@@ -0,0 +1,251 @@
+/*
+ * ST regulator driver for flashSS vsense
+ *
+ * This is a small driver to manage the voltage regulator inside the ST flash
+ * sub-system that is used for configuring MMC, NAND, SPI voltages.
+ *
+ * Copyright(C) 2014 STMicroelectronics Ltd
+ * Author: Giuseppe Cavallaro <peppe.cavallaro@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under  the terms of the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the License, or (at your
+ * option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/of_regulator.h>
+
+/* FlashSS voltage VSENSE TOP CONFIG register defines */
+#define TOP_VSENSE_CONFIG_REG_PSW_EMMC		BIT(0)
+#define TOP_VSENSE_CONFIG_ENB_REG_PSW_EMMC	BIT(1)
+#define TOP_VSENSE_CONFIG_REG_PSW_NAND		BIT(8)
+#define TOP_VSENSE_CONFIG_ENB_REG_PSW_NAND	BIT(9)
+#define TOP_VSENSE_CONFIG_REG_PSW_SPI		BIT(16)
+#define TOP_VSENSE_CONFIG_ENB_REG_PSW_SPI	BIT(17)
+#define TOP_VSENSE_CONFIG_LATCHED_PSW_EMMC	BIT(24)
+#define TOP_VSENSE_CONFIG_LATCHED_PSW_NAND	BIT(25)
+#define TOP_VSENSE_CONFIG_LATCHED_PSW_SPI	BIT(26)
+
+struct st_vsense {
+	char *name;
+	struct device *dev;
+	u8 n_voltages;			/* number of supported voltages */
+	void __iomem *ioaddr;		/* TOP config base address */
+	unsigned int en_psw_mask;	/* Mask/enable vdd for each device */
+	unsigned int psw_mask;		/* Power sel mask for VDD */
+	unsigned int latched_mask;	/* Latched mask for VDD */
+};
+
+static const unsigned int st_type_voltages[] = {
+	1800000,
+	3300000,
+};
+
+const struct st_vsense st_vsense_data[] = {
+	{
+		.en_psw_mask = TOP_VSENSE_CONFIG_ENB_REG_PSW_EMMC,
+		.psw_mask = TOP_VSENSE_CONFIG_REG_PSW_EMMC,
+		.latched_mask = TOP_VSENSE_CONFIG_LATCHED_PSW_EMMC,
+	}, {
+		.en_psw_mask = TOP_VSENSE_CONFIG_ENB_REG_PSW_NAND,
+		.psw_mask = TOP_VSENSE_CONFIG_REG_PSW_NAND,
+		.latched_mask = TOP_VSENSE_CONFIG_LATCHED_PSW_NAND,
+	}, {
+		.en_psw_mask = TOP_VSENSE_CONFIG_ENB_REG_PSW_SPI,
+		.psw_mask = TOP_VSENSE_CONFIG_REG_PSW_SPI,
+		.latched_mask = TOP_VSENSE_CONFIG_LATCHED_PSW_SPI,
+	},
+};
+
+/* Get the value of Sensed-PSW of eMMC/NAND/SPI Pads */
+static int st_get_voltage_sel(struct regulator_dev *dev)
+{
+	struct st_vsense *vsense = rdev_get_drvdata(dev);
+	void __iomem *ioaddr = vsense->ioaddr;
+	int sel = 0;
+	u32 value = readl_relaxed(ioaddr);
+
+	if (value & vsense->latched_mask)
+		sel = 1;
+
+	dev_dbg(vsense->dev, "%s, selection %d (0x%08x)\n", vsense->name, sel,
+		readl_relaxed(ioaddr));
+
+	return sel;
+}
+
+static int st_set_voltage_sel(struct regulator_dev *dev, unsigned int selector)
+{
+	struct st_vsense *vsense = rdev_get_drvdata(dev);
+	void __iomem *ioaddr = vsense->ioaddr;
+	unsigned value = readl_relaxed(ioaddr);
+	unsigned int voltage;
+
+	voltage = st_type_voltages[selector];
+
+	value |= vsense->en_psw_mask;
+	if (voltage == 3300000)
+		value |= vsense->psw_mask;
+	else
+		value &= ~vsense->psw_mask;
+
+	writel_relaxed(value, ioaddr);
+
+	dev_dbg(vsense->dev, "%s, required voltage %d (vsense_conf 0x%08x)\n",
+		vsense->name, voltage,
+		readl_relaxed(ioaddr));
+
+	return 0;
+}
+
+static struct regulator_ops st_ops = {
+	.get_voltage_sel = st_get_voltage_sel,
+	.set_voltage_sel = st_set_voltage_sel,
+	.list_voltage = regulator_list_voltage_table,
+};
+
+static void st_get_satinize_powerup_voltage(struct st_vsense *vsense)
+{
+	void __iomem *ioaddr = vsense->ioaddr;
+	u32 value = readl_relaxed(ioaddr);
+
+	dev_dbg(vsense->dev, "Initial start-up value: (0x%08x)\n", value);
+
+	/* Sanitize voltage values forcing what is provided from start-up */
+	if (value & TOP_VSENSE_CONFIG_LATCHED_PSW_EMMC)
+		value |= TOP_VSENSE_CONFIG_REG_PSW_EMMC;
+	else
+		value &= ~TOP_VSENSE_CONFIG_REG_PSW_EMMC;
+
+	if (value & TOP_VSENSE_CONFIG_LATCHED_PSW_NAND)
+		value |= TOP_VSENSE_CONFIG_REG_PSW_NAND;
+	else
+		value &= ~TOP_VSENSE_CONFIG_REG_PSW_NAND;
+
+	if (value & TOP_VSENSE_CONFIG_LATCHED_PSW_SPI)
+		value |= TOP_VSENSE_CONFIG_REG_PSW_SPI;
+	else
+		value &= ~TOP_VSENSE_CONFIG_REG_PSW_SPI;
+
+	writel_relaxed(value, ioaddr);
+
+	dev_dbg(vsense->dev, "Sanitized value: (0x%08x)\n", value);
+}
+
+static const struct of_device_id __maybe_unused st_vsense_of_match[] = {
+	{.compatible = "st,vqmmc", .data = &st_vsense_data[0]},
+	{.compatible = "st,vnand", .data = &st_vsense_data[1]},
+	{.compatible = "st,vspi", .data = &st_vsense_data[2]},
+	{ /* end */ }
+};
+
+static int st_vsense_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct st_vsense *vsense;
+	const struct of_device_id *device;
+	struct resource *res;
+	struct regulator_desc *rdesc;
+	struct regulator_dev *rdev;
+	struct regulator_config config = { };
+	int ret;
+
+	vsense = devm_kzalloc(dev, sizeof(*vsense), GFP_KERNEL);
+	if (!vsense)
+		return -ENOMEM;
+
+	vsense->dev = dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	vsense->ioaddr = devm_ioremap_resource(dev, res);
+	if (IS_ERR(vsense->ioaddr))
+		return PTR_ERR(vsense->ioaddr);
+
+	rdesc = devm_kzalloc(dev, sizeof(*rdesc), GFP_KERNEL);
+	if (!rdesc)
+		return -ENOMEM;
+
+	device = of_match_device(st_vsense_of_match, &pdev->dev);
+	if (!device)
+		return -ENODEV;
+
+	if (device->data) {
+		const struct st_vsense *data = device->data;
+		vsense->en_psw_mask = data->en_psw_mask;
+		vsense->psw_mask = data->psw_mask;
+		vsense->latched_mask = data->latched_mask;
+	} else
+		return -ENODEV;
+
+	if (of_property_read_string(np, "regulator-name",
+				    (const char **)&vsense->name))
+		return -EINVAL;
+
+	memset(rdesc, 0, sizeof(*rdesc));
+	rdesc->name = vsense->name;
+	rdesc->ops = &st_ops;
+	rdesc->type = REGULATOR_VOLTAGE;
+	rdesc->owner = THIS_MODULE;
+	rdesc->n_voltages = ARRAY_SIZE(st_type_voltages);
+	rdesc->volt_table = st_type_voltages;
+	config.dev = &pdev->dev;
+	config.driver_data = vsense;
+	config.of_node = np;
+
+	config.init_data = of_get_regulator_init_data(&pdev->dev, np, rdesc);
+	if (!config.init_data) {
+		dev_err(dev, "Failed to parse regulator init data\n");
+		return -ENOMEM;
+	}
+
+	/* register regulator */
+	rdev = devm_regulator_register(dev, rdesc, &config);
+	if (IS_ERR(rdev)) {
+		ret = PTR_ERR(rdev);
+		dev_err(dev, "register %s failed with error %d\n", rdesc->name, ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, rdev);
+
+	dev_info(dev, "%s  vsense voltage regulator registered\n", rdesc->name);
+	st_get_satinize_powerup_voltage(vsense);
+
+	return 0;
+}
+
+static int st_vsense_resume(struct device *dev)
+{
+	struct regulator_dev *rdev = dev_get_drvdata(dev);
+	struct st_vsense *vsense = rdev_get_drvdata(rdev);
+
+	st_get_satinize_powerup_voltage(vsense);
+
+	return 0;
+}
+
+MODULE_DEVICE_TABLE(of, st_vsense_of_match);
+
+static DEFINE_SIMPLE_DEV_PM_OPS(st_vsense_pm_ops, NULL,
+						  st_vsense_resume);
+
+static struct platform_driver st_vsense_driver = {
+	.probe = st_vsense_probe,
+	.driver = {
+		   .name = "st-vsense",
+		   .of_match_table = st_vsense_of_match,
+		   .pm	= pm_sleep_ptr(&st_vsense_pm_ops),
+		   },
+};
+module_platform_driver(st_vsense_driver);
+
+MODULE_AUTHOR("Giuseppe Cavallaro <peppe.cavallaro@st.com>");
+MODULE_DESCRIPTION("ST voltage regulator driver for vsense flashSS");
+MODULE_LICENSE("GPL v2");
-- 
2.48.1

From 4aa1f1863b2801e7a51dcce5e19a2396d0784e8c Mon Sep 17 00:00:00 2001
From: Jerome Audu <jau@free.fr>
Date: Wed, 10 May 2023 21:20:11 +0200
Subject: [PATCH 48/72] ARM: dts: sti: enable vsense voltage regulator driver

---
 arch/arm/boot/dts/st/stih407-family.dtsi | 11 +++++++++++
 arch/arm/boot/dts/st/stih418-b2264.dts   |  4 ++++
 arch/arm/boot/dts/st/stih418.dtsi        |  4 ++++
 3 files changed, 19 insertions(+)

diff --git a/arch/arm/boot/dts/st/stih407-family.dtsi b/arch/arm/boot/dts/st/stih407-family.dtsi
index 478415ad2103..bf3bf88a99ac 100644
--- a/arch/arm/boot/dts/st/stih407-family.dtsi
+++ b/arch/arm/boot/dts/st/stih407-family.dtsi
@@ -596,6 +596,16 @@ spi@9542000 {
 			status = "disabled";
 		};
 
+		vqmmc_reg: voltage-regulator {
+			compatible = "st,vqmmc";
+			status = "disabled";
+			regulator-name = "vqmmc0";
+			reg = <0x9061004 0x4>;
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+
 		mmc0: sdhci@9060000 {
 			compatible = "st,sdhci-stih407", "st,sdhci";
 			status = "disabled";
@@ -609,6 +619,7 @@ mmc0: sdhci@9060000 {
 			clocks = <&clk_s_c0_flexgen CLK_MMC_0>,
 				 <&clk_s_c0_flexgen CLK_RX_ICN_HVA>;
 			bus-width = <8>;
+			vqmmc-supply = <&vqmmc_reg>;
 		};
 
 		mmc1: sdhci@9080000 {
diff --git a/arch/arm/boot/dts/st/stih418-b2264.dts b/arch/arm/boot/dts/st/stih418-b2264.dts
index a15f4572ba14..e53e972cc3b4 100644
--- a/arch/arm/boot/dts/st/stih418-b2264.dts
+++ b/arch/arm/boot/dts/st/stih418-b2264.dts
@@ -145,6 +145,10 @@ phy_port1: port@9b2a000 {
 	};
 };
 
+&vqmmc_reg {
+	status = "okay";
+};
+
 &mmc0 {
 	status = "okay";
 };
diff --git a/arch/arm/boot/dts/st/stih418.dtsi b/arch/arm/boot/dts/st/stih418.dtsi
index 8fb8b3af5e49..a1c325e3a6ee 100644
--- a/arch/arm/boot/dts/st/stih418.dtsi
+++ b/arch/arm/boot/dts/st/stih418.dtsi
@@ -136,6 +136,10 @@ ehci1: usb@9a83e00 {
 			phy-names = "usb";
 		};
 
+		vqmmc_reg: voltage-regulator {
+			reg = <0x9061804 0x4>;
+		};
+
 		mmc0: sdhci@9060000 {
 			assigned-clocks = <&clk_s_c0_flexgen CLK_MMC_0>;
 			assigned-clock-parents = <&clk_s_c0_pll1 0>;
-- 
2.48.1

From 6a28ca47b87a9a24893c10cc8a506b3011a23e60 Mon Sep 17 00:00:00 2001
From: Jerome Audu <jau@free.fr>
Date: Wed, 23 Aug 2023 14:58:20 +0200
Subject: [PATCH 49/72] pinctrl: st: use dynamic allocation of GPIO base

Since commit 502df79b860563d7 ("gpiolib: Warn on drivers still using static
gpiobase allocation"), one or more warnings are printed during boot on
systems where static allocation of GPIO base is used:

[    0.022795] gpio gpiochip0: Static allocation of GPIO base is deprecated, use dynamic allocation.
[    0.023098] st-pinctrl 961f080.pin-controller-sbc: PIO0 bank added.
[    0.023174] gpio gpiochip1: Static allocation of GPIO base is deprecated, use dynamic allocation.
[    0.023375] st-pinctrl 961f080.pin-controller-sbc: PIO1 bank added.
[    0.023447] gpio gpiochip2: Static allocation of GPIO base is deprecated, use dynamic allocation.
[    0.023637] st-pinctrl 961f080.pin-controller-sbc: PIO2 bank added.

So let's follow the suggestion and use dynamic allocation.
---
 drivers/pinctrl/pinctrl-st.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/pinctrl/pinctrl-st.c b/drivers/pinctrl/pinctrl-st.c
index fe2d52e434db..b4bf27a3a59a 100644
--- a/drivers/pinctrl/pinctrl-st.c
+++ b/drivers/pinctrl/pinctrl-st.c
@@ -1506,7 +1506,7 @@ static int st_gpiolib_register_bank(struct st_pinctrl *info,
 		return PTR_ERR(bank->base);
 
 	bank->gpio_chip = st_gpio_template;
-	bank->gpio_chip.base = bank_num * ST_GPIO_PINS_PER_BANK;
+	bank->gpio_chip.base = -1;
 	bank->gpio_chip.ngpio = ST_GPIO_PINS_PER_BANK;
 	bank->gpio_chip.fwnode = of_fwnode_handle(np);
 	bank->gpio_chip.parent = dev;
@@ -1516,7 +1516,7 @@ static int st_gpiolib_register_bank(struct st_pinctrl *info,
 	bank->gpio_chip.label = range->name;
 
 	range->id = bank_num;
-	range->pin_base = range->base = range->id * ST_GPIO_PINS_PER_BANK;
+	range->pin_base = range->base = range->id * ST_GPIO_PINS_PER_BANK + 512;
 	range->npins = bank->gpio_chip.ngpio;
 	range->gc = &bank->gpio_chip;
 
-- 
2.48.1

From eac93c03adcc260853243ebb6de581b015b5ee54 Mon Sep 17 00:00:00 2001
From: Alain Volmat <alain.volmat@foss.st.com>
Date: Thu, 1 Jun 2023 09:53:40 +0200
Subject: [PATCH 50/72] tty: serial: st-asc: start transmit within start_tx

Fix the st-asc tx transmit call to be done within the start_tx
ops rather than the startup call as stated within the serial driver
doc: Documentation/driver-api/serial/driver.rst

Signed-off-by: Alain Volmat <alain.volmat@foss.st.com>
Change-Id: I47cb936922c84f5bd51b75224f2a6f0db1919f76
Reviewed-on: https://gerrit.st.com/c/catapult-os/kernel/+/310136
Tested-by: Jerome AUDU <jerome.audu@st.com>
Reviewed-by: Jerome AUDU <jerome.audu@st.com>
Reviewed-by: Raphael GALLAIS-POU <raphael.gallais-pou@foss.st.com>
---
 drivers/tty/serial/st-asc.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/drivers/tty/serial/st-asc.c b/drivers/tty/serial/st-asc.c
index 6ed9a327702b..3c1ce7a32eb0 100644
--- a/drivers/tty/serial/st-asc.c
+++ b/drivers/tty/serial/st-asc.c
@@ -391,6 +391,8 @@ static void asc_start_tx(struct uart_port *port)
 
 	if (!kfifo_is_empty(&tport->xmit_fifo))
 		asc_enable_tx_interrupts(port);
+
+	asc_transmit_chars(port);
 }
 
 /* Transmit stop */
@@ -422,7 +424,6 @@ static int asc_startup(struct uart_port *port)
 		return -ENODEV;
 	}
 
-	asc_transmit_chars(port);
 	asc_enable_rx_interrupts(port);
 
 	return 0;
-- 
2.48.1

From 5a64cfe67b4c7c1aa1a9e6b1a1d7257df40c5cab Mon Sep 17 00:00:00 2001
From: Alain Volmat <alain.volmat@foss.st.com>
Date: Thu, 1 Jun 2023 15:43:13 +0200
Subject: [PATCH 51/72] tty: serial: st-asc: fix race between startup /
 console_write

The startup ops is protected by the uart_port mutex, while the
console_write is protected by the uart_port spin_lock.  This leads
to a race condition situation when the startup call comes in the
middle of a console_write.  Indeed during the console_write, the
interrupts are disabled and the rx interrupt enabling performed
by the startup op can thus be override when enabling back the
interrupts at the end of console_write.

To fix this issue, protect the asc_enable_rx_interrupts call with the
uart_port spin_lock.

Signed-off-by: Alain Volmat <alain.volmat@foss.st.com>
Change-Id: I6409c5461bf1ebcf2293fb1fe6d4f65d5e2dd6b6
Reviewed-on: https://gerrit.st.com/c/catapult-os/kernel/+/310137
Tested-by: Jerome AUDU <jerome.audu@st.com>
Reviewed-by: Jerome AUDU <jerome.audu@st.com>
Reviewed-by: Raphael GALLAIS-POU <raphael.gallais-pou@foss.st.com>
---
 drivers/tty/serial/st-asc.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/drivers/tty/serial/st-asc.c b/drivers/tty/serial/st-asc.c
index 3c1ce7a32eb0..707420617950 100644
--- a/drivers/tty/serial/st-asc.c
+++ b/drivers/tty/serial/st-asc.c
@@ -418,13 +418,17 @@ static void asc_break_ctl(struct uart_port *port, int break_state)
  */
 static int asc_startup(struct uart_port *port)
 {
+	unsigned long flags;
+
 	if (request_irq(port->irq, asc_interrupt, 0,
 			asc_port_name(port), port)) {
 		dev_err(port->dev, "cannot allocate irq.\n");
 		return -ENODEV;
 	}
 
+	spin_lock_irqsave(&port->lock, flags);
 	asc_enable_rx_interrupts(port);
+	spin_unlock_irqrestore(&port->lock, flags);
 
 	return 0;
 }
-- 
2.48.1

From 5ef1191a304908fa4979811fe2ad4b18343f8efb Mon Sep 17 00:00:00 2001
From: Jerome Audu <jerome.audu@st.com>
Date: Mon, 13 Jan 2025 11:49:50 +0100
Subject: [PATCH 52/72] mmc: sdhci-st: driver uses st-flashss to perform
 voltage regulation

This causes driver initialization to fail on boot when st-flashss isn't built into the kernel statically,
as a result of the missing module dependency and, consequently, the required
st_flashss module not being included in the initial ramdisk.  Thus, let's mark
st_flashss as a softdep for sdhci-st, to have its kernel module
included in the initial ramdisk
---
 drivers/mmc/host/sdhci-st.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/mmc/host/sdhci-st.c b/drivers/mmc/host/sdhci-st.c
index 901e431976ce..65399aae3440 100644
--- a/drivers/mmc/host/sdhci-st.c
+++ b/drivers/mmc/host/sdhci-st.c
@@ -520,3 +520,4 @@ MODULE_DESCRIPTION("SDHCI driver for STMicroelectronics SoCs");
 MODULE_AUTHOR("Giuseppe Cavallaro <peppe.cavallaro@st.com>");
 MODULE_LICENSE("GPL v2");
 MODULE_ALIAS("platform:sdhci-st");
+MODULE_SOFTDEP("pre: st_flashss");
-- 
2.48.1

From 980925d6823617d26be1d5c28c92ade6673331a3 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 27 Jul 2023 21:51:25 +0000
Subject: [PATCH 53/72] drm/sti: add hdmi tx6g0c28 phy for STi platform

Addition of the HDMI TX PHY driver for use in the STiH418
SoC platform and more especially the 4KOpen (B2264) board.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/Makefile               |   1 +
 drivers/gpu/drm/sti/sti_hdmi.c             |   4 +
 drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.c | 292 +++++++++++++++++++++
 drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.h |  13 +
 4 files changed, 310 insertions(+)
 create mode 100644 drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.c
 create mode 100644 drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.h

diff --git a/drivers/gpu/drm/sti/Makefile b/drivers/gpu/drm/sti/Makefile
index f203ac5514ae..bf52edb7dba5 100644
--- a/drivers/gpu/drm/sti/Makefile
+++ b/drivers/gpu/drm/sti/Makefile
@@ -11,6 +11,7 @@ sti-drm-y := \
 	sti_plane.o \
 	sti_hdmi.o \
 	sti_hdmi_tx3g4c28phy.o \
+	sti_hdmi_tx6g0c28phy.o \
 	sti_dvo.o \
 	sti_awg_utils.o \
 	sti_vtg.o \
diff --git a/drivers/gpu/drm/sti/sti_hdmi.c b/drivers/gpu/drm/sti/sti_hdmi.c
index 21b46a6465f0..6ebeff566daa 100644
--- a/drivers/gpu/drm/sti/sti_hdmi.c
+++ b/drivers/gpu/drm/sti/sti_hdmi.c
@@ -27,6 +27,7 @@
 
 #include "sti_hdmi.h"
 #include "sti_hdmi_tx3g4c28phy.h"
+#include "sti_hdmi_tx6g0c28phy.h"
 #include "sti_vtg.h"
 
 #define HDMI_CFG                        0x0000
@@ -1367,6 +1368,9 @@ static const struct of_device_id hdmi_of_match[] = {
 	{
 		.compatible = "st,stih407-hdmi",
 		.data = &tx3g4c28phy_ops,
+	}, {
+		.compatible = "st,stih418-hdmi",
+		.data = &tx6g0c28phy_ops,
 	}, {
 		/* end node */
 	}
diff --git a/drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.c b/drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.c
new file mode 100644
index 000000000000..7bd260429044
--- /dev/null
+++ b/drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.c
@@ -0,0 +1,292 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Author: Alain Volmat <avolmat@me.com>
+ *
+ * This driver is highly inspired from sti_hdmi_tx3g4c28phy.c copyright by ST Microelectronics
+ * with IP behavior understood by looking at the display package from 4kopen.com
+ * https://bitbucket.org/4kopen/display/src/master/display/ip/hdmi/stmhdmitx6g0_c28_phy.cpp
+ */
+
+#include <drm/drm_device.h>
+#include <drm/drm_print.h>
+#include <linux/delay.h>
+#include <linux/reset.h>
+
+#include "sti_hdmi_tx6g0c28phy.h"
+
+#define HDMI_SRZ_CFG		0x504
+#define HDMI_SRZ_PWR_CFG	0x508
+#define HDMI_SRZ_PLL_CFG	0x510
+#define HDMI_SRZ_STR_1		0x518
+#define HDMI_SRZ_STR_2		0x51C
+#define HDMI_SRZ_CALCODE_EXT	0x530
+#define HDMI_SRZ_TX_RSVR_BITS	0x560
+
+/* ******************************* */
+/* register : HDMI_SRZ_CFG         */
+/* ******************************* */
+#define HDMI_SRZ_CFG_EN				BIT(0)
+#define HDMI_SRZ_CFG_EN_PE_C0_MASK		GENMASK(6, 4)
+#define HDMI_SRZ_CFG_EN_PE_C1_MASK		GENMASK(10, 8)
+#define HDMI_SRZ_CFG_EN_PE_C2_MASK		GENMASK(14, 12)
+
+#define HDMI_SRZ_CFG_EXTERNAL_DATA		BIT(16)
+#define HDMI_SRZ_CFG_RBIAS_EXT			BIT(17)
+#define HDMI_SRZ_CFG_EN_SINK_TERM_DETECTION	BIT(18)
+#define HDMI_SRZ_CFG_ISNKCTRL_MASK		GENMASK(21, 20)
+
+#define HDMI_SRZ_CFG_EN_SRC_TERM_SHIFT    (24)
+#define HDMI_SRZ_CFG_EN_SRC_TERM_VAL_0_165MHZ             (0x0)
+#define HDMI_SRZ_CFG_EN_SRC_TERM_VAL_165_340MHZ      (0x2)
+#define HDMI_SRZ_CFG_EN_SRC_TERM_VAL_ABV_340MHZ             (0x3)
+
+#define HDMI_SRZ_CFG_CKCH_LOWSW_EN_SHIFT          (29)
+#define HDMI_SRZ_CFG_CKCH_LOWSW_EN_VAL_500MV      (0x0) /* for below or equal 3.4 Gbps */
+#define HDMI_SRZ_CFG_CKCH_LOWSW_EN_VAL_300MV      (0x1) /* for above 3.4 Gbps */
+
+#define HDMI_SRZ_CFG_CKBY10_OR_40_SHIFT             (30)
+#define HDMI_SRZ_CFG_CKBY10_OR_40_VAL_DIV_BY_10     (0x0) /* for below or equal 3.4 Gbps */
+#define HDMI_SRZ_CFG_CKBY10_OR_40_VAL_DIV_BY_40     (0x1) /* for above 3.4 Gbps */
+
+#define HDMI_SRZ_CFG_DATA20BIT10BIT_SHIFT           (31)
+#define HDMI_SRZ_CFG_DATA20BIT10BIT_VAL_10_BPC      (0x0)
+#define HDMI_SRZ_CFG_DATA20BIT10BIT_VAL_20_BPC      (0x1)
+
+/* ******************************* */
+/* register : HDMI_SRZ_PLL_CFG     */
+/* ******************************* */
+#define HDMI_PLL_CFG_EN		BIT(0)
+#define HDMI_PLL_CFG_NDIV_SHIFT (8)
+#define HDMI_PLL_CFG_IDF_SHIFT  (16)
+#define HDMI_PLL_CFG_ODF_SHIFT  (24)
+
+#define ODF_DIV_1          (0)
+#define ODF_DIV_2          (1)
+#define ODF_DIV_4          (2)
+#define ODF_DIV_8          (3)
+#define ODF_DIV_16         (4)
+
+/* ******************************* */
+/* register : HDMI_SRZ_STR_1       */
+/* ******************************* */
+#define HDMI_SRZ_STR1_MSK_PEXC0   GENMASK(11, 0)
+#define HDMI_SRZ_STR1_MSK_PEXC1   GENMASK(27, 16)
+
+/* ******************************* */
+/* register : HDMI_SRZ_STR_2       */
+/* ******************************* */
+#define HDMI_SRZ_STR2_PEXC2       (0)
+#define HDMI_SRZ_STR2_MSK_PEXC2   (0xFFF << HDMI_SRZ_STR2_PEXC2)
+
+/* ******************************* */
+/* register : HDMI_SRZ_CALCODE_EXT */
+/* ******************************* */
+#define HDMI_SRZ_CALCODE_EXT_MASK        GENMASK(27, 0)
+
+/* ******************************** */
+/* register : HDMI_SRZ_TX_RSVR_BITS */
+/* ******************************** */
+#define HDMI_SRZ_TX_RSVR_BITS_BELOW_340MHZ       (0)
+#define HDMI_SRZ_TX_RSVR_BITS_ABOVE_340MHZ       (0x0800000)
+
+/* *********************************** */
+/* Configuration                       */
+/* *********************************** */
+/* Config 0 => HDMI_SRZ_CFG */
+#define HDMI_SRZ_CONFIG_0_MASK  (HDMI_SRZ_CFG_EN_PE_C0_MASK | \
+				 HDMI_SRZ_CFG_EN_PE_C1_MASK | \
+				 HDMI_SRZ_CFG_EN_PE_C2_MASK | \
+				 HDMI_SRZ_CFG_ISNKCTRL_MASK)
+/* Config 1 => HDMI_SRZ_STR_1 */
+#define HDMI_SRZ_CONFIG_1_MASK  (HDMI_SRZ_STR1_MSK_PEXC0 | HDMI_SRZ_STR1_MSK_PEXC1)
+
+/* Config 2 => HDMI_SRZ_STR_2 */
+#define HDMI_SRZ_CONFIG_2_MASK  (HDMI_SRZ_STR2_MSK_PEXC2)
+
+/* Config 3 => HDMI_SRZ_CALCODE_EXT */
+#define HDMI_SRZ_CONFIG_3_MASK  (HDMI_SRZ_CALCODE_EXT_MASK)
+
+#define STM_HDMI_THOLD_CLK_600MHZ  (600000000)
+#define STM_HDMI_THOLD_CLK_340MHZ  (340000000)
+#define STM_HDMI_THOLD_CLK_165MHZ  (165000000)
+
+#define HDMI_TIMEOUT_PLL_LOCK  50  /*milliseconds */
+
+struct plldividers_s {
+	u32 min;
+	u32 max;
+	u32 idf;
+	u32 odf;
+};
+
+/*
+ * Functional specification recommended values
+ */
+static struct plldividers_s plldividers[] = {
+	{0, 37500000, 1, ODF_DIV_16 },
+	{37500000, 75000000, 2, ODF_DIV_8 },
+	{75000000, 150000000, 4, ODF_DIV_4 },
+	{150000000, 300000000, 8, ODF_DIV_2 },
+	{300000000, 600000000, 16, ODF_DIV_1 }
+};
+
+static struct hdmi_phy_config hdmiphy_config[] = {
+	{0, 145000000, {0x0, 0x0, 0x0, 0x0} },
+	{145000000, 165000000, {0x1110, 0x0, 0x0, 0x0} },
+	{165000000, 340000000, {0x1110, 0x30003, 0x3, 0x0} },
+	{340000000, 600000000, {0x200000, 0x0, 0x0, 0x0} },
+};
+
+/**
+ * sti_hdmi_tx6g0c28phy_start - Start hdmi phy macro cell tx6g0c28
+ *
+ * @hdmi: pointer on the hdmi internal structure
+ *
+ * Return false if an error occur
+ */
+static bool sti_hdmi_tx6g0c28phy_start(struct sti_hdmi *hdmi)
+{
+	u32 ckpxpll = hdmi->mode.clock * 1000;
+	u32 cfg, val, tmdsck, idf, odf, pllctrl = 0;
+	bool foundplldivides = false;
+	u32 tx_rsvr_bits = HDMI_SRZ_TX_RSVR_BITS_BELOW_340MHZ;
+	int i;
+
+	drm_dbg_driver(hdmi->drm_dev, "%s: ckpxpll = %dHz\n", __func__, ckpxpll);
+
+	for (i = 0; i < ARRAY_SIZE(plldividers); i++) {
+		if (ckpxpll >= plldividers[i].min &&
+		    ckpxpll < plldividers[i].max) {
+			idf = plldividers[i].idf;
+			odf = plldividers[i].odf;
+			foundplldivides = true;
+			break;
+		}
+	}
+
+	if (!foundplldivides) {
+		dev_err(&hdmi->dev, "%s: input TMDS clock speed (%d) not supported\n",
+			__func__, ckpxpll);
+		return false;
+	}
+
+	/* Assuming no pixel repetition and 24bits color */
+	tmdsck = ckpxpll;
+	pllctrl |= 20 << HDMI_PLL_CFG_NDIV_SHIFT;
+
+	if (tmdsck > STM_HDMI_THOLD_CLK_600MHZ) {
+		dev_err(&hdmi->dev, "%s: output TMDS clock (%d) out of range\n", __func__, tmdsck);
+		return false;
+	}
+
+	pllctrl |= idf << HDMI_PLL_CFG_IDF_SHIFT;
+	pllctrl |= odf << HDMI_PLL_CFG_ODF_SHIFT;
+
+	cfg = (HDMI_SRZ_CFG_EN |
+	       HDMI_SRZ_CFG_EXTERNAL_DATA |
+	       HDMI_SRZ_CFG_RBIAS_EXT |
+	       HDMI_SRZ_CFG_EN_SINK_TERM_DETECTION |
+	       (HDMI_SRZ_CFG_DATA20BIT10BIT_VAL_10_BPC << HDMI_SRZ_CFG_DATA20BIT10BIT_SHIFT));
+
+	if (tmdsck > STM_HDMI_THOLD_CLK_340MHZ) {
+		cfg |= (HDMI_SRZ_CFG_EN_SRC_TERM_VAL_ABV_340MHZ << HDMI_SRZ_CFG_EN_SRC_TERM_SHIFT) |
+		       (HDMI_SRZ_CFG_CKCH_LOWSW_EN_VAL_300MV << HDMI_SRZ_CFG_CKCH_LOWSW_EN_SHIFT) |
+		       (HDMI_SRZ_CFG_CKBY10_OR_40_VAL_DIV_BY_40 << HDMI_SRZ_CFG_CKBY10_OR_40_SHIFT);
+		tx_rsvr_bits = HDMI_SRZ_TX_RSVR_BITS_ABOVE_340MHZ;
+	} else if (tmdsck > STM_HDMI_THOLD_CLK_165MHZ) {
+		cfg |= (HDMI_SRZ_CFG_EN_SRC_TERM_VAL_165_340MHZ << HDMI_SRZ_CFG_EN_SRC_TERM_SHIFT) |
+		       (HDMI_SRZ_CFG_CKCH_LOWSW_EN_VAL_500MV << HDMI_SRZ_CFG_CKCH_LOWSW_EN_SHIFT) |
+		       (HDMI_SRZ_CFG_CKBY10_OR_40_VAL_DIV_BY_10 << HDMI_SRZ_CFG_CKBY10_OR_40_SHIFT);
+	} else {
+		cfg |= (HDMI_SRZ_CFG_EN_SRC_TERM_VAL_0_165MHZ << HDMI_SRZ_CFG_EN_SRC_TERM_SHIFT) |
+		       (HDMI_SRZ_CFG_CKCH_LOWSW_EN_VAL_500MV << HDMI_SRZ_CFG_CKCH_LOWSW_EN_SHIFT) |
+		       (HDMI_SRZ_CFG_CKBY10_OR_40_VAL_DIV_BY_10 << HDMI_SRZ_CFG_CKBY10_OR_40_SHIFT);
+	}
+
+	/*
+	 * To configure the source termination and pre-emphasis appropriately
+	 * for different high speed TMDS clock frequencies a phy configuration
+	 * table must be provided, tailored to the SoC and board combination.
+	 */
+	for (i = 0; i < ARRAY_SIZE(hdmiphy_config); i++) {
+		if (hdmiphy_config[i].min_tmds_freq <= tmdsck &&
+		    hdmiphy_config[i].max_tmds_freq >= tmdsck) {
+			cfg |= (hdmiphy_config[i].config[0] & HDMI_SRZ_CONFIG_0_MASK);
+			hdmi_write(hdmi, cfg, HDMI_SRZ_CFG);
+			hdmi_write(hdmi, 0, HDMI_SRZ_PWR_CFG);
+
+			val = hdmiphy_config[i].config[1] & HDMI_SRZ_CONFIG_1_MASK;
+			hdmi_write(hdmi, val, HDMI_SRZ_STR_1);
+
+			val = hdmiphy_config[i].config[2] & HDMI_SRZ_CONFIG_2_MASK;
+			hdmi_write(hdmi, val, HDMI_SRZ_STR_2);
+
+			val = hdmiphy_config[i].config[3] & HDMI_SRZ_CONFIG_3_MASK;
+			hdmi_write(hdmi, val, HDMI_SRZ_CALCODE_EXT);
+
+			hdmi_write(hdmi, tx_rsvr_bits, HDMI_SRZ_TX_RSVR_BITS);
+
+			/*
+			 * Configure and power up the PHY PLL
+			 */
+			hdmi->event_received = false;
+			hdmi_write(hdmi, (pllctrl | HDMI_PLL_CFG_EN), HDMI_SRZ_PLL_CFG);
+
+			/* wait PLL interrupt */
+			wait_event_interruptible_timeout(hdmi->wait_event, hdmi->event_received,
+							 msecs_to_jiffies(HDMI_TIMEOUT_PLL_LOCK));
+
+			if ((hdmi_read(hdmi, HDMI_STA) & HDMI_STA_DLL_LCK) == 0) {
+				dev_err(&hdmi->dev, "%s: hdmi phy pll not locked\n", __func__);
+				return false;
+			}
+
+			/* Reset the HDMI_TX_PHY */
+			reset_control_assert(hdmi->reset);
+			usleep_range(15, 20);
+			reset_control_deassert(hdmi->reset);
+
+			return true;
+		}
+	}
+
+	/*
+	 * Default, power up the serializer with no pre-emphasis or
+	 * output swing correction
+	 */
+	hdmi_write(hdmi, cfg, HDMI_SRZ_CFG);
+	hdmi_write(hdmi, 0, HDMI_SRZ_PWR_CFG);
+	hdmi_write(hdmi, 0, HDMI_SRZ_STR_1);
+	hdmi_write(hdmi, 0, HDMI_SRZ_STR_2);
+	hdmi_write(hdmi, 0, HDMI_SRZ_CALCODE_EXT);
+	hdmi_write(hdmi, 0, HDMI_SRZ_TX_RSVR_BITS);
+
+	return true;
+}
+
+/**
+ * sti_hdmi_tx6g0c28phy_stop - Stop hdmi phy macro cell tx6g0c28
+ *
+ * @hdmi: pointer on the hdmi internal structure
+ */
+static void sti_hdmi_tx6g0c28phy_stop(struct sti_hdmi *hdmi)
+{
+	hdmi->event_received = false;
+
+	hdmi_write(hdmi, HDMI_SRZ_CFG_EN_SINK_TERM_DETECTION, HDMI_SRZ_CFG);
+	hdmi_write(hdmi, 0, HDMI_SRZ_PLL_CFG);
+
+	/* wait PLL interrupt */
+	wait_event_interruptible_timeout(hdmi->wait_event,
+					 hdmi->event_received,
+					 msecs_to_jiffies
+					 (HDMI_TIMEOUT_PLL_LOCK));
+
+	if (hdmi_read(hdmi, HDMI_STA) & HDMI_STA_DLL_LCK)
+		dev_err(&hdmi->dev, "%s: hdmi phy pll not well disabled\n", __func__);
+}
+
+struct hdmi_phy_ops tx6g0c28phy_ops = {
+	.start = sti_hdmi_tx6g0c28phy_start,
+	.stop = sti_hdmi_tx6g0c28phy_stop,
+};
diff --git a/drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.h b/drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.h
new file mode 100644
index 000000000000..bcb8b70d36ea
--- /dev/null
+++ b/drivers/gpu/drm/sti/sti_hdmi_tx6g0c28phy.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Author: Alain Volmat <avolmat@me.com>
+ */
+
+#ifndef _STI_HDMI_TX6G0C28PHY_H_
+#define _STI_HDMI_TX6G0C28PHY_H_
+
+#include "sti_hdmi.h"
+
+extern struct hdmi_phy_ops tx6g0c28phy_ops;
+
+#endif
-- 
2.48.1

From f1c0a13d3d84de3dd1ba8a72765e5b41aefe3f0b Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 27 Jul 2023 21:51:26 +0000
Subject: [PATCH 54/72] dt-bindings: display: add st,stih418-vtg compatible for
 sti vtg

Add a new compatible in st,stih4xx.txt in order to support sti vtg on
stih418 platforms.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 Documentation/devicetree/bindings/display/st,stih4xx.txt | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Documentation/devicetree/bindings/display/st,stih4xx.txt b/Documentation/devicetree/bindings/display/st,stih4xx.txt
index 6778b3e7ad5b..5450e1db8b8d 100644
--- a/Documentation/devicetree/bindings/display/st,stih4xx.txt
+++ b/Documentation/devicetree/bindings/display/st,stih4xx.txt
@@ -2,7 +2,7 @@ STMicroelectronics stih4xx platforms
 
 - sti-vtg: video timing generator
   Required properties:
-  - compatible: "st,vtg"
+  - compatible: "st,vtg" or "st,stih418-vtg"
   - reg: Physical base address of the IP registers and length of memory mapped region.
   Optional properties:
   - interrupts : VTG interrupt number to the CPU.
-- 
2.48.1

From 71443e4de1f14321b761f5b18491768b4f6056f8 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 27 Jul 2023 21:51:27 +0000
Subject: [PATCH 55/72] drm/sti: add support for VTG on the stih418 platform

VTG integrated into the STiH418 differ in the number of outputs
available and allocation of each output.  Indeed on STiH418, there
are 6 outputs (4 on the STiH407/STiH410) and HDMI is connected to
the 5th output in case of STiH418 while it is on the 1st output
in case of STiH407/STiH410.

A new compatible st,stih418-vtg is added to differentiate that.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/sti_vtg.c | 62 +++++++++++++++++++++++++++++------
 1 file changed, 52 insertions(+), 10 deletions(-)

diff --git a/drivers/gpu/drm/sti/sti_vtg.c b/drivers/gpu/drm/sti/sti_vtg.c
index 5ba469b711b5..19d1e4099972 100644
--- a/drivers/gpu/drm/sti/sti_vtg.c
+++ b/drivers/gpu/drm/sti/sti_vtg.c
@@ -60,6 +60,18 @@
 #define VTG_TOP_V_HD_4      0x012c
 #define VTG_BOT_V_HD_4      0x0130
 
+#define VTG_H_HD_5          0x0140
+#define VTG_TOP_V_VD_5      0x0144
+#define VTG_BOT_V_VD_5      0x0148
+#define VTG_TOP_V_HD_5      0x014c
+#define VTG_BOT_V_HD_5      0x0150
+
+#define VTG_H_HD_6          0x0160
+#define VTG_TOP_V_VD_6      0x0164
+#define VTG_BOT_V_VD_6      0x0168
+#define VTG_TOP_V_HD_6      0x016c
+#define VTG_BOT_V_HD_6      0x0170
+
 #define VTG_IRQ_BOTTOM      BIT(0)
 #define VTG_IRQ_TOP         BIT(1)
 #define VTG_IRQ_MASK        (VTG_IRQ_TOP | VTG_IRQ_BOTTOM)
@@ -92,7 +104,12 @@ struct sti_vtg_regs_offs {
 	u32 bot_v_hd;
 };
 
-#define VTG_MAX_SYNC_OUTPUT 4
+struct sti_vtg_data {
+	unsigned int nb_sync_output;
+	unsigned int hdmi_sync_id;
+};
+
+#define VTG_MAX_SYNC_OUTPUT 6
 static const struct sti_vtg_regs_offs vtg_regs_offs[VTG_MAX_SYNC_OUTPUT] = {
 	{ VTG_H_HD_1,
 	  VTG_TOP_V_VD_1, VTG_BOT_V_VD_1, VTG_TOP_V_HD_1, VTG_BOT_V_HD_1 },
@@ -101,7 +118,11 @@ static const struct sti_vtg_regs_offs vtg_regs_offs[VTG_MAX_SYNC_OUTPUT] = {
 	{ VTG_H_HD_3,
 	  VTG_TOP_V_VD_3, VTG_BOT_V_VD_3, VTG_TOP_V_HD_3, VTG_BOT_V_HD_3 },
 	{ VTG_H_HD_4,
-	  VTG_TOP_V_VD_4, VTG_BOT_V_VD_4, VTG_TOP_V_HD_4, VTG_BOT_V_HD_4 }
+	  VTG_TOP_V_VD_4, VTG_BOT_V_VD_4, VTG_TOP_V_HD_4, VTG_BOT_V_HD_4 },
+	{ VTG_H_HD_5,
+	  VTG_TOP_V_VD_5, VTG_BOT_V_VD_5, VTG_TOP_V_HD_5, VTG_BOT_V_HD_5 },
+	{ VTG_H_HD_6,
+	  VTG_TOP_V_VD_6, VTG_BOT_V_VD_6, VTG_TOP_V_HD_6, VTG_BOT_V_HD_6 }
 };
 
 /*
@@ -138,6 +159,7 @@ struct sti_vtg {
 	u32 irq_status;
 	struct raw_notifier_head notifier_list;
 	struct drm_crtc *crtc;
+	struct sti_vtg_data data;
 };
 
 struct sti_vtg *of_vtg_find(struct device_node *np)
@@ -252,7 +274,7 @@ static void vtg_set_mode(struct sti_vtg *vtg,
 	vtg_set_output_window(vtg->regs, mode);
 
 	/* Set hsync and vsync position for HDMI */
-	vtg_set_hsync_vsync_pos(&sync[VTG_SYNC_ID_HDMI - 1], HDMI_DELAY, mode);
+	vtg_set_hsync_vsync_pos(&sync[vtg->data.hdmi_sync_id - 1], HDMI_DELAY, mode);
 
 	/* Set hsync and vsync position for HD DCS */
 	vtg_set_hsync_vsync_pos(&sync[VTG_SYNC_ID_HDDCS - 1], 0, mode);
@@ -264,7 +286,7 @@ static void vtg_set_mode(struct sti_vtg *vtg,
 	vtg_set_hsync_vsync_pos(&sync[VTG_SYNC_ID_DVO - 1], DVO_DELAY, mode);
 
 	/* Progam the syncs outputs */
-	for (i = 0; i < VTG_MAX_SYNC_OUTPUT ; i++) {
+	for (i = 0; i < vtg->data.nb_sync_output ; i++) {
 		writel(sync[i].hsync,
 		       vtg->regs + vtg_regs_offs[i].h_hd);
 		writel(sync[i].vsync_line_top,
@@ -376,9 +398,27 @@ static irqreturn_t vtg_irq(int irq, void *arg)
 	return IRQ_WAKE_THREAD;
 }
 
+static const struct sti_vtg_data stih407_vtg_data = {
+	.nb_sync_output = 4,
+	.hdmi_sync_id = 1,
+};
+
+static const struct sti_vtg_data stih418_vtg_data = {
+	.nb_sync_output = 6,
+	.hdmi_sync_id = 5,
+};
+
+static const struct of_device_id vtg_of_match[] = {
+	{ .compatible = "st,vtg", .data = &stih407_vtg_data, },
+	{ .compatible = "st,stih418-vtg", .data = &stih418_vtg_data, },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, vtg_of_match);
+
 static int vtg_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
 	struct sti_vtg *vtg;
 	struct resource *res;
 	int ret;
@@ -387,6 +427,14 @@ static int vtg_probe(struct platform_device *pdev)
 	if (!vtg)
 		return -ENOMEM;
 
+	memcpy(&vtg->data, of_match_node(vtg_of_match, np)->data,
+	       sizeof(struct sti_vtg_data));
+
+	if (vtg->data.nb_sync_output > VTG_MAX_SYNC_OUTPUT) {
+		dev_err(dev, "Invalid number of VTG sync output\n");
+		return -EINVAL;
+	}
+
 	/* Get Memory ressources */
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
@@ -422,12 +470,6 @@ static int vtg_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static const struct of_device_id vtg_of_match[] = {
-	{ .compatible = "st,vtg", },
-	{ /* sentinel */ }
-};
-MODULE_DEVICE_TABLE(of, vtg_of_match);
-
 struct platform_driver sti_vtg_driver = {
 	.driver = {
 		.name = "sti-vtg",
-- 
2.48.1

From eb38365c1865415edc5f0f8cfa1527308d9dd3dc Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 27 Jul 2023 21:51:28 +0000
Subject: [PATCH 56/72] drm/sti: add STih418 platform support in sti mixer

On the STiH418, since there are more planes attached to the
mixer, the bit field for each depth of is now coded using 4 bits
instead of 3 bits.  Some registers as well differ between STiH407
and STiH418 leading on relying on the st,stih418-compositor compatible
to distinguish proper behavior.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/sti_mixer.c | 71 ++++++++++++++++++++++++++-------
 1 file changed, 57 insertions(+), 14 deletions(-)

diff --git a/drivers/gpu/drm/sti/sti_mixer.c b/drivers/gpu/drm/sti/sti_mixer.c
index 06c1b81912f7..c01f4f69a211 100644
--- a/drivers/gpu/drm/sti/sti_mixer.c
+++ b/drivers/gpu/drm/sti/sti_mixer.c
@@ -7,6 +7,7 @@
  */
 
 #include <linux/moduleparam.h>
+#include <linux/of.h>
 #include <linux/seq_file.h>
 
 #include <drm/drm_print.h>
@@ -23,10 +24,12 @@ module_param_named(bkgcolor, bkg_color, int, 0644);
 /* regs offset */
 #define GAM_MIXER_CTL      0x00
 #define GAM_MIXER_BKC      0x04
+#define GAM_MIXER_OFF	   0x08 /* Only for STiH418 */
 #define GAM_MIXER_BCO      0x0C
 #define GAM_MIXER_BCS      0x10
 #define GAM_MIXER_AVO      0x28
 #define GAM_MIXER_AVS      0x2C
+#define GAM_MIXER_CRB2     0x30 /* Only for STiH418 */
 #define GAM_MIXER_CRB      0x34
 #define GAM_MIXER_ACT      0x38
 #define GAM_MIXER_MBP      0x3C
@@ -102,13 +105,22 @@ static void mixer_dbg_ctl(struct seq_file *s, int val)
 		seq_puts(s, "Nothing");
 }
 
-static void mixer_dbg_crb(struct seq_file *s, int val)
+static void mixer_dbg_crb(struct seq_file *s, struct sti_mixer *mixer, u64 val)
 {
 	int i;
+	u32 shift, mask_id;
+
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor")) {
+		shift = 4;
+		mask_id = 0x0f;
+	} else {
+		shift = 3;
+		mask_id = 0x07;
+	}
 
 	seq_puts(s, "\tDepth: ");
 	for (i = 0; i < GAM_MIXER_NB_DEPTH_LEVEL; i++) {
-		switch (val & GAM_DEPTH_MASK_ID) {
+		switch (val & mask_id) {
 		case GAM_DEPTH_VID0_ID:
 			seq_puts(s, "VID0");
 			break;
@@ -133,7 +145,7 @@ static void mixer_dbg_crb(struct seq_file *s, int val)
 
 		if (i < GAM_MIXER_NB_DEPTH_LEVEL - 1)
 			seq_puts(s, " < ");
-		val = val >> 3;
+		val = val >> shift;
 	}
 }
 
@@ -149,6 +161,7 @@ static int mixer_dbg_show(struct seq_file *s, void *arg)
 {
 	struct drm_info_node *node = s->private;
 	struct sti_mixer *mixer = (struct sti_mixer *)node->info_ent->data;
+	u64 val;
 
 	seq_printf(s, "%s: (vaddr = 0x%p)",
 		   sti_mixer_to_str(mixer), mixer->regs);
@@ -161,11 +174,18 @@ static int mixer_dbg_show(struct seq_file *s, void *arg)
 	DBGFS_DUMP(GAM_MIXER_AVO);
 	DBGFS_DUMP(GAM_MIXER_AVS);
 	DBGFS_DUMP(GAM_MIXER_CRB);
-	mixer_dbg_crb(s, sti_mixer_reg_read(mixer, GAM_MIXER_CRB));
+	val = sti_mixer_reg_read(mixer, GAM_MIXER_CRB);
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor")) {
+		DBGFS_DUMP(GAM_MIXER_CRB2);
+		val |= ((u64)sti_mixer_reg_read(mixer, GAM_MIXER_CRB2) << 32);
+	}
+	mixer_dbg_crb(s, mixer, val);
 	DBGFS_DUMP(GAM_MIXER_ACT);
-	DBGFS_DUMP(GAM_MIXER_MBP);
-	DBGFS_DUMP(GAM_MIXER_MX0);
-	mixer_dbg_mxn(s, mixer->regs + GAM_MIXER_MX0);
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih407-compositor")) {
+		DBGFS_DUMP(GAM_MIXER_MBP);
+		DBGFS_DUMP(GAM_MIXER_MX0);
+		mixer_dbg_mxn(s, mixer->regs + GAM_MIXER_MX0);
+	}
 	seq_putc(s, '\n');
 	return 0;
 }
@@ -238,7 +258,16 @@ int sti_mixer_set_plane_depth(struct sti_mixer *mixer, struct sti_plane *plane)
 {
 	int plane_id, depth = plane->drm_plane.state->normalized_zpos;
 	unsigned int i;
-	u32 mask, val;
+	u64 mask, val;
+	u32 shift, mask_id;
+
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor")) {
+		shift = 4;
+		mask_id = 0x0f;
+	} else {
+		shift = 3;
+		mask_id = 0x07;
+	}
 
 	switch (plane->desc) {
 	case STI_GDP_0:
@@ -266,26 +295,37 @@ int sti_mixer_set_plane_depth(struct sti_mixer *mixer, struct sti_plane *plane)
 
 	/* Search if a previous depth was already assigned to the plane */
 	val = sti_mixer_reg_read(mixer, GAM_MIXER_CRB);
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor"))
+		val |= ((u64)sti_mixer_reg_read(mixer, GAM_MIXER_CRB2) << 32);
 	for (i = 0; i < GAM_MIXER_NB_DEPTH_LEVEL; i++) {
-		mask = GAM_DEPTH_MASK_ID << (3 * i);
-		if ((val & mask) == plane_id << (3 * i))
+		mask = mask_id << (shift * i);
+		if ((val & mask) == plane_id << (shift * i))
 			break;
 	}
 
-	mask |= GAM_DEPTH_MASK_ID << (3 * depth);
-	plane_id = plane_id << (3 * depth);
+	mask |= mask_id << (shift * depth);
+	plane_id = plane_id << (shift * depth);
 
 	DRM_DEBUG_DRIVER("%s %s depth=%d\n", sti_mixer_to_str(mixer),
 			 sti_plane_to_str(plane), depth);
 	dev_dbg(mixer->dev, "GAM_MIXER_CRB val 0x%x mask 0x%x\n",
-		plane_id, mask);
+		plane_id, (u32)(mask & 0xffffffff));
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor"))
+		dev_dbg(mixer->dev, "GAM_MIXER_CRB2 val 0x%x mask 0x%x\n",
+			plane_id, (u32)(mask >> 32));
 
 	val &= ~mask;
 	val |= plane_id;
-	sti_mixer_reg_write(mixer, GAM_MIXER_CRB, val);
+	sti_mixer_reg_write(mixer, GAM_MIXER_CRB, val & 0xffffffff);
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor"))
+		sti_mixer_reg_write(mixer, GAM_MIXER_CRB2, val >> 32);
 
 	dev_dbg(mixer->dev, "Read GAM_MIXER_CRB 0x%x\n",
 		sti_mixer_reg_read(mixer, GAM_MIXER_CRB));
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor"))
+		dev_dbg(mixer->dev, "Read GAM_MIXER_CRB2 0x%x\n",
+			sti_mixer_reg_read(mixer, GAM_MIXER_CRB2));
+
 	return 0;
 }
 
@@ -352,6 +392,9 @@ int sti_mixer_set_plane_status(struct sti_mixer *mixer,
 	val |= status ? mask : 0;
 	sti_mixer_reg_write(mixer, GAM_MIXER_CTL, val);
 
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor"))
+		sti_mixer_reg_write(mixer, GAM_MIXER_OFF, 0x02);
+
 	return 0;
 }
 
-- 
2.48.1

From 16b736061c50a1ddb17533044f6bfba1e4f8934c Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 27 Jul 2023 21:51:29 +0000
Subject: [PATCH 57/72] drm/sti: add support for stih418 in tvout

The tvout for stih407 and stih418 differ in the connection with the
vtg regarding to the hdmi output.  In order to cop with that, introduce
a new compatible st,stih418-tvout in order to have the hdmi_sync_id
being part of the data attached to each compatible.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/sti_tvout.c | 35 +++++++++++++++++++++++++--------
 1 file changed, 27 insertions(+), 8 deletions(-)

diff --git a/drivers/gpu/drm/sti/sti_tvout.c b/drivers/gpu/drm/sti/sti_tvout.c
index af6c06f448c4..8406ce5a2e6e 100644
--- a/drivers/gpu/drm/sti/sti_tvout.c
+++ b/drivers/gpu/drm/sti/sti_tvout.c
@@ -118,6 +118,7 @@ struct sti_tvout {
 	struct drm_encoder *hda;
 	struct drm_encoder *dvo;
 	bool debugfs_registered;
+	unsigned int hdmi_sync_id;
 };
 
 struct sti_tvout_encoder {
@@ -130,6 +131,10 @@ struct sti_tvout_encoder {
 
 #define to_sti_tvout(x) to_sti_tvout_encoder(x)->tvout
 
+struct sti_tvout_data {
+	unsigned int hdmi_sync_id;
+};
+
 /* preformatter conversion matrix */
 static const u32 rgb_to_ycbcr_601[8] = {
 	0xF927082E, 0x04C9FEAB, 0x01D30964, 0xFA95FD3D,
@@ -359,14 +364,14 @@ static void tvout_hdmi_start(struct sti_tvout *tvout, bool main_path)
 		DRM_DEBUG_DRIVER("main vip for hdmi\n");
 		/* select the input sync for hdmi */
 		tvout_write(tvout,
-			    TVO_SYNC_MAIN_VTG_SET_REF | VTG_SYNC_ID_HDMI,
+			    TVO_SYNC_MAIN_VTG_SET_REF | tvout->hdmi_sync_id,
 			    TVO_HDMI_SYNC_SEL);
 		tvo_in_vid_format = TVO_MAIN_IN_VID_FORMAT;
 	} else {
 		DRM_DEBUG_DRIVER("aux vip for hdmi\n");
 		/* select the input sync for hdmi */
 		tvout_write(tvout,
-			    TVO_SYNC_AUX_VTG_SET_REF | VTG_SYNC_ID_HDMI,
+			    TVO_SYNC_AUX_VTG_SET_REF | tvout->hdmi_sync_id,
 			    TVO_HDMI_SYNC_SEL);
 		tvo_in_vid_format = TVO_AUX_IN_VID_FORMAT;
 	}
@@ -833,10 +838,26 @@ static const struct component_ops sti_tvout_ops = {
 	.unbind	= sti_tvout_unbind,
 };
 
+static const struct sti_tvout_data stih407_tvout_data = {
+	.hdmi_sync_id = 1,
+};
+
+static const struct sti_tvout_data stih418_tvout_data = {
+	.hdmi_sync_id = 5,
+};
+
+static const struct of_device_id tvout_of_match[] = {
+	{ .compatible = "st,stih407-tvout", .data = &stih407_tvout_data, },
+	{ .compatible = "st,stih418-tvout", .data = &stih418_tvout_data, },
+	{ /* end node */ }
+};
+MODULE_DEVICE_TABLE(of, tvout_of_match);
+
 static int sti_tvout_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct device_node *node = dev->of_node;
+	const struct sti_tvout_data *data;
 	struct sti_tvout *tvout;
 	struct resource *res;
 
@@ -851,6 +872,10 @@ static int sti_tvout_probe(struct platform_device *pdev)
 
 	tvout->dev = dev;
 
+	/* populate data structure depending on compatibility */
+	data = of_match_node(tvout_of_match, node)->data;
+	tvout->hdmi_sync_id = data->hdmi_sync_id;
+
 	/* get memory resources */
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "tvout-reg");
 	if (!res) {
@@ -877,12 +902,6 @@ static void sti_tvout_remove(struct platform_device *pdev)
 	component_del(&pdev->dev, &sti_tvout_ops);
 }
 
-static const struct of_device_id tvout_of_match[] = {
-	{ .compatible = "st,stih407-tvout", },
-	{ /* end node */ }
-};
-MODULE_DEVICE_TABLE(of, tvout_of_match);
-
 struct platform_driver sti_tvout_driver = {
 	.driver = {
 		.name = "sti-tvout",
-- 
2.48.1

From 9b5a4104b52f2a765572e458b7f6338a2cc93a01 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 27 Jul 2023 21:51:30 +0000
Subject: [PATCH 58/72] drm/sti: remove VTG_SYNC_ID_HDMI from sti_vtg.h

Since the synchro signal used for hdmi output and coming from the
VTG differs between the stih407 and stih418 platforms, we cannot
rely anymore on hardcoded value and involve drivers use compatible
to figure out the value.
The macro VTG_SYNC_ID_HDMI can thus be removed.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/sti_vtg.h | 1 -
 1 file changed, 1 deletion(-)

diff --git a/drivers/gpu/drm/sti/sti_vtg.h b/drivers/gpu/drm/sti/sti_vtg.h
index 46faf141b2d9..bd0437bd1c8d 100644
--- a/drivers/gpu/drm/sti/sti_vtg.h
+++ b/drivers/gpu/drm/sti/sti_vtg.h
@@ -10,7 +10,6 @@
 #define VTG_TOP_FIELD_EVENT     1
 #define VTG_BOTTOM_FIELD_EVENT  2
 
-#define VTG_SYNC_ID_HDMI        1
 #define VTG_SYNC_ID_HDDCS       2
 #define VTG_SYNC_ID_HDF         3
 #define VTG_SYNC_ID_DVO         4
-- 
2.48.1

From 4bdfc53d20f52021a470fe0d2eb169207a59624c Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 27 Jul 2023 21:51:31 +0000
Subject: [PATCH 59/72] drm/sti: add more possible GDP / VID planes entries in
 sti_plane

In order to address the STiH418, add more entries in sti_plane

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/sti_plane.c | 8 ++++++++
 drivers/gpu/drm/sti/sti_plane.h | 8 +++++++-
 2 files changed, 15 insertions(+), 1 deletion(-)

diff --git a/drivers/gpu/drm/sti/sti_plane.c b/drivers/gpu/drm/sti/sti_plane.c
index 29e669ccec5b..f8d65d608b64 100644
--- a/drivers/gpu/drm/sti/sti_plane.c
+++ b/drivers/gpu/drm/sti/sti_plane.c
@@ -28,8 +28,16 @@ const char *sti_plane_to_str(struct sti_plane *plane)
 		return "GDP2";
 	case STI_GDP_3:
 		return "GDP3";
+	case STI_GDP_4:
+		return "GDP4";
+	case STI_GDP_5:
+		return "GDP5";
 	case STI_HQVDP_0:
 		return "HQVDP0";
+	case STI_HQVDP_1:
+		return "HQVDP1";
+	case STI_HQVDP_2:
+		return "HQVDP2";
 	case STI_CURSOR:
 		return "CURSOR";
 	default:
diff --git a/drivers/gpu/drm/sti/sti_plane.h b/drivers/gpu/drm/sti/sti_plane.h
index 2c0156bede9c..51fc25ed0287 100644
--- a/drivers/gpu/drm/sti/sti_plane.h
+++ b/drivers/gpu/drm/sti/sti_plane.h
@@ -25,7 +25,9 @@ enum sti_plane_id_of_type {
 	STI_ID_0 = 0,
 	STI_ID_1 = 1,
 	STI_ID_2 = 2,
-	STI_ID_3 = 3
+	STI_ID_3 = 3,
+	STI_ID_4 = 4,
+	STI_ID_5 = 5,
 };
 
 enum sti_plane_desc {
@@ -33,7 +35,11 @@ enum sti_plane_desc {
 	STI_GDP_1       = STI_GDP | STI_ID_1,
 	STI_GDP_2       = STI_GDP | STI_ID_2,
 	STI_GDP_3       = STI_GDP | STI_ID_3,
+	STI_GDP_4       = STI_GDP | STI_ID_4,
+	STI_GDP_5       = STI_GDP | STI_ID_5,
 	STI_HQVDP_0     = STI_VDP | STI_ID_0,
+	STI_HQVDP_1     = STI_VDP | STI_ID_1,
+	STI_HQVDP_2     = STI_VDP | STI_ID_2,
 	STI_CURSOR      = STI_CUR,
 	STI_BACK        = STI_BCK
 };
-- 
2.48.1

From ac4154761a998ff5c69c0771a7495ae6d741a89e Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 27 Jul 2023 21:51:32 +0000
Subject: [PATCH 60/72] drm/sti: add more planes supports in sti_mixer

On STiH418, the mixer is able to driver more layers of
planes.  For this purpose, add those new possible entries
and allow it to work in either STiH407 or STiH418 mode.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/sti_mixer.c | 66 ++++++++++++++++++++++++++++-----
 drivers/gpu/drm/sti/sti_mixer.h |  3 +-
 2 files changed, 58 insertions(+), 11 deletions(-)

diff --git a/drivers/gpu/drm/sti/sti_mixer.c b/drivers/gpu/drm/sti/sti_mixer.c
index c01f4f69a211..8d2c8c3a851e 100644
--- a/drivers/gpu/drm/sti/sti_mixer.c
+++ b/drivers/gpu/drm/sti/sti_mixer.c
@@ -42,7 +42,9 @@ module_param_named(bkgcolor, bkg_color, int, 0644);
 #define GAM_DEPTH_GDP1_ID  4
 #define GAM_DEPTH_GDP2_ID  5
 #define GAM_DEPTH_GDP3_ID  6
-#define GAM_DEPTH_MASK_ID  7
+#define GAM_DEPTH_GDP4_ID  7
+#define GAM_DEPTH_GDP5_ID  8
+#define GAM_DEPTH_VID2_ID  9
 
 /* mask in CTL reg */
 #define GAM_CTL_BACK_MASK  BIT(0)
@@ -52,6 +54,10 @@ module_param_named(bkgcolor, bkg_color, int, 0644);
 #define GAM_CTL_GDP1_MASK  BIT(4)
 #define GAM_CTL_GDP2_MASK  BIT(5)
 #define GAM_CTL_GDP3_MASK  BIT(6)
+#define GAM_CTL_GDP4_MASK  BIT(7)
+#define GAM_CTL_GDP5_MASK  BIT(8)
+/* CURSOR doesn't exist on STiH418 where VID2 exist */
+#define GAM_CTL_VID2_MASK  BIT(9)
 #define GAM_CTL_CURSOR_MASK BIT(9)
 
 const char *sti_mixer_to_str(struct sti_mixer *mixer)
@@ -80,15 +86,16 @@ static inline void sti_mixer_reg_write(struct sti_mixer *mixer,
 #define DBGFS_DUMP(reg) seq_printf(s, "\n  %-25s 0x%08X", #reg, \
 				   sti_mixer_reg_read(mixer, reg))
 
-static void mixer_dbg_ctl(struct seq_file *s, int val)
+static void mixer_dbg_ctl(struct seq_file *s, int val, int depth)
 {
 	unsigned int i;
 	int count = 0;
 	char *const disp_layer[] = {"BKG", "VID0", "VID1", "GDP0",
-				    "GDP1", "GDP2", "GDP3"};
+				    "GDP1", "GDP2", "GDP3", "GDP4",
+				    "GDP5", "VID2"};
 
 	seq_puts(s, "\tEnabled: ");
-	for (i = 0; i < 7; i++) {
+	for (i = 0; i < depth; i++) {
 		if (val & 1) {
 			seq_printf(s, "%s ", disp_layer[i]);
 			count++;
@@ -108,18 +115,20 @@ static void mixer_dbg_ctl(struct seq_file *s, int val)
 static void mixer_dbg_crb(struct seq_file *s, struct sti_mixer *mixer, u64 val)
 {
 	int i;
-	u32 shift, mask_id;
+	u32 shift, mask_id, mixer_depth;
 
 	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor")) {
 		shift = 4;
 		mask_id = 0x0f;
+		mixer_depth = GAM_MIXER_NB_DEPTH_LEVEL_STIH418;
 	} else {
 		shift = 3;
 		mask_id = 0x07;
+		mixer_depth = GAM_MIXER_NB_DEPTH_LEVEL_STIH407;
 	}
 
 	seq_puts(s, "\tDepth: ");
-	for (i = 0; i < GAM_MIXER_NB_DEPTH_LEVEL; i++) {
+	for (i = 0; i < mixer_depth; i++) {
 		switch (val & mask_id) {
 		case GAM_DEPTH_VID0_ID:
 			seq_puts(s, "VID0");
@@ -139,11 +148,20 @@ static void mixer_dbg_crb(struct seq_file *s, struct sti_mixer *mixer, u64 val)
 		case GAM_DEPTH_GDP3_ID:
 			seq_puts(s, "GDP3");
 			break;
+		case GAM_DEPTH_GDP4_ID:
+			seq_puts(s, "GDP4");
+			break;
+		case GAM_DEPTH_GDP5_ID:
+			seq_puts(s, "GDP5");
+			break;
+		case GAM_DEPTH_VID2_ID:
+			seq_puts(s, "VID2");
+			break;
 		default:
 			seq_puts(s, "---");
 		}
 
-		if (i < GAM_MIXER_NB_DEPTH_LEVEL - 1)
+		if (i < mixer_depth - 1)
 			seq_puts(s, " < ");
 		val = val >> shift;
 	}
@@ -161,13 +179,19 @@ static int mixer_dbg_show(struct seq_file *s, void *arg)
 {
 	struct drm_info_node *node = s->private;
 	struct sti_mixer *mixer = (struct sti_mixer *)node->info_ent->data;
+	int depth;
 	u64 val;
 
+	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor"))
+		depth = GAM_MIXER_NB_DEPTH_LEVEL_STIH418 + 1;
+	else
+		depth = GAM_MIXER_NB_DEPTH_LEVEL_STIH407 + 1;
+
 	seq_printf(s, "%s: (vaddr = 0x%p)",
 		   sti_mixer_to_str(mixer), mixer->regs);
 
 	DBGFS_DUMP(GAM_MIXER_CTL);
-	mixer_dbg_ctl(s, sti_mixer_reg_read(mixer, GAM_MIXER_CTL));
+	mixer_dbg_ctl(s, sti_mixer_reg_read(mixer, GAM_MIXER_CTL), depth);
 	DBGFS_DUMP(GAM_MIXER_BKC);
 	DBGFS_DUMP(GAM_MIXER_BCO);
 	DBGFS_DUMP(GAM_MIXER_BCS);
@@ -259,14 +283,16 @@ int sti_mixer_set_plane_depth(struct sti_mixer *mixer, struct sti_plane *plane)
 	int plane_id, depth = plane->drm_plane.state->normalized_zpos;
 	unsigned int i;
 	u64 mask, val;
-	u32 shift, mask_id;
+	u32 shift, mask_id, mixer_depth;
 
 	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor")) {
 		shift = 4;
 		mask_id = 0x0f;
+		mixer_depth = GAM_MIXER_NB_DEPTH_LEVEL_STIH418;
 	} else {
 		shift = 3;
 		mask_id = 0x07;
+		mixer_depth = GAM_MIXER_NB_DEPTH_LEVEL_STIH407;
 	}
 
 	switch (plane->desc) {
@@ -285,6 +311,18 @@ int sti_mixer_set_plane_depth(struct sti_mixer *mixer, struct sti_plane *plane)
 	case STI_HQVDP_0:
 		plane_id = GAM_DEPTH_VID0_ID;
 		break;
+	case STI_HQVDP_1:
+		plane_id = GAM_DEPTH_VID1_ID;
+		break;
+	case STI_GDP_4:
+		plane_id = GAM_DEPTH_GDP4_ID;
+		break;
+	case STI_GDP_5:
+		plane_id = GAM_DEPTH_GDP5_ID;
+		break;
+	case STI_HQVDP_2:
+		plane_id = GAM_DEPTH_VID2_ID;
+		break;
 	case STI_CURSOR:
 		/* no need to set depth for cursor */
 		return 0;
@@ -297,7 +335,7 @@ int sti_mixer_set_plane_depth(struct sti_mixer *mixer, struct sti_plane *plane)
 	val = sti_mixer_reg_read(mixer, GAM_MIXER_CRB);
 	if (of_device_is_compatible(mixer->dev->of_node, "st,stih418-compositor"))
 		val |= ((u64)sti_mixer_reg_read(mixer, GAM_MIXER_CRB2) << 32);
-	for (i = 0; i < GAM_MIXER_NB_DEPTH_LEVEL; i++) {
+	for (i = 0; i < mixer_depth; i++) {
 		mask = mask_id << (shift * i);
 		if ((val & mask) == plane_id << (shift * i))
 			break;
@@ -366,6 +404,14 @@ static u32 sti_mixer_get_plane_mask(struct sti_plane *plane)
 		return GAM_CTL_GDP3_MASK;
 	case STI_HQVDP_0:
 		return GAM_CTL_VID0_MASK;
+	case STI_HQVDP_1:
+		return GAM_CTL_VID1_MASK;
+	case STI_GDP_4:
+		return GAM_CTL_GDP4_MASK;
+	case STI_GDP_5:
+		return GAM_CTL_GDP5_MASK;
+	case STI_HQVDP_2:
+		return GAM_CTL_VID2_MASK;
 	case STI_CURSOR:
 		return GAM_CTL_CURSOR_MASK;
 	default:
diff --git a/drivers/gpu/drm/sti/sti_mixer.h b/drivers/gpu/drm/sti/sti_mixer.h
index ab06beb7b258..1ce7c6b4b4f3 100644
--- a/drivers/gpu/drm/sti/sti_mixer.h
+++ b/drivers/gpu/drm/sti/sti_mixer.h
@@ -61,7 +61,8 @@ void sti_mixer_set_background_status(struct sti_mixer *mixer, bool enable);
 void sti_mixer_debugfs_init(struct sti_mixer *mixer, struct drm_minor *minor);
 
 /* depth in Cross-bar control = z order */
-#define GAM_MIXER_NB_DEPTH_LEVEL 6
+#define GAM_MIXER_NB_DEPTH_LEVEL_STIH407 6
+#define GAM_MIXER_NB_DEPTH_LEVEL_STIH418 9
 
 #define STI_MIXER_MAIN 0
 #define STI_MIXER_AUX  1
-- 
2.48.1

From a981a672eebee85c1eed2492bf7ddf6bcd7c476f Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 27 Jul 2023 21:51:33 +0000
Subject: [PATCH 61/72] drm/sti: add support for GDPPLUS / stih418 GDPs

The STiH418 platform embeds two kinds of graphical planes (GDP),
so called GDPPLUS which has additional (yet unimplemented)
features compared to the GDP, and also the GDP.
Register map of GDPPLUS slightly differ from the GDP even if,
for common functionalities registers name and behavior are the
same (but not at same addresses).  For that purpose, this commit
rework the way of addressing the GDP(PLUS) registers.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/sti_compositor.c |   4 +
 drivers/gpu/drm/sti/sti_compositor.h |   1 +
 drivers/gpu/drm/sti/sti_gdp.c        | 250 ++++++++++++++++-----------
 drivers/gpu/drm/sti/sti_gdp.h        |   8 +-
 4 files changed, 163 insertions(+), 100 deletions(-)

diff --git a/drivers/gpu/drm/sti/sti_compositor.c b/drivers/gpu/drm/sti/sti_compositor.c
index 063f82d23d80..bee528d232f2 100644
--- a/drivers/gpu/drm/sti/sti_compositor.c
+++ b/drivers/gpu/drm/sti/sti_compositor.c
@@ -87,6 +87,7 @@ static int sti_compositor_bind(struct device *dev,
 					     compo->regs + desc[i].offset);
 			break;
 		case STI_GPD_SUBDEV:
+		case STI_GPDPLUS_SUBDEV:
 		case STI_CURSOR_SUBDEV:
 			/* Nothing to do, wait for the second round */
 			break;
@@ -120,7 +121,10 @@ static int sti_compositor_bind(struct device *dev,
 			}
 			break;
 		case STI_GPD_SUBDEV:
+		case STI_GPDPLUS_SUBDEV:
 			primary = sti_gdp_create(drm_dev, compo->dev,
+						 desc[i].type == STI_GPD_SUBDEV ?
+						 STI_GDP_TYPE_GDP : STI_GDP_TYPE_GDPPLUS,
 						 desc[i].id,
 						 compo->regs + desc[i].offset,
 						 (1 << mixer_id) - 1,
diff --git a/drivers/gpu/drm/sti/sti_compositor.h b/drivers/gpu/drm/sti/sti_compositor.h
index 25bb01bdd013..62545210b96d 100644
--- a/drivers/gpu/drm/sti/sti_compositor.h
+++ b/drivers/gpu/drm/sti/sti_compositor.h
@@ -24,6 +24,7 @@ enum sti_compositor_subdev_type {
 	STI_MIXER_MAIN_SUBDEV,
 	STI_MIXER_AUX_SUBDEV,
 	STI_GPD_SUBDEV,
+	STI_GPDPLUS_SUBDEV,
 	STI_VID_SUBDEV,
 	STI_CURSOR_SUBDEV,
 };
diff --git a/drivers/gpu/drm/sti/sti_gdp.c b/drivers/gpu/drm/sti/sti_gdp.c
index f046f5f7ad25..d412d97ef164 100644
--- a/drivers/gpu/drm/sti/sti_gdp.c
+++ b/drivers/gpu/drm/sti/sti_gdp.c
@@ -55,6 +55,7 @@ static struct gdp_format_to_str {
 		GDP2STR(ARGB4444)
 		};
 
+/* GDP register offsets */
 #define GAM_GDP_CTL_OFFSET      0x00
 #define GAM_GDP_AGC_OFFSET      0x04
 #define GAM_GDP_VPO_OFFSET      0x0C
@@ -67,8 +68,45 @@ static struct gdp_format_to_str {
 #define GAM_GDP_KEY2_OFFSET     0x2C
 #define GAM_GDP_PPT_OFFSET      0x34
 #define GAM_GDP_CML_OFFSET      0x3C
+#define GAM_GDP_NODE_SIZE	0x40
 #define GAM_GDP_MST_OFFSET      0x68
 
+/* GDPPLUS register offsets */
+#define	GAM_GDPPLUS_CTL_OFFSET	0x00
+#define	GAM_GDPPLUS_AGC_OFFSET	0x04
+#define	GAM_GDPPLUS_VPO_OFFSET	0x08
+#define	GAM_GDPPLUS_VPS_OFFSET	0x0C
+#define	GAM_GDPPLUS_PML_OFFSET	0x10
+#define	GAM_GDPPLUS_PMP_OFFSET	0x14
+#define	GAM_GDPPLUS_SIZE_OFFSET	0x18
+#define	GAM_GDPPLUS_NVN_OFFSET	0x1C
+#define	GAM_GDPPLUS_KEY1_OFFSET	0x20
+#define	GAM_GDPPLUS_KEY2_OFFSET	0x24
+#define	GAM_GDPPLUS_HFP_OFFSET	0x28
+#define	GAM_GDPPLUS_PPT_OFFSET	0x2C
+#define	GAM_GDPPLUS_VFP_OFFSET	0x30
+#define	GAM_GDPPLUS_CML_OFFSET	0x34
+#define	GAM_GDPPLUS_CROP_OFFSET	0x38
+#define	GAM_GDPPLUS_BT0_OFFSET	0x3C
+#define	GAM_GDPPLUS_BT1_OFFSET	0x40
+#define	GAM_GDPPLUS_BT2_OFFSET	0x44
+#define	GAM_GDPPLUS_BT3_OFFSET	0x48
+#define	GAM_GDPPLUS_BT4_OFFSET	0x4C
+#define	GAM_GDPPLUS_HSRC_OFFSET	0x50
+#define	GAM_GDPPLUS_HIP_OFFSET	0x54
+#define	GAM_GDPPLUS_HP1_OFFSET	0x58
+#define	GAM_GDPPLUS_HP2_OFFSET	0x5C
+#define	GAM_GDPPLUS_VSRC_OFFSET	0x60
+#define	GAM_GDPPLUS_VIP_OFFSET	0x64
+#define	GAM_GDPPLUS_VP1_OFFSET	0x68
+#define	GAM_GDPPLUS_VP2_OFFSET	0x6C
+#define GAM_GDPPLUS_NODE_SIZE	0x500
+
+/* Accessor for common registers */
+#define GAM_OFFSET(reg, type)	((type) == STI_GDP_TYPE_GDP ? GAM_GDP_ ## reg ## _OFFSET :\
+				 GAM_GDPPLUS_ ## reg ## _OFFSET)
+#define GAM_OFFSET_U32(reg, type)	(GAM_OFFSET(reg, type) >> 2)
+
 #define GAM_GDP_ALPHARANGE_255  BIT(5)
 #define GAM_GDP_AGC_FULL_RANGE  0x00808080
 #define GAM_GDP_PPT_IGNORE      (BIT(1) | BIT(0))
@@ -79,29 +117,10 @@ static struct gdp_format_to_str {
 #define GDP_NODE_NB_BANK        2
 #define GDP_NODE_PER_FIELD      2
 
-struct sti_gdp_node {
-	u32 gam_gdp_ctl;
-	u32 gam_gdp_agc;
-	u32 reserved1;
-	u32 gam_gdp_vpo;
-	u32 gam_gdp_vps;
-	u32 gam_gdp_pml;
-	u32 gam_gdp_pmp;
-	u32 gam_gdp_size;
-	u32 reserved2;
-	u32 gam_gdp_nvn;
-	u32 gam_gdp_key1;
-	u32 gam_gdp_key2;
-	u32 reserved3;
-	u32 gam_gdp_ppt;
-	u32 reserved4;
-	u32 gam_gdp_cml;
-};
-
 struct sti_gdp_node_list {
-	struct sti_gdp_node *top_field;
+	u32 *top_field;
 	dma_addr_t top_field_paddr;
-	struct sti_gdp_node *btm_field;
+	u32 *btm_field;
 	dma_addr_t btm_field_paddr;
 };
 
@@ -130,6 +149,7 @@ struct sti_gdp {
 	bool is_curr_top;
 	struct sti_gdp_node_list node_list[GDP_NODE_NB_BANK];
 	struct sti_vtg *vtg;
+	enum sti_gdp_type type;
 };
 
 #define to_sti_gdp(x) container_of(x, struct sti_gdp, plane)
@@ -145,8 +165,8 @@ static const uint32_t gdp_supported_formats[] = {
 	DRM_FORMAT_RGB888,
 };
 
-#define DBGFS_DUMP(reg) seq_printf(s, "\n  %-25s 0x%08X", #reg, \
-				   readl(gdp->regs + reg ## _OFFSET))
+#define DBGFS_DUMP(reg, offset) seq_printf(s, "\n  %-25s 0x%08X", #reg, \
+					   readl(gdp->regs + (offset)))
 
 static void gdp_dbg_ctl(struct seq_file *s, int val)
 {
@@ -216,6 +236,7 @@ static int gdp_dbg_show(struct seq_file *s, void *data)
 {
 	struct drm_info_node *node = s->private;
 	struct sti_gdp *gdp = (struct sti_gdp *)node->info_ent->data;
+	struct device_node *np = gdp->dev->of_node;
 	struct drm_plane *drm_plane = &gdp->plane.drm_plane;
 	struct drm_crtc *crtc;
 
@@ -226,26 +247,28 @@ static int gdp_dbg_show(struct seq_file *s, void *data)
 	seq_printf(s, "%s: (vaddr = 0x%p)",
 		   sti_plane_to_str(&gdp->plane), gdp->regs);
 
-	DBGFS_DUMP(GAM_GDP_CTL);
-	gdp_dbg_ctl(s, readl(gdp->regs + GAM_GDP_CTL_OFFSET));
-	DBGFS_DUMP(GAM_GDP_AGC);
-	DBGFS_DUMP(GAM_GDP_VPO);
-	gdp_dbg_vpo(s, readl(gdp->regs + GAM_GDP_VPO_OFFSET));
-	DBGFS_DUMP(GAM_GDP_VPS);
-	gdp_dbg_vps(s, readl(gdp->regs + GAM_GDP_VPS_OFFSET));
-	DBGFS_DUMP(GAM_GDP_PML);
-	DBGFS_DUMP(GAM_GDP_PMP);
-	DBGFS_DUMP(GAM_GDP_SIZE);
-	gdp_dbg_size(s, readl(gdp->regs + GAM_GDP_SIZE_OFFSET));
-	DBGFS_DUMP(GAM_GDP_NVN);
-	gdp_dbg_nvn(s, gdp, readl(gdp->regs + GAM_GDP_NVN_OFFSET));
-	DBGFS_DUMP(GAM_GDP_KEY1);
-	DBGFS_DUMP(GAM_GDP_KEY2);
-	DBGFS_DUMP(GAM_GDP_PPT);
-	gdp_dbg_ppt(s, readl(gdp->regs + GAM_GDP_PPT_OFFSET));
-	DBGFS_DUMP(GAM_GDP_CML);
-	DBGFS_DUMP(GAM_GDP_MST);
-	gdp_dbg_mst(s, readl(gdp->regs + GAM_GDP_MST_OFFSET));
+	DBGFS_DUMP(CTL, GAM_OFFSET(CTL, gdp->type));
+	gdp_dbg_ctl(s, readl(gdp->regs + GAM_OFFSET(CTL, gdp->type)));
+	DBGFS_DUMP(AGC, GAM_OFFSET(AGC, gdp->type));
+	DBGFS_DUMP(VPO, GAM_OFFSET(VPO, gdp->type));
+	gdp_dbg_vpo(s, readl(gdp->regs + GAM_OFFSET(VPO, gdp->type)));
+	DBGFS_DUMP(VPS, GAM_OFFSET(VPS, gdp->type));
+	gdp_dbg_vps(s, readl(gdp->regs + GAM_OFFSET(VPS, gdp->type)));
+	DBGFS_DUMP(PML, GAM_OFFSET(PML, gdp->type));
+	DBGFS_DUMP(PMP, GAM_OFFSET(PMP, gdp->type));
+	DBGFS_DUMP(SIZE, GAM_OFFSET(SIZE, gdp->type));
+	gdp_dbg_size(s, readl(gdp->regs + GAM_OFFSET(SIZE, gdp->type)));
+	DBGFS_DUMP(NVN, GAM_OFFSET(NVN, gdp->type));
+	gdp_dbg_nvn(s, gdp, readl(gdp->regs + GAM_OFFSET(NVN, gdp->type)));
+	DBGFS_DUMP(KEY1, GAM_OFFSET(KEY1, gdp->type));
+	DBGFS_DUMP(KEY2, GAM_OFFSET(KEY2, gdp->type));
+	DBGFS_DUMP(PPT, GAM_OFFSET(PPT, gdp->type));
+	gdp_dbg_ppt(s, readl(gdp->regs + GAM_OFFSET(PPT, gdp->type)));
+	DBGFS_DUMP(CML, GAM_OFFSET(CML, gdp->type));
+	if (of_device_is_compatible(np, "st,stih407-compositor")) {
+		DBGFS_DUMP(MST, GAM_GDP_MST_OFFSET);
+		gdp_dbg_mst(s, readl(gdp->regs + GAM_GDP_MST_OFFSET));
+	}
 
 	seq_puts(s, "\n\n");
 	if (!crtc)
@@ -257,26 +280,26 @@ static int gdp_dbg_show(struct seq_file *s, void *data)
 	return 0;
 }
 
-static void gdp_node_dump_node(struct seq_file *s, struct sti_gdp_node *node)
+static void gdp_node_dump_node(struct seq_file *s, u32 *node, enum sti_gdp_type type)
 {
 	seq_printf(s, "\t@:0x%p", node);
-	seq_printf(s, "\n\tCTL  0x%08X", node->gam_gdp_ctl);
-	gdp_dbg_ctl(s, node->gam_gdp_ctl);
-	seq_printf(s, "\n\tAGC  0x%08X", node->gam_gdp_agc);
-	seq_printf(s, "\n\tVPO  0x%08X", node->gam_gdp_vpo);
-	gdp_dbg_vpo(s, node->gam_gdp_vpo);
-	seq_printf(s, "\n\tVPS  0x%08X", node->gam_gdp_vps);
-	gdp_dbg_vps(s, node->gam_gdp_vps);
-	seq_printf(s, "\n\tPML  0x%08X", node->gam_gdp_pml);
-	seq_printf(s, "\n\tPMP  0x%08X", node->gam_gdp_pmp);
-	seq_printf(s, "\n\tSIZE 0x%08X", node->gam_gdp_size);
-	gdp_dbg_size(s, node->gam_gdp_size);
-	seq_printf(s, "\n\tNVN  0x%08X", node->gam_gdp_nvn);
-	seq_printf(s, "\n\tKEY1 0x%08X", node->gam_gdp_key1);
-	seq_printf(s, "\n\tKEY2 0x%08X", node->gam_gdp_key2);
-	seq_printf(s, "\n\tPPT  0x%08X", node->gam_gdp_ppt);
-	gdp_dbg_ppt(s, node->gam_gdp_ppt);
-	seq_printf(s, "\n\tCML  0x%08X\n", node->gam_gdp_cml);
+	seq_printf(s, "\n\tCTL  0x%08X", node[GAM_OFFSET_U32(CTL, type)]);
+	gdp_dbg_ctl(s, node[GAM_OFFSET_U32(CTL, type)]);
+	seq_printf(s, "\n\tAGC  0x%08X", node[GAM_OFFSET_U32(AGC, type)]);
+	seq_printf(s, "\n\tVPO  0x%08X", node[GAM_OFFSET_U32(VPO, type)]);
+	gdp_dbg_vpo(s, node[GAM_OFFSET_U32(VPO, type)]);
+	seq_printf(s, "\n\tVPS  0x%08X", node[GAM_OFFSET_U32(VPS, type)]);
+	gdp_dbg_vps(s, node[GAM_OFFSET_U32(VPS, type)]);
+	seq_printf(s, "\n\tPML  0x%08X", node[GAM_OFFSET_U32(PML, type)]);
+	seq_printf(s, "\n\tPMP  0x%08X", node[GAM_OFFSET_U32(PMP, type)]);
+	seq_printf(s, "\n\tSIZE 0x%08X", node[GAM_OFFSET_U32(SIZE, type)]);
+	gdp_dbg_size(s, node[GAM_OFFSET_U32(SIZE, type)]);
+	seq_printf(s, "\n\tNVN  0x%08X", node[GAM_OFFSET_U32(NVN, type)]);
+	seq_printf(s, "\n\tKEY1 0x%08X", node[GAM_OFFSET_U32(KEY1, type)]);
+	seq_printf(s, "\n\tKEY2 0x%08X", node[GAM_OFFSET_U32(KEY2, type)]);
+	seq_printf(s, "\n\tPPT  0x%08X", node[GAM_OFFSET_U32(PPT, type)]);
+	gdp_dbg_ppt(s, node[GAM_OFFSET_U32(PPT, type)]);
+	seq_printf(s, "\n\tCML  0x%08X\n", node[GAM_OFFSET_U32(CML, type)]);
 }
 
 static int gdp_node_dbg_show(struct seq_file *s, void *arg)
@@ -287,9 +310,9 @@ static int gdp_node_dbg_show(struct seq_file *s, void *arg)
 
 	for (b = 0; b < GDP_NODE_NB_BANK; b++) {
 		seq_printf(s, "\n%s[%d].top", sti_plane_to_str(&gdp->plane), b);
-		gdp_node_dump_node(s, gdp->node_list[b].top_field);
+		gdp_node_dump_node(s, gdp->node_list[b].top_field, gdp->type);
 		seq_printf(s, "\n%s[%d].btm", sti_plane_to_str(&gdp->plane), b);
-		gdp_node_dump_node(s, gdp->node_list[b].btm_field);
+		gdp_node_dump_node(s, gdp->node_list[b].btm_field, gdp->type);
 	}
 
 	return 0;
@@ -315,6 +338,16 @@ static struct drm_info_list gdp3_debugfs_files[] = {
 	{ "gdp3_node", gdp_node_dbg_show, 0, NULL },
 };
 
+static struct drm_info_list gdp4_debugfs_files[] = {
+	{ "gdp4", gdp_dbg_show, 0, NULL },
+	{ "gdp4_node", gdp_node_dbg_show, 0, NULL },
+};
+
+static struct drm_info_list gdp5_debugfs_files[] = {
+	{ "gdp5", gdp_dbg_show, 0, NULL },
+	{ "gdp5_node", gdp_node_dbg_show, 0, NULL },
+};
+
 static int gdp_debugfs_init(struct sti_gdp *gdp, struct drm_minor *minor)
 {
 	unsigned int i;
@@ -338,6 +371,14 @@ static int gdp_debugfs_init(struct sti_gdp *gdp, struct drm_minor *minor)
 		gdp_debugfs_files = gdp3_debugfs_files;
 		nb_files = ARRAY_SIZE(gdp3_debugfs_files);
 		break;
+	case STI_GDP_4:
+		gdp_debugfs_files = gdp4_debugfs_files;
+		nb_files = ARRAY_SIZE(gdp4_debugfs_files);
+		break;
+	case STI_GDP_5:
+		gdp_debugfs_files = gdp5_debugfs_files;
+		nb_files = ARRAY_SIZE(gdp5_debugfs_files);
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -397,9 +438,10 @@ static int sti_gdp_get_alpharange(int format)
 static struct sti_gdp_node_list *sti_gdp_get_free_nodes(struct sti_gdp *gdp)
 {
 	int hw_nvn;
+	u32 nvn_off = GAM_OFFSET(NVN, gdp->type);
 	unsigned int i;
 
-	hw_nvn = readl(gdp->regs + GAM_GDP_NVN_OFFSET);
+	hw_nvn = readl(gdp->regs + nvn_off);
 	if (!hw_nvn)
 		goto end;
 
@@ -429,9 +471,10 @@ static
 struct sti_gdp_node_list *sti_gdp_get_current_nodes(struct sti_gdp *gdp)
 {
 	int hw_nvn;
+	u32 nvn_off = GAM_OFFSET(NVN, gdp->type);
 	unsigned int i;
 
-	hw_nvn = readl(gdp->regs + GAM_GDP_NVN_OFFSET);
+	hw_nvn = readl(gdp->regs + nvn_off);
 	if (!hw_nvn)
 		goto end;
 
@@ -456,13 +499,14 @@ struct sti_gdp_node_list *sti_gdp_get_current_nodes(struct sti_gdp *gdp)
 static void sti_gdp_disable(struct sti_gdp *gdp)
 {
 	unsigned int i;
+	u32 ppt_off = GAM_OFFSET_U32(PPT, gdp->type);
 
 	DRM_DEBUG_DRIVER("%s\n", sti_plane_to_str(&gdp->plane));
 
 	/* Set the nodes as 'to be ignored on mixer' */
 	for (i = 0; i < GDP_NODE_NB_BANK; i++) {
-		gdp->node_list[i].top_field->gam_gdp_ppt |= GAM_GDP_PPT_IGNORE;
-		gdp->node_list[i].btm_field->gam_gdp_ppt |= GAM_GDP_PPT_IGNORE;
+		gdp->node_list[i].top_field[ppt_off] |= GAM_GDP_PPT_IGNORE;
+		gdp->node_list[i].btm_field[ppt_off] |= GAM_GDP_PPT_IGNORE;
 	}
 
 	if (sti_vtg_unregister_client(gdp->vtg, &gdp->vtg_field_nb))
@@ -519,11 +563,16 @@ static void sti_gdp_init(struct sti_gdp *gdp)
 	struct device_node *np = gdp->dev->of_node;
 	dma_addr_t dma_addr;
 	void *base;
-	unsigned int i, size;
+	unsigned int i, size, gdp_node_size;
+
+	/* Check the type of GDP */
+	if (gdp->type == STI_GDP_TYPE_GDP)
+		gdp_node_size = GAM_GDP_NODE_SIZE;
+	else
+		gdp_node_size = GAM_GDPPLUS_NODE_SIZE;
 
 	/* Allocate all the nodes within a single memory page */
-	size = sizeof(struct sti_gdp_node) *
-	    GDP_NODE_PER_FIELD * GDP_NODE_NB_BANK;
+	size = gdp_node_size * GDP_NODE_PER_FIELD * GDP_NODE_NB_BANK;
 	base = dma_alloc_wc(gdp->dev, size, &dma_addr, GFP_KERNEL);
 
 	if (!base) {
@@ -541,8 +590,8 @@ static void sti_gdp_init(struct sti_gdp *gdp)
 		gdp->node_list[i].top_field_paddr = dma_addr;
 
 		DRM_DEBUG_DRIVER("node[%d].top_field=%p\n", i, base);
-		base += sizeof(struct sti_gdp_node);
-		dma_addr += sizeof(struct sti_gdp_node);
+		base += gdp_node_size;
+		dma_addr += gdp_node_size;
 
 		if (dma_addr & 0xF) {
 			DRM_ERROR("Mem alignment failed\n");
@@ -551,8 +600,8 @@ static void sti_gdp_init(struct sti_gdp *gdp)
 		gdp->node_list[i].btm_field = base;
 		gdp->node_list[i].btm_field_paddr = dma_addr;
 		DRM_DEBUG_DRIVER("node[%d].btm_field=%p\n", i, base);
-		base += sizeof(struct sti_gdp_node);
-		dma_addr += sizeof(struct sti_gdp_node);
+		base += gdp_node_size;
+		dma_addr += gdp_node_size;
 	}
 
 	if (of_device_is_compatible(np, "st,stih407-compositor")) {
@@ -720,7 +769,7 @@ static void sti_gdp_atomic_update(struct drm_plane *drm_plane,
 	struct drm_gem_dma_object *dma_obj;
 	struct sti_gdp_node_list *list;
 	struct sti_gdp_node_list *curr_list;
-	struct sti_gdp_node *top_field, *btm_field;
+	u32 *top_field, *btm_field;
 	u32 dma_updated_top;
 	u32 dma_updated_btm;
 	int format;
@@ -774,12 +823,12 @@ static void sti_gdp_atomic_update(struct drm_plane *drm_plane,
 		sti_plane_to_str(plane), top_field, btm_field);
 
 	/* build the top field */
-	top_field->gam_gdp_agc = GAM_GDP_AGC_FULL_RANGE;
-	top_field->gam_gdp_ctl = WAIT_NEXT_VSYNC;
+	top_field[GAM_OFFSET_U32(AGC, gdp->type)] = GAM_GDP_AGC_FULL_RANGE;
+	top_field[GAM_OFFSET_U32(CTL, gdp->type)] = WAIT_NEXT_VSYNC;
 	format = sti_gdp_fourcc2format(fb->format->format);
-	top_field->gam_gdp_ctl |= format;
-	top_field->gam_gdp_ctl |= sti_gdp_get_alpharange(format);
-	top_field->gam_gdp_ppt &= ~GAM_GDP_PPT_IGNORE;
+	top_field[GAM_OFFSET_U32(CTL, gdp->type)] |= format;
+	top_field[GAM_OFFSET_U32(CTL, gdp->type)] |= sti_gdp_get_alpharange(format);
+	top_field[GAM_OFFSET_U32(PPT, gdp->type)] &= ~GAM_GDP_PPT_IGNORE;
 
 	dma_obj = drm_fb_dma_get_gem_obj(fb, 0);
 
@@ -789,9 +838,9 @@ static void sti_gdp_atomic_update(struct drm_plane *drm_plane,
 
 	/* pixel memory location */
 	bpp = fb->format->cpp[0];
-	top_field->gam_gdp_pml = (u32) dma_obj->dma_addr + fb->offsets[0];
-	top_field->gam_gdp_pml += src_x * bpp;
-	top_field->gam_gdp_pml += src_y * fb->pitches[0];
+	top_field[GAM_OFFSET_U32(PML, gdp->type)] = (u32)dma_obj->dma_addr + fb->offsets[0];
+	top_field[GAM_OFFSET_U32(PML, gdp->type)] += src_x * bpp;
+	top_field[GAM_OFFSET_U32(PML, gdp->type)] += src_y * fb->pitches[0];
 
 	/* output parameters (clamped / cropped) */
 	dst_w = sti_gdp_get_dst(gdp->dev, dst_w, src_w);
@@ -800,23 +849,25 @@ static void sti_gdp_atomic_update(struct drm_plane *drm_plane,
 	yds = sti_vtg_get_line_number(*mode, dst_y + dst_h - 1);
 	xdo = sti_vtg_get_pixel_number(*mode, dst_x);
 	xds = sti_vtg_get_pixel_number(*mode, dst_x + dst_w - 1);
-	top_field->gam_gdp_vpo = (ydo << 16) | xdo;
-	top_field->gam_gdp_vps = (yds << 16) | xds;
+	top_field[GAM_OFFSET_U32(VPO, gdp->type)] = (ydo << 16) | xdo;
+	top_field[GAM_OFFSET_U32(VPS, gdp->type)] = (yds << 16) | xds;
 
 	/* input parameters */
 	src_w = dst_w;
-	top_field->gam_gdp_pmp = fb->pitches[0];
-	top_field->gam_gdp_size = src_h << 16 | src_w;
+	top_field[GAM_OFFSET_U32(PMP, gdp->type)] = fb->pitches[0];
+	top_field[GAM_OFFSET_U32(SIZE, gdp->type)] = src_h << 16 | src_w;
 
 	/* Same content and chained together */
-	memcpy(btm_field, top_field, sizeof(*btm_field));
-	top_field->gam_gdp_nvn = list->btm_field_paddr;
-	btm_field->gam_gdp_nvn = list->top_field_paddr;
+	memcpy(btm_field, top_field,
+	       gdp->type == STI_GDP_TYPE_GDP ?
+	       GAM_GDP_NODE_SIZE : GAM_GDPPLUS_NODE_SIZE);
+	top_field[GAM_OFFSET_U32(NVN, gdp->type)] = list->btm_field_paddr;
+	btm_field[GAM_OFFSET_U32(NVN, gdp->type)] = list->top_field_paddr;
 
 	/* Interlaced mode */
 	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
-		btm_field->gam_gdp_pml = top_field->gam_gdp_pml +
-					 fb->pitches[0];
+		btm_field[GAM_OFFSET_U32(PML, gdp->type)] =
+			top_field[GAM_OFFSET_U32(PML, gdp->type)] + fb->pitches[0];
 
 	/* Update the NVN field of the 'right' field of the current GDP node
 	 * (being used by the HW) with the address of the updated ('free') top
@@ -832,10 +883,10 @@ static void sti_gdp_atomic_update(struct drm_plane *drm_plane,
 	dma_updated_btm = list->btm_field_paddr;
 
 	dev_dbg(gdp->dev, "Current NVN:0x%X\n",
-		readl(gdp->regs + GAM_GDP_NVN_OFFSET));
+		readl(gdp->regs + GAM_OFFSET(NVN, gdp->type)));
 	dev_dbg(gdp->dev, "Posted buff: %lx current buff: %x\n",
 		(unsigned long) dma_obj->dma_addr,
-		readl(gdp->regs + GAM_GDP_PML_OFFSET));
+		readl(gdp->regs + GAM_OFFSET(PML, gdp->type)));
 
 	if (!curr_list) {
 		/* First update or invalid node should directly write in the
@@ -845,7 +896,7 @@ static void sti_gdp_atomic_update(struct drm_plane *drm_plane,
 
 		writel(gdp->is_curr_top ?
 				dma_updated_btm : dma_updated_top,
-				gdp->regs + GAM_GDP_NVN_OFFSET);
+				gdp->regs + GAM_OFFSET(NVN, gdp->type));
 		goto end;
 	}
 
@@ -854,15 +905,15 @@ static void sti_gdp_atomic_update(struct drm_plane *drm_plane,
 			/* Do not update in the middle of the frame, but
 			 * postpone the update after the bottom field has
 			 * been displayed */
-			curr_list->btm_field->gam_gdp_nvn = dma_updated_top;
+			curr_list->btm_field[GAM_OFFSET_U32(NVN, gdp->type)] = dma_updated_top;
 		} else {
 			/* Direct update to avoid one frame delay */
 			writel(dma_updated_top,
-			       gdp->regs + GAM_GDP_NVN_OFFSET);
+			       gdp->regs + GAM_OFFSET(NVN, gdp->type));
 		}
 	} else {
 		/* Direct update for progressive to avoid one frame delay */
-		writel(dma_updated_top, gdp->regs + GAM_GDP_NVN_OFFSET);
+		writel(dma_updated_top, gdp->regs + GAM_OFFSET(NVN, gdp->type));
 	}
 
 end:
@@ -917,7 +968,7 @@ static const struct drm_plane_funcs sti_gdp_plane_helpers_funcs = {
 };
 
 struct drm_plane *sti_gdp_create(struct drm_device *drm_dev,
-				 struct device *dev, int desc,
+				 struct device *dev, enum sti_gdp_type gdp_type, int desc,
 				 void __iomem *baseaddr,
 				 unsigned int possible_crtcs,
 				 enum drm_plane_type type)
@@ -935,6 +986,7 @@ struct drm_plane *sti_gdp_create(struct drm_device *drm_dev,
 	gdp->regs = baseaddr;
 	gdp->plane.desc = desc;
 	gdp->plane.status = STI_PLANE_DISABLED;
+	gdp->type = gdp_type;
 
 	gdp->vtg_field_nb.notifier_call = sti_gdp_field_cb;
 
diff --git a/drivers/gpu/drm/sti/sti_gdp.h b/drivers/gpu/drm/sti/sti_gdp.h
index deb07e34173d..b1f06a0c5c37 100644
--- a/drivers/gpu/drm/sti/sti_gdp.h
+++ b/drivers/gpu/drm/sti/sti_gdp.h
@@ -16,8 +16,14 @@
 struct drm_device;
 struct device;
 
+enum sti_gdp_type {
+	STI_GDP_TYPE_GDP,
+	STI_GDP_TYPE_GDPPLUS,
+};
+
 struct drm_plane *sti_gdp_create(struct drm_device *drm_dev,
-				 struct device *dev, int desc,
+				 struct device *dev, enum sti_gdp_type gdp_type,
+				 int desc,
 				 void __iomem *baseaddr,
 				 unsigned int possible_crtcs,
 				 enum drm_plane_type type);
-- 
2.48.1

From 132c71287331a82082d535104ec5d553ebcc46d5 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 27 Jul 2023 21:51:34 +0000
Subject: [PATCH 62/72] drm/sti: add compositor support for stih418 platform

On the STiH418, a new clock (proc_mixer) must be enabled in order
to have the plane mixers properly behaving.  Add a new
st,stih418-compositor in order to describe the planes/mixers
available on this platform.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 drivers/gpu/drm/sti/sti_compositor.c | 26 ++++++++++++++++++++++++++
 drivers/gpu/drm/sti/sti_compositor.h |  2 ++
 drivers/gpu/drm/sti/sti_crtc.c       | 11 +++++++++++
 3 files changed, 39 insertions(+)

diff --git a/drivers/gpu/drm/sti/sti_compositor.c b/drivers/gpu/drm/sti/sti_compositor.c
index bee528d232f2..911257802cfe 100644
--- a/drivers/gpu/drm/sti/sti_compositor.c
+++ b/drivers/gpu/drm/sti/sti_compositor.c
@@ -43,6 +43,23 @@ static const struct sti_compositor_data stih407_compositor_data = {
 	},
 };
 
+/*
+ * stiH418 compositor properties
+ */
+static const struct sti_compositor_data stih418_compositor_data = {
+	.nb_subdev = 8,
+	.subdev_desc = {
+			{STI_GPDPLUS_SUBDEV, (int)STI_GDP_0, 0x00000},
+			{STI_GPDPLUS_SUBDEV, (int)STI_GDP_1, 0x10000},
+			{STI_GPDPLUS_SUBDEV, (int)STI_GDP_2, 0x20000},
+			{STI_GPDPLUS_SUBDEV, (int)STI_GDP_3, 0x30000},
+			{STI_GPD_SUBDEV, (int)STI_GDP_4, 0x40000},
+			{STI_GPD_SUBDEV, (int)STI_GDP_5, 0x50000},
+			{STI_MIXER_MAIN_SUBDEV, STI_MIXER_MAIN, 0x100000},
+			{STI_MIXER_AUX_SUBDEV, STI_MIXER_AUX, 0x110000},
+	},
+};
+
 void sti_compositor_debugfs_init(struct sti_compositor *compo,
 				 struct drm_minor *minor)
 {
@@ -169,6 +186,9 @@ static const struct of_device_id compositor_of_match[] = {
 	{
 		.compatible = "st,stih407-compositor",
 		.data = &stih407_compositor_data,
+	}, {
+		.compatible = "st,stih418-compositor",
+		.data = &stih418_compositor_data,
 	}, {
 		/* end node */
 	}
@@ -236,6 +256,12 @@ static int sti_compositor_probe(struct platform_device *pdev)
 		return PTR_ERR(compo->clk_pix_aux);
 	}
 
+	compo->clk_proc_mixer = devm_clk_get_optional(dev, "proc_mixer");
+	if (IS_ERR(compo->clk_proc_mixer)) {
+		DRM_ERROR("Cannot get proc_mixer clock\n");
+		return PTR_ERR(compo->clk_proc_mixer);
+	}
+
 	/* Get reset resources */
 	compo->rst_main = devm_reset_control_get_shared(dev, "compo-main");
 	/* Take compo main out of reset */
diff --git a/drivers/gpu/drm/sti/sti_compositor.h b/drivers/gpu/drm/sti/sti_compositor.h
index 62545210b96d..fdc655f78579 100644
--- a/drivers/gpu/drm/sti/sti_compositor.h
+++ b/drivers/gpu/drm/sti/sti_compositor.h
@@ -57,6 +57,7 @@ struct sti_compositor_data {
  * @clk_compo_aux: clock for aux compo
  * @clk_pix_main: pixel clock for main path
  * @clk_pix_aux: pixel clock for aux path
+ * @clk_proc_mixer: clock for the mixers
  * @rst_main: reset control of the main path
  * @rst_aux: reset control of the aux path
  * @mixer: array of mixers
@@ -72,6 +73,7 @@ struct sti_compositor {
 	struct clk *clk_compo_aux;
 	struct clk *clk_pix_main;
 	struct clk *clk_pix_aux;
+	struct clk *clk_proc_mixer;
 	struct reset_control *rst_main;
 	struct reset_control *rst_aux;
 	struct sti_mixer *mixer[STI_MAX_MIXER];
diff --git a/drivers/gpu/drm/sti/sti_crtc.c b/drivers/gpu/drm/sti/sti_crtc.c
index 3c7154f2d5f3..d93764e99b0e 100644
--- a/drivers/gpu/drm/sti/sti_crtc.c
+++ b/drivers/gpu/drm/sti/sti_crtc.c
@@ -67,6 +67,12 @@ sti_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *mode)
 		pix_clk = compo->clk_pix_aux;
 	}
 
+	/* Enable the mixer processing clock (if applicable) */
+	if (clk_prepare_enable(compo->clk_proc_mixer)) {
+		DRM_INFO("Failed to prepare/enable processing mixer clk\n");
+		goto proc_mixer_error;
+	}
+
 	/* Prepare and enable the compo IP clock */
 	if (clk_prepare_enable(compo_clk)) {
 		DRM_INFO("Failed to prepare/enable compositor clk\n");
@@ -97,6 +103,8 @@ sti_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *mode)
 pix_error:
 	clk_disable_unprepare(compo_clk);
 compo_error:
+	clk_disable_unprepare(compo->clk_proc_mixer);
+proc_mixer_error:
 	return -EINVAL;
 }
 
@@ -122,6 +130,9 @@ static void sti_crtc_disable(struct drm_crtc *crtc)
 		clk_disable_unprepare(compo->clk_compo_aux);
 	}
 
+	/* Disable the mixer clock (if applicable) */
+	clk_disable_unprepare(compo->clk_proc_mixer);
+
 	mixer->status = STI_MIXER_DISABLED;
 }
 
-- 
2.48.1

From 9b868f3e1ad4898d89ccfe29b4d0c992bab8fa17 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 27 Jul 2023 21:51:35 +0000
Subject: [PATCH 63/72] ARM: dts: sti: move vtg_main / vtg_aux into
 stih407/stih410 dtsi

In preparation of introduction of display support in stih418, move
the vtg nodes into stih407.dtsi and stih410.dtsi since vtg nodes
will differ in case of the stih418 and thus cannot be kept as part
of the stih407-family.dtsi.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/boot/dts/st/stih407-family.dtsi | 13 -------------
 arch/arm/boot/dts/st/stih407.dtsi        | 12 ++++++++++++
 arch/arm/boot/dts/st/stih410.dtsi        | 12 ++++++++++++
 3 files changed, 24 insertions(+), 13 deletions(-)

diff --git a/arch/arm/boot/dts/st/stih407-family.dtsi b/arch/arm/boot/dts/st/stih407-family.dtsi
index bf3bf88a99ac..0f7a9f62dba4 100644
--- a/arch/arm/boot/dts/st/stih407-family.dtsi
+++ b/arch/arm/boot/dts/st/stih407-family.dtsi
@@ -293,19 +293,6 @@ syscfg_lpm: lpm-syscfg@94b5100 {
 			reg = <0x94b5100 0x1000>;
 		};
 
-		/* Display */
-		vtg_main: sti-vtg-main@8d02800 {
-			compatible = "st,vtg";
-			reg = <0x8d02800 0x200>;
-			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
-		};
-
-		vtg_aux: sti-vtg-aux@8d00200 {
-			compatible = "st,vtg";
-			reg = <0x8d00200 0x100>;
-			interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
-		};
-
 		serial@9830000 {
 			compatible = "st,asc";
 			reg = <0x9830000 0x2c>;
diff --git a/arch/arm/boot/dts/st/stih407.dtsi b/arch/arm/boot/dts/st/stih407.dtsi
index aca43d2bdaad..69430556edc4 100644
--- a/arch/arm/boot/dts/st/stih407.dtsi
+++ b/arch/arm/boot/dts/st/stih407.dtsi
@@ -8,6 +8,18 @@
 #include <dt-bindings/gpio/gpio.h>
 / {
 	soc {
+		vtg_main: sti-vtg-main@8d02800 {
+			compatible = "st,vtg";
+			reg = <0x8d02800 0x200>;
+			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		vtg_aux: sti-vtg-aux@8d00200 {
+			compatible = "st,vtg";
+			reg = <0x8d00200 0x100>;
+			interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
 		sti-display-subsystem@0 {
 			compatible = "st,sti-display-subsystem";
 			#address-cells = <1>;
diff --git a/arch/arm/boot/dts/st/stih410.dtsi b/arch/arm/boot/dts/st/stih410.dtsi
index a69231854f78..3bcdc9ca76a0 100644
--- a/arch/arm/boot/dts/st/stih410.dtsi
+++ b/arch/arm/boot/dts/st/stih410.dtsi
@@ -99,6 +99,18 @@ ehci1: usb@9a83e00 {
 			status = "disabled";
 		};
 
+		vtg_main: sti-vtg-main@8d02800 {
+			compatible = "st,vtg";
+			reg = <0x8d02800 0x200>;
+			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
+		vtg_aux: sti-vtg-aux@8d00200 {
+			compatible = "st,vtg";
+			reg = <0x8d00200 0x100>;
+			interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+		};
+
 		sti-display-subsystem@0 {
 			compatible = "st,sti-display-subsystem";
 			#address-cells = <1>;
-- 
2.48.1

From b6f881b88a8e500d5195bb6e5dfc0c8566cb14fc Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 27 Jul 2023 21:51:36 +0000
Subject: [PATCH 64/72] ARM: dts: sti: addition of display nodes for stih418
 platform

Addition of a first set of nodes (compositor/tvout/hdmi/dvo) in order
to allow graphic plane usage via HDMI or DVO on the stih418 based boards.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/boot/dts/st/stih418-clock.dtsi |   2 +-
 arch/arm/boot/dts/st/stih418.dtsi       | 154 ++++++++++++++++++++++++
 2 files changed, 155 insertions(+), 1 deletion(-)

diff --git a/arch/arm/boot/dts/st/stih418-clock.dtsi b/arch/arm/boot/dts/st/stih418-clock.dtsi
index e1749e92a2e7..93641df58bf2 100644
--- a/arch/arm/boot/dts/st/stih418-clock.dtsi
+++ b/arch/arm/boot/dts/st/stih418-clock.dtsi
@@ -17,7 +17,7 @@ clk_sysin: clk-sysin {
 	clk_tmdsout_hdmi: clk-tmdsout-hdmi {
 		#clock-cells = <0>;
 		compatible = "fixed-clock";
-		clock-frequency = <0>;
+		clock-frequency = <594000000>;
 	};
 
 	clocks {
diff --git a/arch/arm/boot/dts/st/stih418.dtsi b/arch/arm/boot/dts/st/stih418.dtsi
index a1c325e3a6ee..c111db9fef35 100644
--- a/arch/arm/boot/dts/st/stih418.dtsi
+++ b/arch/arm/boot/dts/st/stih418.dtsi
@@ -6,6 +6,7 @@
 #include "stih418-clock.dtsi"
 #include "stih407-family.dtsi"
 #include "stih410-pinctrl.dtsi"
+#include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/thermal/thermal.h>
 / {
 	cpus {
@@ -154,5 +155,158 @@ thermal: thermal@91a0000 {
 			interrupts = <GIC_SPI 205 IRQ_TYPE_EDGE_RISING>;
 			#thermal-sensor-cells = <0>;
 		};
+
+		sti-display-subsystem@0 {
+			compatible = "st,sti-display-subsystem";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			reg = <0 0>;
+			assigned-clocks = <&clk_s_d2_quadfs 0>,
+					  <&clk_s_d2_quadfs 1>,
+					  <&clk_s_d2_flexgen CLK_TMDS_HDMI_DIV2>,
+					  <&clk_s_d2_flexgen CLK_TMDS_HDMI>,
+					  <&clk_s_d2_flexgen CLK_PIX_MAIN_DISP>,
+					  <&clk_s_d2_flexgen CLK_PIX_AUX_DISP>,
+					  <&clk_s_c0_flexgen CLK_MAIN_DISP>,
+					  <&clk_s_c0_flexgen CLK_AUX_DISP>,
+					  <&clk_s_c0_flexgen CLK_COMPO_DVP>,
+					  <&clk_s_c0_flexgen CLK_PROC_MIXER>;
+
+			assigned-clock-parents = <0>,
+						 <0>,
+						 <&clk_tmdsout_hdmi>,
+						 <&clk_tmdsout_hdmi>,
+						 <&clk_s_d2_quadfs 0>,
+						 <&clk_s_d2_quadfs 1>,
+						 <&clk_s_c0_pll1 0>,
+						 <&clk_s_c0_pll1 0>,
+						 <&clk_s_c0_pll0 0>,
+						 <&clk_s_c0_pll0 0>;
+
+			assigned-clock-rates = <297000000>,
+					       <108000000>,
+					       <297000000>,
+					       <0>,
+					       <74250000>,
+					       <13500000>,
+					       <400000000>,
+					       <400000000>,
+					       <355000000>,
+					       <355000000>;
+
+			ranges;
+
+			sti_compo: sti-compositor@a600000 {
+				compatible = "st,stih418-compositor";
+				reg = <0xa600000 0x200000>;
+
+				clock-names = "compo_main",
+					      "compo_aux",
+					      "pix_main",
+					      "pix_aux",
+					      "proc_mixer";
+
+				clocks = <&clk_s_c0_flexgen CLK_COMPO_DVP>,
+					 <&clk_s_c0_flexgen CLK_COMPO_DVP>,
+					 <&clk_s_d2_flexgen CLK_PIX_MAIN_DISP>,
+					 <&clk_s_d2_flexgen CLK_PIX_AUX_DISP>,
+					 <&clk_s_c0_flexgen CLK_PROC_MIXER>;
+
+				reset-names = "compo-main", "compo-aux";
+				resets = <&softreset STIH407_COMPO_SOFTRESET>,
+					 <&softreset STIH407_COMPO_SOFTRESET>;
+				st,vtg = <&vtg_main>, <&vtg_aux>;
+
+				status = "disabled";
+			};
+
+			sti_tvout: sti-tvout@a900000 {
+				compatible = "st,stih418-tvout";
+				reg = <0xa900000 0x1000>;
+				reg-names = "tvout-reg";
+				reset-names = "tvout";
+				resets = <&softreset STIH407_HDTVOUT_SOFTRESET>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				assigned-clocks = <&clk_s_d2_flexgen CLK_PIX_HDMI>,
+						  <&clk_s_d2_flexgen CLK_TMDS_HDMI>,
+						  <&clk_s_d2_flexgen CLK_REF_HDMIPHY>,
+						  <&clk_s_d0_flexgen CLK_PCM_0>,
+						  <&clk_s_d2_flexgen CLK_PIX_HDDAC>,
+						  <&clk_s_d2_flexgen CLK_HDDAC>;
+
+				assigned-clock-parents = <&clk_s_d2_quadfs 0>,
+							 <&clk_tmdsout_hdmi>,
+							 <&clk_s_d2_quadfs 0>,
+							 <&clk_s_d0_quadfs 0>,
+							 <&clk_s_d2_quadfs 0>,
+							 <&clk_s_d2_quadfs 0>;
+				assigned-clock-rates = <74250000>,
+						       <0>,
+						       <74250000>,
+						       <0>,
+						       <74250000>,
+						       <148500000>;
+
+				status = "disabled";
+			};
+
+			sti_dvo: sti-dvo@a800400 {
+				compatible = "st,stih407-dvo";
+				reg = <0xa800400 0x200>;
+				reg-names = "dvo-reg";
+				clock-names = "dvo_pix", "dvo",
+					      "main_parent", "aux_parent";
+				clocks = <&clk_s_d2_flexgen CLK_PIX_DVO>,
+					 <&clk_s_d2_flexgen CLK_DVO>,
+					 <&clk_s_d2_quadfs 0>, <&clk_s_d2_quadfs 1>;
+				status = "disabled";
+			};
+
+			sti_hdmi: sti-hdmi@a804000 {
+				compatible = "st,stih418-hdmi";
+				reg = <0xa804000 0x1000>;
+				reg-names = "hdmi-reg";
+				#sound-dai-cells = <0>;
+				interrupts = <GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "irq";
+				clock-names = "pix",
+					      "tmds",
+					      "phy",
+					      "audio",
+					      "main_parent",
+					      "aux_parent";
+
+				clocks = <&clk_s_d2_flexgen CLK_PIX_HDMI>,
+					 <&clk_s_d2_flexgen CLK_TMDS_HDMI>,
+					 <&clk_s_d2_flexgen CLK_REF_HDMIPHY>,
+					 <&clk_s_d0_flexgen CLK_PCM_0>,
+					 <&clk_s_d2_quadfs 0>,
+					 <&clk_s_d2_quadfs 1>;
+
+				hdmi,hpd-gpio = <&pio5 3 GPIO_ACTIVE_LOW>;
+				reset-names = "hdmi";
+				resets = <&softreset STIH407_HDMI_TX_PHY_SOFTRESET>;
+
+				status = "disabled";
+			};
+		};
+
+		vtg_main: sti-vtg-main@a802800 {
+			compatible = "st,stih418-vtg";
+			reg = <0xa802800 0x200>;
+			interrupts = <GIC_SPI 108 IRQ_TYPE_LEVEL_HIGH>;
+
+			status = "disabled";
+		};
+
+		vtg_aux: sti-vtg-aux@a800200 {
+			compatible = "st,stih418-vtg";
+			reg = <0xa800200 0x100>;
+			interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+
+			status = "disabled";
+		};
 	};
 };
-- 
2.48.1

From c7b6f79cda04dee6a949865bedfd9684d6f04e9d Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 27 Jul 2023 21:51:37 +0000
Subject: [PATCH 65/72] ARM: dts: sti: add the gpu node for the MALI-400 on
 stih418.dtsi

Add the gpu node for the MALI-400 found on stih418 soc.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/boot/dts/st/stih418.dtsi | 34 +++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/arch/arm/boot/dts/st/stih418.dtsi b/arch/arm/boot/dts/st/stih418.dtsi
index c111db9fef35..2208f39e551e 100644
--- a/arch/arm/boot/dts/st/stih418.dtsi
+++ b/arch/arm/boot/dts/st/stih418.dtsi
@@ -308,5 +308,39 @@ vtg_aux: sti-vtg-aux@a800200 {
 
 			status = "disabled";
 		};
+
+		gpu: gpu@9f00000 {
+			compatible = "arm,mali-400";
+			reg = <0x9f00000 0x10000>;
+			/* LIMA driver needs 2 clocks, use the same for both */
+			clocks = <&clk_s_c0_flexgen CLK_ICN_GPU>,
+				 <&clk_s_c0_flexgen CLK_ICN_GPU>;
+			clock-names = "bus", "core";
+			assigned-clocks = <&clk_s_c0_flexgen CLK_ICN_GPU>;
+			assigned-clock-rates = <400000000>;
+			resets = <&softreset STIH407_GPU_SOFTRESET>;
+			interrupts = <GIC_SPI 49 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 46 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 48 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "gp",
+					  "gpmmu",
+					  "pp0",
+					  "ppmmu0",
+					  "pp1",
+					  "ppmmu1",
+					  "pp2",
+					  "ppmmu2",
+					  "pp3",
+					  "ppmmu3";
+
+			status = "disabled";
+		};
 	};
 };
-- 
2.48.1

From c55a7bb715a36e1170fc9b52a10179a78706b5d4 Mon Sep 17 00:00:00 2001
From: Alain Volmat <avolmat@me.com>
Date: Thu, 27 Jul 2023 21:51:38 +0000
Subject: [PATCH 66/72] ARM: dts: sti: enable basic display on stih418-b2264
 board

Enable the compositor, tvout, hdmi and gpu on the B2264 board.

Signed-off-by: Alain Volmat <avolmat@me.com>
---
 arch/arm/boot/dts/st/stih418-b2264.dts | 34 ++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/arch/arm/boot/dts/st/stih418-b2264.dts b/arch/arm/boot/dts/st/stih418-b2264.dts
index e53e972cc3b4..e07cec0af093 100644
--- a/arch/arm/boot/dts/st/stih418-b2264.dts
+++ b/arch/arm/boot/dts/st/stih418-b2264.dts
@@ -116,6 +116,14 @@ st,pins {
 			};
 		};
 
+		hdmiddc: i2c@9541000 {
+			/* HDMI V1.3a supports Standard mode only */
+			clock-frequency = <100000>;
+			st,i2c-min-scl-pulse-width-us = <0>;
+			st,i2c-min-sda-pulse-width-us = <5>;
+
+			status = "okay";
+		};
 	};
 };
 
@@ -213,6 +221,32 @@ &st_dwc3 {
 	status = "okay";
 };
 
+&sti_compo {
+	status = "okay";
+};
+
+&sti_tvout {
+	status = "okay";
+};
+
+&sti_hdmi {
+	ddc = <&hdmiddc>;
+
+	status = "okay";
+};
+
+&vtg_main {
+	status = "okay";
+};
+
+&vtg_aux {
+	status = "okay";
+};
+
+&gpu {
+	status = "okay";
+};
+
 &sti_uni_player2 {
 	status = "okay";
 };
-- 
2.48.1

From 2410132aeb643fabba59793800cdabb8e7045729 Mon Sep 17 00:00:00 2001
From: Jerome Audu <jau@free.fr>
Date: Wed, 10 May 2023 23:24:34 +0200
Subject: [PATCH 67/72] ARM: dts: sti: enable HDMI audio output on
 stih418-b2264

---
 arch/arm/boot/dts/st/stih418-b2264.dts | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/arch/arm/boot/dts/st/stih418-b2264.dts b/arch/arm/boot/dts/st/stih418-b2264.dts
index e07cec0af093..e82ca9cf7cdb 100644
--- a/arch/arm/boot/dts/st/stih418-b2264.dts
+++ b/arch/arm/boot/dts/st/stih418-b2264.dts
@@ -91,6 +91,21 @@ codec {
 				sound-dai = <&sti_sasg_codec 1>;
 			};
 		};
+
+		simple-audio-card,dai-link@1 {
+			reg = <1>;
+			/* HDMI */
+			format = "i2s";
+			mclk-fs = <128>;
+			cpu {
+				sound-dai = <&sti_uni_player0>;
+			};
+
+			codec {
+				sound-dai = <&sti_hdmi>;
+			};
+		};
+
 	};
 
 	leds {
@@ -247,6 +262,10 @@ &gpu {
 	status = "okay";
 };
 
+&sti_uni_player0 {
+	status = "okay";
+};
+
 &sti_uni_player2 {
 	status = "okay";
 };
-- 
2.48.1

From b14c8a3c166543bb503ead0f683a4c43540cd05a Mon Sep 17 00:00:00 2001
From: Jerome Audu <jau@free.fr>
Date: Wed, 17 May 2023 23:18:50 +0200
Subject: [PATCH 68/72] ARM: dts: sti: add STi-CEC node on stih418.dtsi

Signed-off-by: Jerome Audu <jau@free.fr>
---
 arch/arm/boot/dts/st/stih418.dtsi | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/arch/arm/boot/dts/st/stih418.dtsi b/arch/arm/boot/dts/st/stih418.dtsi
index 2208f39e551e..3287f5935fd4 100644
--- a/arch/arm/boot/dts/st/stih418.dtsi
+++ b/arch/arm/boot/dts/st/stih418.dtsi
@@ -309,6 +309,19 @@ vtg_aux: sti-vtg-aux@a800200 {
 			status = "disabled";
 		};
 
+		cec: cec@94a087c {
+			compatible = "st,stih-cec";
+			reg = <0x94a087c 0x64>;
+			clocks = <&clk_sysin>;
+			clock-names = "cec-clk";
+			interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "cec-irq";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_cec0_default>;
+			resets = <&softreset STIH407_LPM_SOFTRESET>;
+			hdmi-phandle = <&sti_hdmi>;
+		};
+
 		gpu: gpu@9f00000 {
 			compatible = "arm,mali-400";
 			reg = <0x9f00000 0x10000>;
-- 
2.48.1

From 7bdb3d73193d3ee8e0a8125cf73c23822bda17b1 Mon Sep 17 00:00:00 2001
From: Jerome Audu <jau@free.fr>
Date: Thu, 18 May 2023 00:13:23 +0200
Subject: [PATCH 69/72] ARM: dts: sti: enable STi-CEC on stih418-b2264

Signed-off-by: Jerome Audu <jau@free.fr>
---
 arch/arm/boot/dts/st/stih418-b2264.dts | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/arch/arm/boot/dts/st/stih418-b2264.dts b/arch/arm/boot/dts/st/stih418-b2264.dts
index e82ca9cf7cdb..aca5a3aa28a2 100644
--- a/arch/arm/boot/dts/st/stih418-b2264.dts
+++ b/arch/arm/boot/dts/st/stih418-b2264.dts
@@ -258,6 +258,10 @@ &vtg_aux {
 	status = "okay";
 };
 
+&cec {
+	status = "okay";
+};
+
 &gpu {
 	status = "okay";
 };
-- 
2.48.1

From cbed4eea64dfa7f1759ca399ede832a6464d61cd Mon Sep 17 00:00:00 2001
From: Jerome Audu <jerome.audu@st.com>
Date: Tue, 12 Mar 2024 14:52:39 +0100
Subject: [PATCH 70/72] fixup! drm/sti: add support for VTG on the stih418
 platform

---
 drivers/gpu/drm/sti/sti_vtg.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/gpu/drm/sti/sti_vtg.c b/drivers/gpu/drm/sti/sti_vtg.c
index 19d1e4099972..9febeece7a72 100644
--- a/drivers/gpu/drm/sti/sti_vtg.c
+++ b/drivers/gpu/drm/sti/sti_vtg.c
@@ -10,6 +10,7 @@
 #include <linux/module.h>
 #include <linux/io.h>
 #include <linux/notifier.h>
+#include <linux/of.h>
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
 
-- 
2.48.1

From 214fca5b8295904969dc38d04f10dc8aa919a211 Mon Sep 17 00:00:00 2001
From: Jerome Audu <jerome.audu@st.com>
Date: Tue, 12 Mar 2024 14:53:12 +0100
Subject: [PATCH 71/72] fixup! drm/sti: add support for stih418 in tvout

---
 drivers/gpu/drm/sti/sti_tvout.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/gpu/drm/sti/sti_tvout.c b/drivers/gpu/drm/sti/sti_tvout.c
index 8406ce5a2e6e..fc6e58937ead 100644
--- a/drivers/gpu/drm/sti/sti_tvout.c
+++ b/drivers/gpu/drm/sti/sti_tvout.c
@@ -10,6 +10,7 @@
 #include <linux/component.h>
 #include <linux/io.h>
 #include <linux/module.h>
+#include <linux/of.h>
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
 #include <linux/reset.h>
-- 
2.48.1

From ecffacb65e936db492be30ab77ee501d6590617a Mon Sep 17 00:00:00 2001
From: Jerome Audu <jau@free.fr>
Date: Wed, 22 Jan 2025 14:20:38 +0100
Subject: [PATCH 72/72] drm/sti: fix for drm_crtc_vblank_off support

Since Linux 4.17, calls to drm_crtc_vblank_off are mandatory, and we get
a warning when ctrc is disabled :
"driver forgot to call drm_crtc_vblank_off()"
---
 drivers/gpu/drm/sti/sti_crtc.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/gpu/drm/sti/sti_crtc.c b/drivers/gpu/drm/sti/sti_crtc.c
index d93764e99b0e..6f4d56548045 100644
--- a/drivers/gpu/drm/sti/sti_crtc.c
+++ b/drivers/gpu/drm/sti/sti_crtc.c
@@ -43,6 +43,7 @@ static void sti_crtc_atomic_disable(struct drm_crtc *crtc,
 	mixer->status = STI_MIXER_DISABLING;
 
 	drm_crtc_wait_one_vblank(crtc);
+	drm_crtc_vblank_off(crtc);
 }
 
 static int
-- 
2.48.1

